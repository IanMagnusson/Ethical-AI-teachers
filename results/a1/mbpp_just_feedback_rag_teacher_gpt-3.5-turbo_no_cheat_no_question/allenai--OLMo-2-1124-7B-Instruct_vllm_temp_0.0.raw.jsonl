{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    # Convert lists to sets to remove duplicates and for efficient intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Use the intersection method to find common elements\n    shared_elements = set1.intersection(set2)\n    \n    return shared_elements\n\n# Test the function with the provided example\nassert set(similar_elements((3, 4, 5, 6), (5, 7, 4, 10))) == set((4, 5))"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    # Base cases: 0 and 1 are not prime\n    if n <= 1:\n        return True\n    # 2 is the only even prime number\n    if n == 2:\n        return False  # 2 is not considered a non-prime number in the traditional sense, but for consistency, we return False here\n    # All other even numbers are not prime\n    if not n & 1:  # n is even\n        return False\n    # Check for divisibility by all odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False\n\n# Test cases to validate the function"}
{"task_id": "Mbpp/4", "solution": "import heapq\n\ndef find_n_largest_elements(lst, n):\n    \"\"\"\n    Finds the n largest elements in a list.\n\n    Parameters:\n    - lst (list): The input list.\n    - n (int): The number of largest elements to find.\n\n    Returns:\n    - list: A list containing the n largest elements from lst.\n    \"\"\"\n    # Use heapq.nlargest to directly get the n largest elements\n    return heapq.nlargest(n, lst)\n\n# Example usage:\nnumbers = [3, 1, 4, 2, 5, 6, 7]\nn = 3\nlargest_elements = find_n_largest_elements(numbers, n)"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(n1, n2):\n    # Convert the numbers to their binary string representations\n    bin_str_n1 = bin(n1)[2:]  # Strip the '0b' prefix\n    bin_str_n2 = bin(n2)[2:]  # Strip the '0b' prefix\n\n    # Initialize a counter for the differing bits\n    differing_bits = 0\n\n    # Iterate over the binary strings character by character\n    for i in range(len(bin_str_n1)):\n        # Compare the current bits\n        if bin_str_n1[i] != bin_str_n2[i]:\n            # If they differ, increment the counter\n            differing_bits += 1\n\n    # Return the number of differing bits (which should be exactly one if they differ at exactly one bit)\n    return differing_bits == 1\n\n# Test cases"}
{"task_id": "Mbpp/7", "solution": "def find_long_words(text):\n    # Split the text into words\n    words = text.split()\n    \n    # Initialize an empty set to store long words\n    long_words = set()\n    \n    # Iterate through each word\n    for word in words:\n        # Check if the word is at least 4 characters long\n        if len(word) >= 4:\n            # Add the word to the set of long words\n            long_words.add(word)\n    \n    # Return the set of long words\n    return long_words\n\n# Test cases to validate the function"}
{"task_id": "Mbpp/8", "solution": "def square_nums(lst):\n    \"\"\"\n    Function to find squares of individual elements in a list.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        list: A new list containing the squares of the elements in the input list.\n    \"\"\"\n    return [x ** 2 for x in lst]\n\n# Test the function\nassert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "Mbpp/9", "solution": "def find_minimum_rotations(rotations):\n    min_rotations = float('inf')  # Initialize with infinity to ensure any rotation is smaller\n    for rotation in rotations:\n        if rotation < min_rotations:\n            min_rotations = rotation  # Update the minimum rotation found\n    return min_rotations\n\n# Example usage:\n# rotations = [45, 30, 60, 20]\n# min_rotation = find_minimum_rotations(rotations)\n# print(min_rotation)  # This should print 20\n\n# Test cases\ntest_rotations = [45, 30, 60, 20]\nassert find_minimum_rotations(test_rotations) == 20\n\n# Another set of test cases with negative values\ntest_rotations_negative = [-45, -30, -60, -20]\nassert find_minimum_rotations(test_rotations_negative) == -20\n\n# Case with all zeros\ntest_rotations_zeros = [0, 0, 0, 0]\nassert find_minimum_rotations(test_rotations_zeros) == 0\n"}
{"task_id": "Mbpp/11", "solution": "def remove_first_last_occurrences(string, char):\n    \"\"\"\n    Replaces the first and last occurrences of a given character in a string.\n    \n    Parameters:\n    string (str): The input string.\n    char (str): The character to be replaced.\n    \n    Returns:\n    str: The string with the first and last occurrences of 'char' removed.\n    \"\"\"\n    # Ensure the input is valid\n    if not isinstance(string, str) or not isinstance(char, str):\n        raise ValueError(\"Both string and char must be of type str.\")\n    \n    # Check if the character exists in the string\n    if char not in string:\n        return string\n    \n    # Create a new string with the first and last occurrences of 'char' removed\n    new_string = string[1:-1]\n    \n    return new_string\n\n# Test cases"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix_by_row_sums(matrix):\n    \"\"\"\n    Sorts a 2D list (matrix) based on the sums of each row.\n    \"\"\"\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Sort the matrix based on the row sums\n    sorted_matrix = sorted(matrix, key=lambda x: row_sums.index(x[0]))\n    \n    return sorted_matrix\n\n# Example usage:\n# Original matrix\nmatrix = [[5, 2, 8], [1, 9, 3], [7, 6, 4]]\n\n# Sort the matrix\nsorted_matrix = sort_matrix_by_row_sums(matrix)\n\n# Print the sorted matrix"}
{"task_id": "Mbpp/14", "solution": "import math\n\ndef calculate_prism_volume(base_length, height, base_width):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangle.\n    height (float): The height of the prism.\n    base_width (float): The width of the base of the triangle.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Correct formula for the volume of a triangular prism\n    # V = 0.5 * base_length * base_width * height\n    volume = 0.5 * base_length * base_width * height\n    return volume\n\n# Test cases to validate the function\nassert calculate_prism_volume(3, 4, 2) == 12.0\nassert calculate_prism_volume(5, 6, 3) == 45.0\nassert calculate_prism_volume(1.5, 7, 1.2) == 10.5\n"}
{"task_id": "Mbpp/16", "solution": "def identify_sequences(input_string):\n    \"\"\"\n    Identifies sequences of lowercase letters joined by underscores in an input string.\n\n    Args:\n        input_string (str): The input string to be analyzed.\n\n    Returns:\n        list: A list of tuples, where each tuple contains a sequence of lowercase letters joined by underscores.\n\n    Examples:\n        >>> identify_sequences('abc_def_ghi_jkl')\n        [('abc', '_'), ('def', '_'), ('ghi', '_'), ('jkl', '_')]\n    \"\"\"\n    sequences = []\n    words = input_string.split('_')\n    for word in words:\n        if word.isalpha() and len(word) > 1:\n            sequences.append((word, '_'))\n    return sequences\n\n# Test cases"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Returns the perimeter of a square given its side length.\n    \n    Args:\n        side_length (int): The length of a side of the square.\n        \n    Returns:\n        int: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Test the function\nassert square_perimeter(10) == 40"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(first_string, second_string):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n    \n    Args:\n        first_string (str): The first string from which characters are to be removed.\n        second_string (str): The string containing characters to be removed from the first string.\n        \n    Returns:\n        str: The first string with characters from the second string removed.\n    \"\"\"\n    result = \"\"\n    for char in first_string:\n        if char not in second_string:\n            result += char\n    return result\n\n# Test cases\nassert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'\nassert remove_dirty_chars(\"hello\", \"llo\") == 'he'\nassert remove_dirty_chars(\"python\", \"on\") == 'pyt'\nassert remove_dirty_chars(\"world\", \"d\") == 'wr'"}
{"task_id": "Mbpp/19", "solution": "def has_duplicates(lst):\n    \"\"\"\n    Determines if the list contains any duplicate elements.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        bool: True if the list contains duplicates, False otherwise.\n    \"\"\"\n    # Input validation\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list.\")\n    for item in lst:\n        if not isinstance(item, int):\n            raise ValueError(\"List elements must be integers.\")\n    \n    # Check for duplicates\n    seen = set()\n    for num in lst:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\n# Testing the function with various inputs"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\"\"\"\n    # Woodall numbers are of the form 2*2^k - 1\n    # We need to check if (2 * 2^k) - 1 is a power of 2\n    k = 0\n    while (2 * (2**k)) - 1 > 1:\n        k += 1\n    return (2 * (2**k)) - 1 == 2**k\n\n# Testing the function"}
{"task_id": "Mbpp/56", "solution": "def check(num):\n    # Calculate the reverse of the number\n    reverse = int(str(num)[::-1])\n    \n    # Calculate twice the reverse\n    twice_reverse = 2 * reverse\n    \n    # Check if the given number is one less than twice its reverse\n    if num == twice_reverse - 1:\n        return True\n    else:\n        return False\n\n# Test the function with the provided example\nassert check(70) == False  # This should evaluate to False"}
{"task_id": "Mbpp/57", "solution": "def sort_and_construct_descending_number(sorted_digits):\n    # Sort the digits in descending order\n    sorted_digits.sort(reverse=True)\n    \n    # Initialize max_num with the first digit\n    max_num = sorted_digits[0]\n    \n    # Loop through the sorted digits to construct the largest number\n    for digit in sorted_digits[1:]:\n        # Ensure correct comparison with the last digit of max_num\n        if digit > max_num[-1]:\n            max_num = digit\n    \n    return max_num\n\n# Test the function\nsorted_digits = [9, 8, 7, 6, 5]\nresult = sort_and_construct_descending_number(sorted_digits)"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(num1, num2):\n    \"\"\"\n    Check if two integers have opposite signs.\n    \n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n        \n    Returns:\n        bool: True if num1 and num2 have opposite signs, False otherwise.\n    \"\"\"\n    return num1 * num2 < 0\n\n# Test cases"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal_number(n):\n    \"\"\"\n    Check if a number is an octagonal number.\n    \n    An octagonal number is defined as the sum of the first (n-3) triangular numbers.\n    The formula to check if a number is octagonal is:\n    n^2 - 2n + 1 = T(n-3)\n    where T(k) is the k-th triangular number, calculated as (k*(k+1))/2.\n    \"\"\"\n    # Calculate the (n-3)th triangular number\n    triangular_number = (n - 3) * (n - 3 + 1) // 2\n    \n    # Check if the number is octagonal\n    return n**2 - 2*n + 1 == triangular_number\n\n# Test cases"}
{"task_id": "Mbpp/61", "solution": "def sum_of_digits_in_substring(string):\n    \"\"\"\n    Calculate the sum of digits of the current substring correctly.\n    \n    Parameters:\n    string (str): The input string\n    \n    Returns:\n    int: The sum of digits in the current substring\n    \"\"\"\n    # Initialize the sum of digits to 0\n    sum_digits = 0\n    \n    # Iterate over the string, slicing it into substrings of length 1\n    for char in string:\n        # Convert the character to an integer and sum its digits\n        sum_digits += sum(int(char) for char in str(char))\n    \n    return sum_digits\n\n# Test the function with some examples"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a given list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    return min(lst)\n\n# Test case\nassert smallest_num([10, 20, 1, 45, 99]) == 1"}
{"task_id": "Mbpp/63", "solution": "def calculate_tuple_differences(tuples_list):\n    # Ensure the input is a list of tuples\n    if not isinstance(tuples_list, list):\n        raise TypeError(\"Input must be a list of tuples.\")\n\n    differences = []\n    for i in range(len(tuples_list) - 1):  # Iterate over pairs of tuples\n        tuple1, tuple2 = tuples_list[i], tuples_list[i + 1]\n        difference = tuple(abs(a - b) for a, b in zip(tuple1, tuple2))\n        differences.append(difference)\n    return differences\n\n# Example usage\ntuples_list = [(1, 2), (3, 4), (5, 6)]\nresult = calculate_tuple_differences(tuples_list)"}
{"task_id": "Mbpp/64", "solution": "def sort_tuples_by_second(tuples):\n    return sorted(tuples, key=lambda x: x[1])\n\n# Test the function\ntuples_list = [(3, 'a'), (1, 'b'), (5, 'c'), (2, 'd'), (4, 'e')]\nsorted_list = sort_tuples_by_second(tuples_list)"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    \"\"\"\n    Function to flatten a list and sum all of its elements recursively.\n    \"\"\"\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n\n# Test case\nassert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"}
{"task_id": "Mbpp/66", "solution": "def pos_count(numbers):\n    \"\"\"\n    Count the number of positive numbers in a list.\n    \n    :param numbers: List of numbers\n    :return: Count of positive numbers in the list\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n\n# Test cases\nassert pos_count([1, -2, 3, -4]) == 2\nassert pos_count([5, 6, 7, 8, 9]) == 5\nassert pos_count([-1, -2, -3, -4, -5]) == 0\nassert pos_count([0, 0, 0]) == 0"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    # Initialize the first Bell number\n    bell_numbers = [1]\n    \n    # Generate Bell numbers up to the nth Bell number\n    for i in range(1, n):\n        next_bell = sum(bell_numbers[:i])  # Correctly sum the first 'i' Bell numbers\n        bell_numbers.append(next_bell)\n    \n    return bell_numbers[n-1]  # Return the nth Bell number\n\n# Test the function with some examples"}
{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr1, arr2):\n    \"\"\"\n    Determines if the first array is monotonic increasing or decreasing\n    and the second array is monotonic increasing or decreasing.\n    \"\"\"\n    # Check if both arrays are lists\n    if not isinstance(arr1, list) or not isinstance(arr2, list):\n        return False\n\n    # Check if both arrays are non-empty\n    if len(arr1) == 0 or len(arr2) == 0:\n        return False\n\n    # Check if the first array is monotonic increasing\n    is_increasing1 = all(arr1[i] <= arr1[i + 1] for i in range(len(arr1) - 1))\n\n    # Check if the second array is monotonic increasing\n    is_increasing2 = all(arr2[i] <= arr2[i + 1] for i in range(len(arr2) - 1))\n\n    return is_increasing1 and is_increasing2\n\n# Example usage:\n# Incorrect call with nested arrays and boolean values\nincorrect_call = is_Monotonic([1, 2, 3], False)\n\n# Correct call with separate list arguments\ncorrect_call = is_Monotonic([1, 2, 3], [4, 5, 6])\n"}
{"task_id": "Mbpp/69", "solution": "def check_sublist_order(main_list, target_sublist):\n    # Check if the target_sublist is a sublist of main_list by comparing their orders\n    if target_sublist == sorted(main_list):\n        return True\n    else:\n        return False\n\n# Test cases\nmain_list = [1, 2, 3, 4, 5]\ntarget_sublist = [3, 4]  # This is a sublist in the correct order\nassert check_sublist_order(main_list, target_sublist) == True\n\ntarget_sublist = [3, 4]  # This is a sublist but not in the correct order\nassert check_sublist_order(main_list, target_sublist) == False\n\ntarget_sublist = [5, 4, 3]  # This is not a sublist at all\nassert check_sublist_order(main_list, target_sublist) == False\n"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    # Check if all tuples have the same length\n    common_length = len(tuples[0])\n    for tup in tuples:\n        if len(tup) != common_length:\n            return False\n    return True\n\n# Test the function\nassert get_equal([(11, 22, 33), (44, 55, 66)]) == True\nassert get_equal([(11, 22, 33), (44, 55)]) == False"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(lst):\n    \"\"\"\n    Sorts a list of elements in ascending order.\n    \n    Args:\n        lst (list): A list of elements to be sorted.\n        \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    return sorted(lst)\n\n# Test the function\nassert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"}
{"task_id": "Mbpp/72", "solution": "import math\n\ndef is_difference_of_squares(n):\n    \"\"\"\n    Check if a number can be represented as the difference of two squares.\n    \"\"\"\n    # Check if the number is a perfect square\n    root_n = math.isqrt(n)\n    if root_n * root_n != n:\n        return False\n\n    # Check if n can be expressed as (a^2 - b^2) = (a+b)(a-b)\n    # This requires that (a+b) and (a-b) are both integers\n    # Therefore, (a+b) and (a-b) must both be even or both odd\n\n    # (a+b) and (a-b) must be either both even or both odd\n    # If root_n is even, both factors must be even\n    # If root_n is odd, one factor must be even and the other odd\n\n    # Factorize root_n\n    if root_n % 2 == 0:\n        factor1 = root_n // 2\n        factor2 = root_n // factor1\n    else:\n        factor1 = root_n // 2 + 1\n        factor2 = root_n // (2 * factor1)\n\n    # Check if both factors are either even or odd\n    return factor1 % 2 == factor2 % 2\n\n# Example usage:\n# Testing with some values\nresults = {n: is_difference_of_squares(n) for n in range(1, 101)}\n"}
{"task_id": "Mbpp/74", "solution": "def separate_lists(input_list):\n    \"\"\"\n    This function takes a combined list of test cases and separates them into two separate lists:\n    one for successful inputs and one for failed inputs.\n    \"\"\"\n    # Assuming the first half of the list are successful inputs and the second half are failed inputs\n    successful_inputs = input_list[:len(input_list) // 2]\n    failed_inputs = input_list[len(input_list) // 2:]\n\n    return successful_inputs, failed_inputs\n\n# Example usage:\n# Combined list of test cases (assuming the first half are successful and the second half are failed)\ncombined_test_cases = [1, 2, 3, 'a', 4, 'b', 5, 'c', 'd']\n\n# Separate the lists\nsuccessful, failed = separate_lists(combined_test_cases)\n\n# Print the results"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples in the list where all elements are divisible by k.\n    \n    Args:\n    tuples_list (list): A list of tuples.\n    k (int): The divisor to check for divisibility.\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(el % k == 0 for el in tup):\n            result.append(tup)\n    return result\n\n# Test the function\nassert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"}
{"task_id": "Mbpp/77", "solution": "def is_Diff(n):\n    \"\"\"\n    Check if a number is divisible by 11.\n    \"\"\"\n    return n % 11 == 0\n\n# Test cases\nassert is_Diff(12345) == False, \"Test case 12345 failed\"\nassert is_Diff(11) == True, \"Test case 11 failed\"\nassert is_Diff(0) == True, \"Test case 0 failed\"\nassert is_Diff(100) == False, \"Test case 100 failed\""}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    Check if the length of the word is odd.\n    \n    Args:\n        word (str): The word to check.\n        \n    Returns:\n        bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0\n\n# Test cases\nassert word_len(\"Hadoop\") == False  # Expected: False, because \"Hadoop\" has an even length\nassert word_len(\"Python\") == True   # Expected: True, because \"Python\" has an odd length\nassert word_len(\"hello\") == False  # Expected: False, because \"hello\" has an even length\nassert word_len(\"Elephant\") == True # Expected: True, because \"Elephant\" has an odd length"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n    \n    :param n: int, the position of the tetrahedral number\n    :return: int, the nth tetrahedral number\n    \"\"\"\n    # Formula for the nth tetrahedral number: T(n) = n*(n+1)*(n+2)/6\n    return n * (n + 1) * (n + 2) // 6\n\n# Test the function\nassert tetrahedral_number(5) == 35"}
{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    :param radius: float, the radius of the sphere\n    :return: float, the volume of the sphere\n    \"\"\"\n    return (4/3) * math.pi * radius**3\n\n# Test the function with the provided example\nassert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)"}
{"task_id": "Mbpp/84", "solution": "def newman_conway_sequence(n):\n    \"\"\"\n    Generate the first n terms of the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as follows:\n    - a(0) = 1\n    - b(0) = 1\n    - For n >= 1:\n        a(n) = a(n-1) + b(n-1)\n        b(n) = 2 * a(n-1) - b(n-1)\n    \"\"\"\n    if n < 1:\n        return []\n\n    a, b = 1, 1  # Initial values for a(0) and b(0)\n\n    sequence = [a, b]\n    for _ in range(1, n):\n        a, b = a + b, 2 * a - b\n        sequence.append(a)\n\n    return sequence\n\n# Example usage:"}
{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n    \n    Args:\n        radius (float): The radius of the sphere.\n        \n    Returns:\n        float: The surface area of the sphere.\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n\n# Test the function with the given radius\nassert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n    \n    The formula for the nth centered hexagonal number is:\n    H_n = n * (5n - 3) / 2\n    \n    Args:\n    n (int): The position of the centered hexagonal number.\n    \n    Returns:\n    int: The nth centered hexagonal number.\n    \"\"\"\n    return n * (5 * n - 3) // 2\n\n# Test cases to validate the function\nassert centered_hexagonal_number(1) == 1\nassert centered_hexagonal_number(2) == 6\nassert centered_hexagonal_number(3) == 15\nassert centered_hexagonal_number(4) == 28\nassert centered_hexagonal_number(5) == 45\n"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    # Merge dict2 and dict3 first\n    merged_dict2_3 = {**dict2, **dict3}\n    \n    # Merge the result with dict1\n    final_dict = {**dict1, **merged_dict2_3}\n    \n    return final_dict\n\n# Test the function with the provided example\nassert merge_dictionaries_three(\n    {\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"},\n    {\"G\": \"Green\", \"W\": \"White\"},\n    {\"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\"}\n) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all elements in a list.\n    \n    Args:\n        lst (list): A list of elements.\n        \n    Returns:\n        dict: A dictionary where keys are the unique elements from the list and values are their corresponding frequencies.\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict\n\n# Test the function\nassert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}"}
{"task_id": "Mbpp/89", "solution": "def closest_smaller(n):\n    \"\"\"\n    Finds the closest smaller number than 'n'.\n    \"\"\"\n    # Check if n is already smaller than 1\n    if n < 1:\n        return 0\n\n    # If n is 1, the closest smaller number is 0\n    if n == 1:\n        return 0\n\n    # For n > 1, the closest smaller number is n - 1\n    return n - 1\n\n# Test cases"}
{"task_id": "Mbpp/90", "solution": "def longest_word_length(words):\n    \"\"\"\n    Returns the length of the longest word in the given list of words.\n    \n    Args:\n        words (list): A list of strings representing words.\n        \n    Returns:\n        int: The length of the longest word in the list.\n        \n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not words:\n        raise ValueError(\"Input list is empty.\")\n    \n    longest_length = max(len(word) for word in words)\n    return longest_length\n\n# Test cases"}
{"task_id": "Mbpp/91", "solution": "def find_substring(strings, substring):\n    \"\"\"\n    Check if a substring is present in a list of strings.\n    \n    :param strings: List of strings.\n    :param substring: The substring to search for.\n    :return: True if the substring is found in any string in the list, False otherwise.\n    \"\"\"\n    for s in strings:\n        if substring in s:\n            return True\n    return False\n\n# Test cases\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"], \"ack\") == True\nassert find_substring([\"apple\", \"banana\", \"cherry\"], \"ry\") == False\nassert find_substring([\"hello\", \"world\"], \"lo\") == True\nassert find_substring([\"python\", \"java\", \"ruby\"], \"va\") == False"}
{"task_id": "Mbpp/92", "solution": "def correct_digit_comparison(input_str):\n    \"\"\"\n    Corrects the issue in the loop logic for comparing digits in an input string.\n    \n    Args:\n        input_str (str): The input string to be processed.\n        \n    Returns:\n        str: The input string with adjacent digits correctly compared.\n    \"\"\"\n    # Ensure the input is a string\n    if not isinstance(input_str, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Initialize an empty string to store the corrected digits\n    corrected_str = \"\"\n    \n    # Iterate over each character in the input string\n    for char in input_str:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Get the digit value\n            digit = int(char)\n            \n            # Compare the digit with the next character (if any)\n            if len(corrected_str) > 0 and corrected_str[-1].isdigit() and int(corrected_str[-1]) < digit:\n                # Swap the current digit with the previous one if the previous one is larger\n                corrected_str = corrected_str[:len(corrected_str)-1] + str(digit) + char\n            else:\n                # Simply append the digit to the corrected string\n                corrected_str += char\n    \n    return corrected_str\n\n# Example usage:"}
{"task_id": "Mbpp/93", "solution": "def calculate_exponent(base, exponent):\n    \"\"\"\n    Calculate the value of a number raised to a given exponent.\n    Handles both positive and negative exponents according to mathematical rules.\n    \"\"\"\n    if exponent == 0:\n        return 1\n    elif exponent > 0:\n        return base ** exponent\n    else:\n        return 1 / (base ** abs(exponent))\n\n# Test cases to verify the function's correctness with negative exponents\ntest_cases = [\n    (2, -3, 0.125),  # 2^-3 = 0.125\n    (-1, -2, 0.25),  # -1^-2 = 0.25\n    (5, -1, 0.2),   # 5^-1 = 0.2\n    (0.5, -2, 4)    # (0.5)^-2 = 4\n]\n\nresults = [calculate_exponent(base, exponent) for base, exponent in test_cases]"}
{"task_id": "Mbpp/94", "solution": "def sort_tuples(tuples):\n    # Sort the tuples based on their second element\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    \n    # Extract the tuple with the smallest second element\n    smallest_index = 0\n    for i, tup in enumerate(sorted_tuples):\n        if tup[1] == sorted_tuples[smallest_index][1]:\n            smallest_index = i\n    \n    # Return the first value of the tuple with the smallest second element\n    return sorted_tuples[smallest_index][0]\n\n# Test cases"}
{"task_id": "Mbpp/95", "solution": "def find_smallest_list_length(lst):\n    \"\"\"\n    This function finds the length of the smallest list in a list of lists.\n    \n    Args:\n    lst (list): A list containing lists.\n    \n    Returns:\n    int: The length of the smallest list in lst.\n    \"\"\"\n    min_length = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length\n\n# Test cases\n# Case 1: Single list with one element\nassert find_smallest_list_length([[1]]) == 1\n\n# Case 2: Single list with multiple elements\nassert find_smallest_list_length([[1, 2, 3], [], [4]]) == 1\n\n# Case 3: Multiple lists with varying lengths\nassert find_smallest_list_length([[1], [2, 3], [], [4, 5, 6]]) == 1\n\n# Case 4: Empty list\nassert find_smallest_list_length([]) == 0\n"}
{"task_id": "Mbpp/96", "solution": "def count_divisors(n):\n    \"\"\"Returns the total count of divisors of the given integer n.\"\"\"\n    divisors = set()\n    \n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)  # Ensure we count both the divisor and its reciprocal\n    \n    return len(divisors)\n\n# Test the function with some examples"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    \n    # Create a dictionary to store frequencies\n    freq_dict = {}\n    \n    # Iterate through the flattened list to count frequencies\n    for item in flat_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict\n\n# Test the function with the provided example\nassert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}"}
{"task_id": "Mbpp/98", "solution": "import math\n\ndef multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n\n# Test case\nassert math.isclose(multiply_num([8, 2, 3, -1, 7]), -67.2, rel_tol=0.001)"}
{"task_id": "Mbpp/99", "solution": "def handle_input(input_list):\n    \"\"\"\n    Handles input validation and negative number checks for a list.\n    \n    Args:\n        input_list (list): A list of numbers.\n        \n    Returns:\n        list: The same list with negative numbers replaced by zero and empty lists removed.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(input_list, list):\n        return \"Error: Input must be a list.\"\n    \n    # Check if the list is empty\n    if not input_list:\n        return \"Error: List is empty.\"\n    \n    # Replace negative numbers with zero\n    for num in input_list:\n        if num < 0:\n            input_list[num] = 0\n    \n    return input_list\n\n# Test cases"}
{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    # Function to check if a number is a palindrome\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    # Start checking from n + 1\n    for i in range(n + 1, 100000):  # Arbitrary large limit to ensure we find the next palindrome\n        if is_palindrome(i):\n            return i\n\n    # If no palindrome found within the limit, return None\n    return None\n\n# Test the function with the given assertion\nassert next_smallest_palindrome(99) == 101"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Function to find the kth element in the given array using 1-based indexing.\n    \n    Args:\n    arr (list): The input array.\n    k (int): The index of the kth element (1-based indexing).\n    \n    Returns:\n    int: The kth element in the array.\n    \"\"\"\n    if len(arr) < k:\n        raise IndexError(\"The array does not contain enough elements for the given index.\")\n    \n    return arr[k - 1]\n\n# Test the function\nassert kth_element([12, 3, 5, 7, 19], 2) == 3"}
{"task_id": "Mbpp/102", "solution": "def capitalize_and_join(words):\n    # Convert each word to title case (capitalize the first letter)\n    capitalized_words = [word.title() for word in words]\n    \n    # Join the capitalized words without any underscore\n    joined_string = ''.join(capitalized_words)\n    \n    return joined_string\n\n# Test the function\nwords = [\"this\", \"is\", \"a\", \"test\"]\nresult = capitalize_and_join(words)"}
{"task_id": "Mbpp/103", "solution": "def find_sum_of_elements(m, arr):\n    # Handle the base case where m is 1\n    if m == 1:\n        return sum(arr)\n    \n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Iterate through the array\n    for num in arr:\n        # Add the current element to the total sum\n        total_sum += num\n        \n    # Return the total sum\n    return total_sum\n\n# Test cases with correct input format\n# [(3, 1)] -> Expected output: 4"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(sublists):\n    # Sort each sublist in the given list of lists\n    sorted_sublists = [sorted(sublist) for sublist in sublists]\n    return sorted_sublists\n\n# Test the function with the provided example\nassert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"])) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']])"}
{"task_id": "Mbpp/105", "solution": "def check_function_name_match():\n    # This function checks if the test case function name matches the defined function name\n    test_function_name = 'test_check_function_name_match'\n    defined_function_name = 'check_function_name_match'\n    \n    if test_function_name == defined_function_name:\n        return \"The test case function name matches the defined function name.\"\n    else:\n        return \"The test case function name does not match the defined function name.\"\n\n# Test cases"}
{"task_id": "Mbpp/106", "solution": "def combine_tuples_and_list(tuples, list_elements):\n    \"\"\"\n    Combines each tuple with a given list by concatenating the tuple elements with the list elements.\n    \n    Parameters:\n    - tuples (list): A list of tuples.\n    - list_elements (list): A list of elements to concatenate with each tuple.\n\n    Returns:\n    - combined_list (list): A new list where each tuple from 'tuples' is concatenated with 'list_elements'.\n    \"\"\"\n    combined_list = []\n    for tup in tuples:\n        concatenated_tuple = tuple(tup + list_elements)\n        combined_list.append(concatenated_tuple)\n    return combined_list\n\n# Example usage:\ntuples = [(1, 2), (3, 4), (5, 6)]\nlist_elements = [7, 8, 9]\n\nresult = combine_tuples_and_list(tuples, list_elements)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list\n\n# Test the function with the provided example\nassert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"}
{"task_id": "Mbpp/109", "solution": "def count_odd_rotations(binary_string):\n    # Convert the binary string to an integer\n    num = int(binary_string, endianness='big')\n\n    # Calculate the number of 1s in the binary representation\n    ones_count = bin(num).count('1')\n\n    # If the number of 1s is odd, return 1; otherwise, return 0\n    return ones_count % 2 == 1\n\n# Test cases"}
{"task_id": "Mbpp/111", "solution": "def find_common_elements(nested_lists):\n    # Convert each nested list to a set to retain uniqueness\n    sets = [set(sublist) for sublist in nested_lists]\n    \n    # Find the intersection of all sets to get the common elements\n    common_elements = sets[0].intersection(*sets[1:])\n    \n    return common_elements\n\n# Example usage:\nnested_lists = [[1, 2, 3], [2, 3, 4], [1, 2, 5]]"}
{"task_id": "Mbpp/113", "solution": "def string_to_int(s):\n    \"\"\"\n    Convert a string to an integer if possible.\n    \n    Args:\n        s (str): The input string to be converted.\n        \n    Returns:\n        int: The integer value if the string can be converted, else None.\n    \"\"\"\n    # Check if the string is empty or contains only whitespace\n    if not s.strip():\n        return None\n    \n    # Try converting the string to an integer\n    try:\n        return int(s)\n    except ValueError:\n        # If conversion fails, check if the string represents a negative integer\n        if '-' in s:\n            # Attempt to extract the integer part after the negative sign\n            try:\n                neg_str = s.split('-')[0]\n                return int(neg_str)\n            except IndexError:\n                return None  # No valid integer part found\n        else:\n            return None  # No valid integer part found without a negative sign\n\n# Test cases"}
{"task_id": "Mbpp/116", "solution": "def flatten_tuple(tup):\n    \"\"\"\n    This function flattens a nested tuple, handling empty tuples and tuples containing nested lists.\n\n    Args:\n        tup (tuple): A nested tuple to be flattened.\n\n    Returns:\n        list: The flattened tuple as a list.\n    \"\"\"\n    flat_list = []\n    for item in tup:\n        if isinstance(item, tuple):\n            # Recursively handle nested tuples\n            flat_list.extend(flatten_tuple(item))\n        else:\n            # Add non-tuple items directly to the list\n            flat_list.append(item)\n    \n    return flat_list\n\n# Test cases to validate the function"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(input_string, delimiter):\n    \"\"\"\n    Converts a string into a list using a specified delimiter.\n    \n    Args:\n    - input_string (str): The string to be split.\n    - delimiter (str): The character to use as the split delimiter.\n    \n    Returns:\n    - list: The string split into a list.\n    \"\"\"\n    return input_string.split(delimiter)\n\n# Example usage:\n# Test with a simple string and a space as delimiter"}
{"task_id": "Mbpp/119", "solution": "def find_unique_element(arr):\n    # Since the array is sorted, the unique element must be at the middle.\n    # If the array has an odd length, the unique element is the middle element.\n    # If the array has an even length, the unique element is the average of the two middle elements.\n    mid = len(arr) // 2\n    return arr[mid]\n\n# Test cases"}
{"task_id": "Mbpp/120", "solution": "def max_product_of_pairs(tuples):\n    \"\"\"\n    Calculate the maximum product of pairs of numbers in a list of tuples.\n    \n    Args:\n    tuples (list): A list of tuples, where each tuple contains two numbers.\n    \n    Returns:\n    tuple: A tuple containing the maximum product and the corresponding tuple.\n    \"\"\"\n    # Ensure the input is a list of tuples\n    if not isinstance(tuples, list):\n        raise ValueError(\"Input must be a list of tuples.\")\n    \n    # Initialize variables to keep track of the maximum product and the corresponding tuple\n    max_product = float('-inf')\n    max_tuple = None\n    \n    # Iterate over each tuple in the list\n    for tup in tuples:\n        # Calculate the product of the numbers in the current tuple\n        product = tup[0] * tup[1]\n        \n        # Update the maximum product and the corresponding tuple if the current product is greater\n        if product > max_product:\n            max_product = product\n            max_tuple = tup\n    \n    return max_product, max_tuple\n\n# Test cases\n# Example 1: Single tuple with the maximum product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Function to find pairs of amicable numbers within a given range [1, n].\n    An amicable number pair (a, b) is such that the sum of the divisors of a equals b,\n    and the sum of the divisors of b equals a.\n    \"\"\"\n    def sum_of_divisors(num):\n        \"\"\"\n        Helper function to calculate the sum of divisors of a given number.\n        \"\"\"\n        divisors = [i for i in range(1, num + 1) if num % i == 0]\n        return sum(divisors)\n\n    # List to store amicable number pairs\n    amicable_pairs = []\n\n    # Iterate through the range [1, n]\n    for a in range(1, n + 1):\n        sum_a = sum_of_divisors(a)\n        # Check if there exists a number b such that sum_of_divisors(b) == a\n        for b in range(1, n + 1):\n            if sum_of_divisors(b) == a:\n                amicable_pairs.append((a, b))\n\n    return amicable_pairs\n\n# Example usage\nn = 300  # You can change this value to search for amicable numbers within a different range\nresult = amicable_numbers_sum(n)"}
{"task_id": "Mbpp/124", "solution": "def angle_complex(z):\n    \"\"\"\n    Calculate the argument (angle) of a complex number z.\n    :param z: A complex number as a single value (e.g., 3+2j).\n    :return: The angle in radians.\n    \"\"\"\n    if isinstance(z, complex):\n        return abs(z) * (1.0 / math.pi)\n    else:\n        raise ValueError(\"Input must be a complex number.\")\n\n# Example usage\n# Incorrect way (list with strings)\ntry:\n    print(angle_complex([3, 2]))  # This will raise a ValueError\nexcept ValueError as e:\n    print(e)  # Output: Input must be a complex number.\n\n# Correct way (single complex number)\ncorrect_input = 3 + 2j"}
{"task_id": "Mbpp/125", "solution": "def max_diff_count_binary(binary_str):\n    \"\"\"\n    Finds the maximum difference between the counts of 0s and 1s in any substring of the binary string.\n    \"\"\"\n    max_diff = 0\n    for i in range(len(binary_str)):\n        count_0 = binary_str.count('0')   # Count the number of 0s\n        count_1 = binary_str.count('1')   # Count the number of 1s\n        diff = abs(count_0 - count_1)   # Calculate the difference\n        max_diff = max(max_diff, diff)  # Update the maximum difference\n\n    return max_diff\n\n# Test cases"}
{"task_id": "Mbpp/126", "solution": "def sum_common_divisors(a, b):\n    # Function to find and sum common divisors\n    def find_common_divisors(x, y):\n        divisors = []\n        for i in range(1, x + 1):\n            if x % i == 0 and y % i == 0:\n                divisors.append(i)\n        return divisors\n\n    common_divisors = find_common_divisors(a, b)\n    return sum(common_divisors)\n\n# Test the function\nresult = sum_common_divisors(10, 15)"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Multiply two integers.\n    \n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n        \n    Returns:\n        int: The product of a and b.\n    \"\"\"\n    return a * b\n\n# Test the function\nassert multiply_int(10, 20) == 200"}
{"task_id": "Mbpp/128", "solution": "def process_inputs(*args):\n    \"\"\"\n    This function processes inputs correctly by unpacking them from the arguments.\n    It expects a variable number of arguments representing different inputs.\n    \"\"\"\n    # Ensure at least one argument is provided\n    if len(args) < 1:\n        raise ValueError(\"At least one input is required.\")\n\n    # Unpack the arguments into separate variables\n    first_input = args[0]\n    second_input = args[1]\n\n    # Perform some operation with the inputs\n    result = first_input + second_input\n\n    return result\n\n# Example usage with correct argument unpacking"}
{"task_id": "Mbpp/129", "solution": "def is_magic_square(matrix):\n    # Check if the matrix is empty\n    if not matrix:\n        return False\n\n    # Check the magic square properties\n    n = len(matrix)\n    magic_sum = sum(matrix[i][i] for i in range(n))\n\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != magic_sum:\n            return False\n\n    return True\n\n# Test cases\n# An empty matrix"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    :param lst: A list of integers.\n    :return: The item with the maximum frequency in the list.\n    :assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    max_freq_item = max(frequency, key=frequency.get)\n    return max_freq_item\n\n# Test case\nassert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels_in_string(s):\n    vowels = 'aeiou'\n    reversed_s = ''\n    for char in s:\n        if char in vowels:\n            reversed_s += char\n        else:\n            reversed_s += ' '\n    return reversed_s\n\n# Test cases"}
{"task_id": "Mbpp/132", "solution": "def concatenate_without_spaces(string):\n    # Use an empty string '' as the separator to concatenate the characters\n    return ''.join(string)\n\n# Test cases"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of negative numbers in a given list of numbers.\n    \n    :param numbers: List of numbers\n    :return: Sum of negative numbers in the list\n    \"\"\"\n    return sum(x for x in numbers if x < 0)\n\n# Test case\nassert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_number(n):\n    \"\"\"\n    Calculate the nth hexagonal number using the correct formula: n * (2n - 1)\n    \"\"\"\n    return n * (2 * n - 1)\n\n# Test cases to validate the function\nassert hexagonal_number(1) == 1  # 1st hexagonal number should be 1\nassert hexagonal_number(2) == 5  # 2nd hexagonal number should be 5\nassert hexagonal_number(3) == 14  # 3rd hexagonal number should be 14\nassert hexagonal_number(10) == 165  # 10th hexagonal number should be 165\n"}
{"task_id": "Mbpp/137", "solution": "import math\n\ndef is_close(a, b, rel_tol=1e-9):\n    \"\"\"\n    Check if two numbers are close to each other within a relative tolerance.\n    \n    :param a: First number\n    :param b: Second number\n    :param rel_tol: Relative tolerance (default is 1e-9)\n    :return: True if a and b are close, False otherwise\n    \"\"\"\n    return math.isclose(a, b, rel_tol=rel_tol)\n\n# Test cases"}
{"task_id": "Mbpp/138", "solution": "def index_to_power_of_two(index):\n    \"\"\"\n    Calculate the power of 2 corresponding to the position of the first '1' in the binary representation.\n    \"\"\"\n    # Convert the index to its binary representation\n    binary_representation = bin(index)[2:]  # Strip the '0b' prefix\n\n    # Count the number of '1's in the binary representation\n    count_ones = binary_representation.count('1')\n\n    # Return the power of 2 corresponding to the position of the first '1'\n    return 2 ** count_ones\n\ndef is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Check if the given number can be expressed as the sum of distinct powers of 2.\n    \"\"\"\n    # Initialize a set to store the powers of 2\n    powers_of_two = set()\n\n    # Iterate over possible indices to find powers of 2\n    for i in range(0, n + 1):\n        power = index_to_power_of_two(i)\n        if power > n:\n            break\n        if power not in powers_of_two:\n            powers_of_two.add(power)\n\n    # Check if all numbers up to n can be expressed as the sum of distinct powers of 2\n    return len(powers_of_two) == len(range(1, n + 1))\n\n# Test cases"}
{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    :param radius: float, the radius of the circle\n    :return: float, the circumference of the circle\n    \"\"\"\n    return 2 * math.pi * radius\n\n# Test the function with the provided example\nassert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(lst):\n    flat_set = set()\n    for sublist in lst:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set\n\n# Test the function\nassert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements in ascending order.\n    \"\"\"\n    return sorted(lst)\n\n# Test case\nassert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"}
{"task_id": "Mbpp/142", "solution": "def check_identical_positions(list1, list2, list3):\n    # Ensure the input is in the correct format\n    if not all(isinstance(lst, list) for lst in [list1, list2, list3]):\n        raise ValueError(\"All inputs must be lists.\")\n    \n    # Check for identical items at the same positions in all three lists\n    identical_positions_count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            identical_positions_count += 1\n    \n    return identical_positions_count\n\n# Example input as per the problem statement\ninput_lists = [ [1,2,3,4,5,6,7,8], [2,2,3,1,2,6,7,9], [2,1,3,1,2,6,7,9] ]\n\n# Call the function with the example input\nresult = check_identical_positions(*input_lists)"}
{"task_id": "Mbpp/145", "solution": "def max_difference(arr):\n    \"\"\"\n    Function to find the maximum difference between any two elements in an array.\n    \n    Args:\n        arr (list): A list of integers.\n        \n    Returns:\n        int: The maximum difference between any two elements in the list.\n        \n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    \n    # Handle the edge case of an empty list\n    if not arr:\n        raise ValueError(\"Input list is empty.\")\n    \n    # Initialize the maximum difference with the difference of the first two elements\n    max_diff = abs(arr[0] - arr[1])\n    \n    # Iterate through the list to find the maximum difference\n    for i in range(1, len(arr)):\n        diff = abs(arr[i] - arr[i-1])\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n\n# Test cases"}
{"task_id": "Mbpp/160", "solution": "def solve_linear_equation(a, b, n):\n    \"\"\"\n    Solves the linear equation ax + by = n for x and y.\n\n    Parameters:\n    a (int): Coefficient of x.\n    b (int): Coefficient of y.\n    n (int): Right-hand side of the equation.\n\n    Returns:\n    tuple: A tuple containing the values of x and y.\n    \"\"\"\n    # Check if a solution exists\n    if a == 0:\n        raise ValueError(\"No solution exists if a is zero.\")\n    \n    # Calculate y in terms of n and a\n    y = (n - a * 0) / b\n    \n    # Calculate x in terms of y\n    x = n / a\n    \n    return x, y\n\n# Example usage:\ntry:\n    x, y = solve_linear_equation(2, 3, 6)\n    print(f\"x = {x}, y = {y}\")\nexcept ValueError as e:\n    print(e)"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(original_list, elements_to_remove):\n    \"\"\"\n    Remove all elements from the original list that are present in the list of elements to remove.\n    \n    Args:\n        original_list (list): The original list from which elements are to be removed.\n        elements_to_remove (list): A list of elements to be removed from the original list.\n        \n    Returns:\n        list: The original list with elements to be removed.\n    \"\"\"\n    return [item for item in original_list if item not in elements_to_remove]\n\n# Test the function\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    \"\"\"\n    Calculate the sum (n - 2*i) for i ranging from 0 to n // 2.\n    \n    Example:\n    assert sum_series(6) == 12\n    \n    Args:\n    n (int): The upper limit for the sum calculation.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    total_sum = 0\n    for i in range(n // 2 + 1):\n        total_sum += n - 2 * i\n    return total_sum\n\n# Test the function\nassert sum_series(6) == 12"}
{"task_id": "Mbpp/165", "solution": "def check_char_position(char, target_position):\n    \"\"\"\n    Check if a given character is at the target position in the alphabet.\n    \n    Args:\n        char (str): The character to check.\n        target_position (int): The target position in the alphabet (0 for 'a', 25 for 'z', and 1 for 'A', 26 for 'Z').\n    \n    Returns:\n        bool: True if the character is at the target position, False otherwise.\n    \"\"\"\n    # Adjust the target position to be zero-based for 'a' or one-based for 'A'\n    if char.isupper():\n        target_position -= 1\n    \n    # Check if the position is valid (0 to 25 for lowercase, 1 to 26 for uppercase)\n    if not 0 <= target_position <= 25:\n        return False\n    \n    # Check the character's position in the alphabet\n    return ord(char) - ord('a') + 1 == target_position\n\n# Example usage:"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count\n\n# Test case\nassert find_even_pair([5, 4, 7, 2, 1]) == 4"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Correctly calculates the smallest power of 2 that is greater than or equal to n.\n    \"\"\"\n    # Initialize the base 2 with the value of n\n    base_2 = n\n    \n    # While the base 2 is less than the actual power of 2\n    while base_2 < n:\n        base_2 *= 2\n    \n    # Return the final base 2 which is the smallest power of 2 >= n\n    return base_2\n\n# Test cases"}
{"task_id": "Mbpp/168", "solution": "def count_occurrences(numbers_list, target_number):\n    \"\"\"\n    This function counts the occurrences of a target number in a list of numbers.\n    \n    :param numbers_list: A list of numbers.\n    :param target_number: The number to be counted.\n    :return: The count of occurrences of the target_number in numbers_list.\n    \"\"\"\n    return numbers_list.count(target_number)\n\n# Test cases to validate the function\n# Test case 1: Target number is present in the list\nnumbers_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget_number = 5\nexpected_result = 2\nassert count_occurrences(numbers_list, target_number) == expected_result, \"Test case 1 failed\"\n\n# Test case 2: Target number is not present in the list\nnumbers_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget_number = 11\nexpected_result = 0\nassert count_occurrences(numbers_list, target_number) == expected_result, \"Test case 2 failed\"\n\n# Test case 3: Empty list\nnumbers_list = []\ntarget_number = 0\nexpected_result = 0\nassert count_occurrences(numbers_list, target_number) == expected_result, \"Test case 3 failed\"\n\n# Test case 4: List with only one element\nnumbers_list = [7]\ntarget_number = 7\nexpected_result = 1\nassert count_occurrences(numbers_list, target_number) == expected_result, \"Test case 4 failed\"\n"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        lst (list): The input list of numbers.\n        start_index (int): The starting index in the list.\n        end_index (int): The ending index in the list.\n        \n    Returns:\n        int: The sum of numbers in the list from start_index to end_index inclusive.\n    \"\"\"\n    return sum(lst[start_index:end_index+1])\n\n# Test the function\nassert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    # A regular pentagon has 5 equal sides.\n    return 5 * side_length\n\n# Test the function\nassert perimeter_pentagon(5) == 25"}
{"task_id": "Mbpp/172", "solution": "def check_string(input_string):\n    \"\"\"\n    Check if the input string contains the substring 'std'.\n    \"\"\"\n    return 'std' in input_string\n\n# Test cases"}
{"task_id": "Mbpp/222", "solution": "def check_type(tup):\n    \"\"\"\n    Check if all elements in the tuple have the same data type.\n    \n    Args:\n    tup (tuple): A tuple of elements to be checked.\n    \n    Returns:\n    bool: True if all elements in the tuple are of the same data type, False otherwise.\n    \"\"\"\n    # Convert the tuple to a list for easier iteration\n    t_list = list(tup)\n    \n    # Check if all elements are of the same type\n    if len(set(type(x) for x in t_list)) == 1:\n        return True\n    else:\n        return False\n\n# Test the function\nassert check_type((5, 6, 7, 3, 5, 6)) == True\nassert check_type((5, '6', 7, 3, '5', 6)) == False\nassert check_type((5, 6, 7, 3, 5.0, 6.0)) == False"}
{"task_id": "Mbpp/223", "solution": "def calculate_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Returns:\n        float: The area of the rectangle.\n    \"\"\"\n    return length * width\n\n# Testing the function with correct inputs\nlength = 5.0\nwidth = 3.0\narea = calculate_area(length, width)"}
{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    \"\"\"\n    Count the number of set bits (binary digits with value 1) in a given number.\n    \n    :param n: int\n    :return: int\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\n# Test cases\nassert count_Set_Bits(2) == 1\nassert count_Set_Bits(3) == 2\nassert count_Set_Bits(8) == 1\nassert count_Set_Bits(16) == 0"}
{"task_id": "Mbpp/226", "solution": "def remove_odd_index_characters(s):\n    \"\"\"\n    Remove characters at odd indices from the string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    # Convert the string to a list to easily access indices\n    s_list = list(s)\n    \n    # Iterate over the list and remove characters at odd indices\n    for i in range(1, len(s_list), 2):\n        s_list[i] = ''\n    \n    # Join the list back into a string\n    return ''.join(s_list)\n\n# Test cases"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Returns the minimum value among three numbers.\n    \n    Args:\n        a (int/built-in): The first number.\n        b (int/built-in): The second number.\n        c (int/built-in): The third number.\n        \n    Returns:\n        int: The minimum value among a, b, and c.\n    \"\"\"\n    return min(a, b, c)\n\n# Test case\nassert min_of_three(10, 20, 0) == 0"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(string, char):\n    return string.replace(' ', char)\n\n# Test case\nassert replace_blank(\"hello people\",'@') == \"hello@people\""}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    # Sort the list in descending order\n    lst.sort(reverse=True)\n    \n    # Return the first n items from the sorted list\n    return lst[:n]\n\n# Test the function with the provided example\nassert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2)) == {100, 90}"}
{"task_id": "Mbpp/233", "solution": "import math\n\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    r (float): The radius of the base of the cylinder.\n    h (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    return 2 * math.pi * r * h\n\n# Test the function with the provided values\nradius = 10\nheight = 5\nexpected_area = 314.15\n\nassert math.isclose(lateralsuface_cylinder(radius, height), expected_area, rel_tol=0.001)"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    :param side_length: The length of a side of the cube.\n    :return: The volume of the cube.\n    \"\"\"\n    return side_length ** 3\n\n# Test case\nassert volume_cube(3) == 27"}
{"task_id": "Mbpp/235", "solution": "def set_even_bits(n):\n    \"\"\"\n    Sets all even bits (0s in binary) to 1 in the binary representation of the given number.\n    \"\"\"\n    # Convert the number to its binary representation\n    binary_representation = bin(n)[2:]  # bin() returns '0bxxxxxx', so [2:] to remove '0b'\n\n    # Initialize an empty list to store the new binary representation\n    new_binary = []\n\n    # Iterate over each digit (bit) in the binary representation\n    for bit in binary_representation:\n        # If the bit is '0' (even), set it to '1' (odd)\n        if bit == '0':\n            new_binary.append('1')\n        else:\n            new_binary.append(bit)\n\n    # Convert the list of bits back to an integer\n    result = int(''.join(new_binary))\n\n    return result\n\n# Test cases"}
{"task_id": "Mbpp/237", "solution": "def count_tuple_occurrences(tuples):\n    # Use a dictionary to count occurrences of each tuple\n    occurrence_dict = {}\n    \n    # Iterate through each tuple\n    for tup in tuples:\n        # Check if the tuple already exists in the dictionary\n        if tup in occurrence_dict:\n            occurrence_dict[tup] += 1\n        else:\n            occurrence_dict[tup] = 1\n    \n    return occurrence_dict\n\n# Example usage\ntuples = [(1, 2), (3, 4), (1, 2), (5, 6)]\nresult = count_tuple_occurrences(tuples)"}
{"task_id": "Mbpp/238", "solution": "def count_non_empty_substrings(s):\n    \"\"\"\n    Function to count all non-empty substrings in a given string.\n    \"\"\"\n    # Initialize variables\n    n = len(s)\n    count = 0\n\n    # Use a sliding window approach\n    i = 0\n    while i < n:\n        # Calculate the length of the current substring\n        window_length = i + 1\n\n        # Update the count for this substring\n        count += window_length\n\n        # Slide the window to the right\n        i += 1\n\n    return count\n\n# Test the function with examples"}
{"task_id": "Mbpp/239", "solution": "def count_sequences(arr):\n    \"\"\"\n    This function counts the number of valid sequences in the given array.\n    A valid sequence is defined as a subsequence where each element is either the same as the previous element or one increment.\n    \"\"\"\n    # Base case: if the array is empty, return 1 (the empty sequence)\n    if not arr:\n        return 1\n\n    # Initialize the count of valid sequences\n    count = 1\n\n    # Iterate through the array\n    for i in range(1, len(arr)):\n        # Check if the current element is one increment more than the previous\n        if arr[i] == arr[i-1] + 1:\n            # If it is, recursively count sequences ending at this element\n            count += count_sequences(arr[i:])\n        else:\n            # If it's not, the sequence ends here, so return 1\n            return count\n\n    # If we reach the end of the array without returning, the entire array forms a valid sequence\n    return count\n\n# Test the function with some examples"}
{"task_id": "Mbpp/240", "solution": "def append_lists(first_list, second_list):\n    \"\"\"\n    Appends elements from the second list to the first list iteratively.\n    \n    :param first_list: List to which elements will be appended.\n    :param second_list: List of elements to append.\n    :return: First_list with elements from second_list appended.\n    \"\"\"\n    # Ensure both lists have the same length\n    assert len(first_list) == len(second_list), \"Lists must have the same length for appending.\"\n\n    # Iteratively append elements from second_list to first_list\n    for item in second_list:\n        first_list.append(item)\n\n    return first_list\n\n# Test the function\nfirst_list = [1, 2, 3]\nsecond_list = [4, 5, 6]\nresult = append_lists(first_list, second_list)\n"}
{"task_id": "Mbpp/242", "solution": "def count_characters(input_string):\n    \"\"\"\n    This function counts the total number of characters in an input string.\n    \"\"\"\n    return len(input_string)\n\n# Test the function with the input string \"python programming\"\nresult = count_characters(\"python programming\")"}
{"task_id": "Mbpp/244", "solution": "def calculate_square(n):\n    \"\"\"\n    Calculate the square of a given positive integer.\n    \n    Args:\n        n (int): A single positive integer.\n        \n    Returns:\n        int: The square of the input number.\n    \"\"\"\n    # Input validation to ensure n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    return n ** 2\n\n# Testing the function with valid inputs"}
{"task_id": "Mbpp/245", "solution": "def max_bitonic_subsequence(arr):\n    n = len(arr)\n    if n < 2:\n        return n  # Base case: single element is a bitonic subsequence\n\n    # Initialize variables to keep track of the maximum sum and the indices\n    max_sum = float('-inf')\n    start_index = 0\n    end_index = 0\n\n    # Iterate through the array to find the increasing and decreasing parts\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            # Found an increasing part\n            if end_index == 0:\n                start_index = i\n            end_index = i\n\n        else:\n            # Found a decreasing part\n            if start_index == n - 1:\n                max_sum = max(max_sum, sum(arr[start_index:i+1]))\n                start_index = i\n            end_index = i\n\n    # Check the last part of the array\n    if start_index < n - 1:\n        max_sum = max(max_sum, sum(arr[start_index:n]))\n\n    return max_sum\n\n# Example usage:\narr = [3, 2, 1, 5, 4, 3, 2]"}
{"task_id": "Mbpp/247", "solution": "def find_palindromic_subsequence(s):\n    # Initialize a 2D DP table with (len(s), 1) where len(s) is the length of the string\n    dp = [[0] * (len(s) + 1) for _ in range(len(s + ''))]\n\n    # Base case: any single character is a palindromic subsequence of length 1\n    for i in range(len(s)):\n        dp[i][1] = 1\n\n    # Fill the DP table\n    for i in range(2, len(s) + 1):\n        for j in range(1, len(s) + 1):\n            if s[i - 1] == s[j - 1]:  # Check if characters match\n                dp[i][j] = dp[i - 1][j - 1] + 2  # A palindromic subsequence of length i can be formed by appending the character s[i-1] to a palindromic subsequence of length j-1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])  # If characters don't match, choose the maximum length subsequence from the left or right\n\n    # The length of the longest palindromic subsequence is found at dp[len(s)][len(s)]\n    return dp[len(s)][len(s)]\n\n# Example usage:\ns = \"abba\""}
{"task_id": "Mbpp/250", "solution": "def count_occurrences(tuples):\n    \"\"\"\n    This function counts the occurrences of each element in a list of tuples.\n    \n    Args:\n    tuples (list): A list of tuples.\n    \n    Returns:\n    dict: A dictionary where keys are the unique elements from tuples and values are their counts.\n    \"\"\"\n    occurrences = {}\n    for tup in tuples:\n        for element in tup:\n            if element in occurrences:\n                occurrences[element] += 1\n            else:\n                occurrences[element] = 1\n    return occurrences\n\n# Test cases\n# Ensure that the elements passed in the tuples match the elements being counted\ntest_cases = [\n    ((1, 2, 3), {\"1\": 1, \"2\": 1, \"3\": 1}),\n    ((4, 5, 6), {\"4\": 1, \"5\": 1, \"6\": 1}),\n    ((7, 8, 9), {\"7\": 1, \"8\": 1, \"9\": 1}),\n    ((10, 20, 30), {\"10\": 1, \"20\": 1, \"30\": 1}),\n    ((-1, 0, 1), {\"-1\": 1, \"0\": 1, \"1\": 1}),\n    ((2.0, 3.5, 4), {\"2.0\": 1, \"3.5\": 1, \"4\": 1})\n]\n\n# Run test cases\nfor test in test_cases:\n    result = count_occurrences(test)\n    print(f\"Test case {test} passed: {result == dict(test)}\")"}
{"task_id": "Mbpp/251", "solution": "def insert_before_each(lst, element):\n    \"\"\"\n    Insert the given element before each element in the list.\n    \n    Args:\n    lst (list): The original list.\n    element (any): The element to insert before each element in the list.\n    \n    Returns:\n    list: The modified list with the element inserted before each element.\n    \"\"\"\n    return [element + item for item in lst]\n\n# Test the function\noriginal_list = [1, 2, 3, 4]\nelement_to_insert = 'X'\n\nmodified_list = insert_before_each(original_list, element_to_insert)"}
{"task_id": "Mbpp/252", "solution": "import math\n\ndef convert(c):\n    \"\"\"\n    Converts a complex number to polar coordinates (magnitude, angle).\n\n    Args:\n        c (complex): A complex number in the form of `x + yi`.\n\n    Returns:\n        Tuple: A tuple containing the magnitude and angle of the complex number in polar form.\n    \"\"\"\n    # Extract real and imaginary parts\n    real = c.real\n    imag = c.imag\n\n    # Calculate the magnitude (r)\n    r = math.sqrt(real**2 + imag**2)\n\n    # Calculate the angle (theta) in radians\n    theta = math.atan2(imag, real)\n\n    # Convert the angle to degrees for better readability (optional)\n    theta_degrees = math.degrees(theta)\n\n    return r, theta\n\n# Test cases\nassert convert(1) == (1.0, 0.0)  # Real part is 1, imaginary part is 0\nassert convert(2 + 3j) == (3.605551275463989, 71.56507017510803)  # Approximately (3.61, 71.56\u00b0)\nassert convert(-1) == (-1.0, -180.0)  # Negative real part flips the angle to the fourth quadrant\nassert convert(0) == (0.0, 0.0)  # Purely imaginary, angle is 0\u00b0"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    \"\"\"\n    Returns the number of integer elements in a given list.\n    \n    :param lst: List of elements.\n    :return: Integer count in the list.\n    \"\"\"\n    return sum(1 for element in lst if isinstance(element, int))\n\n# Test case\nassert count_integer([1, 2, 'abc', 1.2]) == 2"}
{"task_id": "Mbpp/255", "solution": "def calculate_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Returns:\n        float: The area of the rectangle.\n    \"\"\"\n    return length * width\n\n# Test cases\n# Each test case should be a separate call to calculate_area\n\n# Test case 1: Correct dimensions\narea = calculate_area(5, 3)\nassert area == 15, \"Test case 1 failed\"\n\n# Test case 2: Zero length\narea = calculate_area(0, 4)\nassert area == 0, \"Test case 2 failed\"\n\n# Test case 3: Zero width\narea = calculate_area(5, 0)\nassert area == 0, \"Test case 3 failed\"\n\n# Test case 4: Negative dimensions (should raise an error)\ntry:\n    area = calculate_area(-5, 3)\n    assert False, \"Test case 4 failed (should raise an error)\"\nexcept ValueError as e:\n    assert str(e) == \"Length must be positive\", \"Incorrect error message\"\n\n# Test case 5: Non-numeric dimensions (should raise an error)\ntry:\n    area = calculate_area('five', 3)\n    assert False, \"Test case 5 failed (should raise an error)\"\nexcept TypeError as e:\n    assert str(e) == \"Both length and width must be numbers\", \"Incorrect error message\""}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    \"\"\"\n    Function to count the number of prime numbers less than a given non-negative number.\n    \n    Args:\n        n (int): A non-negative number.\n        \n    Returns:\n        int: The count of prime numbers less than n.\n    \"\"\"\n    primes_count = 0\n    \n    # Function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Count primes up to n\n    for possible_prime in range(2, n):\n        if is_prime(possible_prime):\n            primes_count += 1\n    \n    return primes_count\n\n# Test the function\nassert count_Primes_nums(5) == 2"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    \"\"\"\n    Swaps two numbers.\n    \n    Args:\n    a (int or float): The first number to swap.\n    b (int or float): The second number to swap.\n    \n    Returns:\n    tuple: A tuple containing the swapped numbers.\n    \"\"\"\n    return (b, a)\n\n# Test cases with proper input format\n# Test case 1: Swapping positive integers\nassert swap_numbers(3, 7) == (7, 3)\n\n# Test case 2: Swapping negative integers\nassert swap_numbers(-5, -2) == (-2, -5)\n\n# Test case 3: Swapping decimal numbers\nassert swap_numbers(4.6, 1.2) == (1.2, 4.6)\n\n# Test case 4: Swapping zero with another number\nassert swap_numbers(0, 5) == (5, 0)\n"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(list1, list2):\n    \"\"\"\n    This function compares two lists and returns a new list containing the maximum element from each input list.\n    \n    Parameters:\n    list1 (list): A list of integers or floats.\n    list2 (list): Another list of integers or floats.\n    \n    Returns:\n    list: A new list with the maximum element from each input list.\n    \"\"\"\n    return [max(item1, item2) for item1, item2 in zip(list1, list2)]\n\n# Example usage:\nlist1 = [4, 2, 9]\nlist2 = [7, 5, 1]\nresult = maximize_elements(list1, list2)"}
{"task_id": "Mbpp/260", "solution": "def find_next_prime(n):\n    \"\"\"\n    Finds the next prime number after n considering Newman-Shanks-Williams primality test.\n    Handles cases where n <= 3 by returning the appropriate Newman-Shanks-Williams primes.\n    \"\"\"\n    # Base cases for n <= 3\n    if n <= 3:\n        # Newman-Shanks-Williams primes for n <= 3\n        if n == 2:\n            return 3\n        elif n == 3:\n            return 5\n        elif n == 1 or n == 0:\n            return 2  # 2 is the only prime number for n = 1 or n = 0\n\n    # Function to check if a number is prime using the Newman-Shanks-Williams test\n    def is_prime(x):\n        if x < 2:\n            return False\n        for p in range(2, int(x**0.5) + 1):\n            if x % p == 0:\n                return False\n        return True\n\n    # Iterate to find the next prime after n\n    current = n + 1\n    while not is_prime(current):\n        current += 1\n\n    return current\n\n# Example usage"}
{"task_id": "Mbpp/261", "solution": "def division_elements(t1, t2):\n    \"\"\"\n    Perform element-wise division operation across two tuples.\n    \n    Args:\n        t1 (tuple): The first tuple of numbers.\n        t2 (tuple): The second tuple of numbers.\n        \n    Returns:\n        tuple: A tuple where each element is the result of dividing the corresponding elements from the input tuples.\n    \"\"\"\n    return tuple(a / b for a, b in zip(t1, t2))\n\n# Test the function\nassert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits a list into two parts where the length of the first part is L.\n    :param lst: The input list.\n    :param L: The desired length of the first part of the list.\n    :return: A tuple containing the two resulting lists.\n    \"\"\"\n    if len(lst) < L:\n        return ([], lst)\n    \n    first_part = lst[:L]\n    second_part = lst[L:]\n    \n    return (first_part, second_part)\n\n# Test cases\nassert split_two_parts([1,1,2,3,4,4,5,1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])\nassert split_two_parts([1,2,3,4,5], 2) == ([1, 2], [3, 4, 5])\nassert split_two_parts([], 0) == ([], [])\nassert split_two_parts([1,2,3,4,5], 7) == ([1, 2, 3], [4, 5])"}
{"task_id": "Mbpp/264", "solution": "def dog_years_to_human(years):\n    # The formula to convert dog years to human years is:\n    # Dog years = 0.15 * human years for the first year, then 1 dog year = 5 human years.\n    if years <= 1:\n        return 0.15 * years\n    else:\n        dog_years = 0.15 * years\n        remaining_years = years - 1\n        return dog_years + 5 * remaining_years\n\n# Test cases to validate the function\nassert dog_years_to_human(1) == 0.15\nassert dog_years_to_human(2) == 0.3\nassert dog_years_to_human(5) == 7.75\nassert dog_years_to_human(10) == 17.5\nassert dog_years_to_human(15) == 32.25\n"}
{"task_id": "Mbpp/265", "solution": "def split_list_into_n_sublists(lst, n):\n    \"\"\"\n    Splits a list into n sublists, ensuring all elements are included even if the original list's length is not divisible by n.\n    \"\"\"\n    # Calculate the number of full sublists we can create\n    full_sublists_count = len(lst) // n\n    \n    # Initialize an empty list to store the sublists\n    sublists = []\n    \n    # Iterate over the original list\n    for i in range(full_sublists_count * n):\n        # Create a sublist by slicing the original list\n        sublist = lst[i:i + n]\n        # Append the sublist to the result list\n        sublists.append(sublist)\n    \n    # If there are remaining elements, create a final sublist\n    if len(lst) % n != 0:\n        sublists.append(lst[full_sublists_count * n:])\n\n    return sublists\n\n# Example usage:\noriginal_list = [1, 2, 3, 4, 5]\nn = 2\nresult = split_list_into_n_sublists(original_list, n)"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n    \n    Args:\n    side_length (int): The length of a side of the cube.\n    \n    Returns:\n    int: The lateral surface area of the cube.\n    \"\"\"\n    return 6 * side_length ** 2\n\n# Testing the function"}
{"task_id": "Mbpp/267", "solution": "def first_n_odd_numbers(n):\n    \"\"\"Return the first n odd natural numbers as a list.\"\"\"\n    # Correct range to iterate over the first n odd numbers\n    return [2 * i + 1 for i in range(n)]\n\n# Test the function with some examples"}
{"task_id": "Mbpp/268", "solution": "def star_number(n):\n    # Correct formula for the n-th star number\n    # Star numbers: 1, 1, 2, 3, 5, 8, 13, 21, ...\n    # General formula: 2^(n-1)\n    return 2**(n - 1)\n\n# Test cases to verify the correctness of the function\ntest_cases = [(1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), (8, 21)]\n\nfor case in test_cases:\n    result = star_number(case[0])\n    expected = case[1]\n    print(f\"Test case {case}: Actual {result} vs Expected {expected}\")\n    assert result == expected, f\"Failed for test case {case}\"\n\n# This line ensures the function works correctly based on the provided test cases"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    Returns the ASCII value of a given character.\n    \n    :param char: The character for which the ASCII value is to be returned.\n    :return: The ASCII value of the character.\n    \"\"\"\n    return ord(char)\n\n# Test cases\nassert ascii_value('A') == 65\nassert ascii_value('a') == 97\nassert ascii_value('1') == 49\nassert ascii_value(' ') == 32\nassert ascii_value('!') == 33"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    \"\"\"\n    Calculate the sum of even numbers at even positions in a list.\n    \n    :param lst: List of integers.\n    :return: Sum of even numbers at even positions.\n    \"\"\"\n    sum_even = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 == 0:  # Check if the number is even\n            sum_even += lst[i]\n    return sum_even\n\n# Test case\nassert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30"}
{"task_id": "Mbpp/271", "solution": "def sum_first_n_even_numbers(n):\n    \"\"\"\n    Calculate the sum of the first n even natural numbers.\n    \n    Args:\n    n (int): The number of even natural numbers to sum.\n    \n    Returns:\n    int: The sum of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum to 0\n    sum_even_numbers = 0\n    \n    # Iterate from 2 to n (inclusive), summing each even number\n    for i in range(2, n + 1, 2):\n        sum_even_numbers += i\n    \n    return sum_even_numbers\n\n# Example usage:\n# Test the function with different inputs"}
{"task_id": "Mbpp/272", "solution": "def extract_last_elements(tuples):\n    \"\"\"Extract the last element from each tuple in a list.\"\"\"\n    return [element[-1] for element in tuples]\n\n# Test the function\ntuples = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\nresult = extract_last_elements(tuples)"}
{"task_id": "Mbpp/273", "solution": "# Define the function to subtract elements between two tuples\ndef subtract_elements(tup1, tup2):\n    \"\"\"\n    This function subtracts corresponding elements from two tuples.\n    \n    Parameters:\n    tup1 (tuple): The first tuple to perform subtraction on.\n    tup2 (tuple): The second tuple to perform subtraction against.\n    \n    Returns:\n    tuple: A new tuple with the differences of corresponding elements.\n    \"\"\"\n    result = ()\n    for i in range(len(tup1)):\n        result += (tup1[i] - tup2[i],) if tup2[i] != 0 else (0,)\n    return result\n\n# Test the function with some example inputs\ntup1 = (10, 20, 30, 40)\ntup2 = (5, 15, 25, 35)\n\n# Expected output: (5, 5, 5, 5)"}
{"task_id": "Mbpp/274", "solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) which represents the number of ways to choose k items from n items without regard to order.\n    \"\"\"\n    if k > n:\n        return 0\n    elif k == 0:\n        return 1\n    else:\n        return (binomial_coefficient(n - 1, k - 1) * (n - k)) // (k + 1)\n\n# Test the binomial_coefficient function\nn = 5\nk = 3"}
{"task_id": "Mbpp/276", "solution": "import math\n\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Args:\n        radius (float): The radius of the base of the cylinder.\n        height (float): The height of the cylinder.\n        \n    Returns:\n        float: The volume of the cylinder.\n    \"\"\"\n    return math.pi * radius ** 2 * height\n\n# Test case\nassert math.isclose(volume_cylinder(10, 5), 1570.7500000000002, rel_tol=0.001)"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    \"\"\"\n    Filter a dictionary to include only entries with values greater than or equal to n.\n    \n    Args:\n    dictionary (dict): The input dictionary.\n    n (int): The threshold value.\n    \n    Returns:\n    dict: The filtered dictionary.\n    \"\"\"\n    filtered_dict = {key: value for key, value in dictionary.items() if value >= n}\n    return filtered_dict\n\n# Test the function with the provided example\nassert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190}, 170) == {'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}"}
{"task_id": "Mbpp/278", "solution": "def count_before_tuple(data):\n    count = 0\n    for item in data:\n        if isinstance(item, tuple):\n            count_in_tuple = 0\n            for sub_item in item:\n                if isinstance(sub_item, (int, str, list)):\n                    count_in_tuple += 1\n            count += count_in_tuple\n        else:\n            count += 1\n    return count\n\n# Test cases"}
{"task_id": "Mbpp/279", "solution": "def is_decagonal_number(n):\n    # A decagonal number is given by the formula: D_n = 4.5 * n^2 - 3 * n + 1\n    # We need to check if the calculated decagonal number matches the input 'n'\n    decagonal_number = 4.5 * n**2 - 3 * n + 1\n    return decagonal_number == n\n\n# Testing the function"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    \"\"\"\n    Function to find an element in a list and return a tuple containing a boolean indicating its presence and its index (or -1 if not found).\n    :param arr: List of elements.\n    :param element: Element to search for.\n    :return: Tuple (boolean, index).\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)\n\n# Test the function\nassert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): A list of elements.\n    \n    Returns:\n    bool: True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))\n\n# Test cases\nassert all_unique([1, 2, 3]) == True\nassert not all_unique([1, 1, 2, 2, 3, 3]) == False\nassert all_unique(['a', 'b', 'c']) == True\nassert not all_unique(['a', 'b', 'c', 'a']) == False"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    \"\"\"\n    Subtracts two lists element-wise.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        \n    Returns:\n        list: The result of subtracting corresponding elements from both lists.\n    \"\"\"\n    return [a - b for a, b in zip(list1, list2)]\n\n# Test the function\nassert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"}
{"task_id": "Mbpp/283", "solution": "def convert_number_to_digits(n):\n    # Convert the number to a string first\n    num_str = str(n)\n    # Then convert the string to a list of characters (digits)\n    digit_list = list(num_str)\n    return digit_list\n\n# Example usage:\nnumber = 12345\ndigits = convert_number_to_digits(number)"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    \"\"\"\n    Check if all elements in the list are equal to the given element.\n    \n    Args:\n        lst (list): A list of elements to be checked.\n        element (any): The element to compare against each item in the list.\n        \n    Returns:\n        bool: True if all elements in the list are equal to the given element, False otherwise.\n    \"\"\"\n    return all(item == element for item in lst)\n\n# Test cases\nassert check_element([\"green\", \"orange\", \"black\", \"white\"], 'blue') == False, \"Test case 1 failed\"\nassert check_element([\"blue\", \"blue\", \"blue\"], 'blue') == True, \"Test case 2 failed\"\nassert check_element([1, 1, 1], 1) == True, \"Test case 3 failed\"\nassert check_element([\"apple\", \"banana\", \"cherry\"], \"fruit\") == True, \"Test case 4 failed\""}
{"task_id": "Mbpp/285", "solution": "def text_match_two_three(text):\n    # Check if 'a' is followed by exactly two 'b's\n    if text.startswith('ab'):\n        return True\n    # Check if 'a' is followed by exactly three 'b's\n    elif text.startswith('abb'):\n        return True\n    # If neither condition is met, return False\n    else:\n        return False\n\n# Test cases\nassert text_match_two_three(\"ac\") == False  # Expected result\nassert text_match_two_three(\"abb\") == True   # 'a' followed by exactly three 'b's\nassert text_match_two_three(\"abab\") == False # 'a' followed by two 'b's"}
{"task_id": "Mbpp/286", "solution": "def correct_subarray_sum(arr, k):\n    \"\"\"\n    Corrects the issues in the original student's code:\n    \n    1. Properly calculates the sum of subarrays by repeating the original array 'k' times.\n    2. Ensures the repeated sum calculation is based on 'k' repetitions, not a factor of 'rep'.\n    3. Adjusts the logic to consider subarrays formed by repeating the original array 'k' times.\n\n    Args:\n        arr (list): The input array.\n        k (int): The number of times the array should be repeated.\n\n    Returns:\n        int: The sum of the subarrays formed by repeating the original array 'k' times.\n    \"\"\"\n    # Calculate the sum of the original array\n    original_sum = sum(arr)\n    \n    # Calculate the sum of subarrays by repeating the original array 'k' times\n    repeated_sum = k * original_sum\n    \n    return repeated_sum\n\n# Example usage:\n# arr = [1, 2, 3, 4, 5]\n# k = 2\n# print(correct_subarray_sum(arr, k))  # Expected output: 30\n\n# Test cases\ntest_cases = [\n    ([-1, -1, 2], 2, -1),  # Expected: 0\n    ([1, 2, 3], 3, 6),  # Expected: 18\n    ([5, 5, 5, 5], 1, 5),  # Expected: 20\n    ([1, 2, 3, 4], 2, 10),  # Expected: 30\n]\n\nfor arr, k, expected in test_cases:\n    result = correct_subarray_sum(arr, k)\n    print(f\"Test case {arr} with k={k} gives result {result}, expected {expected}\")"}
{"task_id": "Mbpp/287", "solution": "def square_sum(n):\n    \"\"\"\n    Calculate the sum of squares of the first n even natural numbers.\n    \"\"\"\n    sum_of_squares = 0\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            sum_of_squares += i ** 2\n    return sum_of_squares\n\n# Test cases"}
{"task_id": "Mbpp/290", "solution": "def max_length(lst):\n    \"\"\"\n    Function to find the list of maximum length in a list of lists.\n    \n    :param lst: A list of lists.\n    :return: A tuple where the first element is the length of the longest list and the second element is the longest list itself.\n    \"\"\"\n    max_len = 0\n    longest_list = []\n    \n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            longest_list = sublist\n    \n    return (max_len, longest_list)\n\n# Test the function\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"}
{"task_id": "Mbpp/292", "solution": "def quotient(a, b):\n    \"\"\"\n    Calculate the quotient of two numbers, rounding down to the nearest integer.\n    \n    :param a: The dividend\n    :param b: The divisor\n    :return: The integer quotient\n    \"\"\"\n    return a // b\n\n# Test cases to ensure correctness\nassert quotient(10, 3) == 3  # Expected: 3\nassert quotient(15, 5) == 3  # Expected: 3\nassert quotient(20, 4) == 5  # Expected: 5\nassert quotient(25, 5) == 5  # Expected: 5\nassert quotient(30, 6) == 5  # Expected: 5\nassert quotient(35, 7) == 5  # Expected: 5\nassert quotient(40, 8) == 5  # Expected: 5\nassert quotient(45, 9) == 5  # Expected: 5\nassert quotient(50, 10) == 5  # Expected: 5\n"}
{"task_id": "Mbpp/293", "solution": "import math\n\ndef otherside_rightangle(a, b):\n    # Pythagorean theorem: c^2 = a^2 + b^2\n    c = math.sqrt(a**2 + b**2)\n    return c\n\n# Test the function with the provided example\nassert otherside_rightangle(7, 8) == 10.63014581273465"}
{"task_id": "Mbpp/294", "solution": "def find_max_in_numeric_list(lst):\n    \"\"\"\n    Finds the maximum value in a list after filtering out non-numeric elements.\n    \n    Args:\n    lst (list): A list containing both numeric and non-numeric elements.\n    \n    Returns:\n    float: The maximum numeric value in the filtered list.\n    \"\"\"\n    # Filter out non-numeric elements using a list comprehension\n    numeric_list = [num for num in lst if isinstance(num, (int, float))]\n\n    # If the list is empty after filtering, return None\n    if not numeric_list:\n        return None\n\n    # Use the built-in max function to find the maximum value in the numeric list\n    return max(numeric_list)\n\n# Example usage:\n# Test with a list containing both numeric and non-numeric elements\ntest_list = [5, 'a', 10, 15, 'b', 20.5]"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n    \n    Args:\n        arr (list): A list of integers.\n        \n    Returns:\n        int: The number of inversions in the array.\n    \"\"\"\n    inv_count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    \n    return inv_count\n\n# Test case\nassert get_Inv_Count([1, 20, 6, 4, 5]) == 5"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"Flattens a given nested list structure.\"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n\n# Test the function with the provided example\nassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"}
{"task_id": "Mbpp/299", "solution": "def find_max_score_and_name():\n    # Initialize a dictionary to store scores and names\n    scores_and_names = {}\n\n    # Example data\n    scores_and_names['Alice'] = [85, 90]\n    scores_and_names['Bob'] = [80, 95]\n    scores_and_names['Charlie'] = [75, 88]\n\n    # Find the name associated with the highest score\n    max_score_name = max(scores_and_names, key=lambda x: sum(x))\n\n    # Return the name and the maximum aggregate score\n    return max_score_name, sum(scores_and_names[max_score_name])\n\n# Test the function\nname, max_score = find_max_score_and_name()"}
{"task_id": "Mbpp/300", "solution": "def count_valid_binary_sequences(n):\n    \"\"\"\n    This function counts the number of valid binary sequences of length n\n    where the middle bit is 1 and all other bits are 0.\n    \"\"\"\n    # If n is less than 2, there are no valid sequences\n    if n < 2:\n        return 0\n\n    # For sequences of length 2, there is only one valid sequence: \"01\"\n    if n == 2:\n        return 1\n\n    # For sequences of length 3 or more, the middle bit must be 1 and all other bits must be 0\n    # The valid sequence pattern is \"0...1...0\" repeated n-2 times\n    return (2 ** (n - 2))  # Each group of \"0...1...0\" can be repeated (2^(n-2)) times\n\n# Example usage:\n# For n = 4, the valid sequences are \"0001\", \"0010\", \"0100\", \"1000\"\n# There is only one valid sequence where the middle bit is 1: \"0010\"\n"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(d, depth=1):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    Args:\n    d (dict): The dictionary to calculate the depth of.\n\n    Returns:\n    int: The depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise ValueError(\"Input must be a dictionary.\")\n    \n    # Base case: if the dictionary is empty, return 0\n    if not d:\n        return 0\n\n    # Start with the initial depth\n    current_depth = depth\n\n    # Iterate over the keys and values\n    for key, value in d.items():\n        # If the value is another dictionary, recursively call the function\n        if isinstance(value, dict):\n            # Update the depth for the nested dictionary\n            current_depth += dict_depth(value, depth=depth)\n        else:\n            # Increment the depth for non-dictionary values\n            current_depth += 1\n\n    return current_depth\n\n# Test cases to validate the function\n# Simple dictionary with no nested dictionaries"}
{"task_id": "Mbpp/305", "solution": "def start_with_p(words):\n    # Convert each word to lowercase before checking if it starts with 'p'\n    return [word for word in words if word.lower().startswith('p')]\n\n# Test the function\nwords = ['Peach', 'apple', 'Pine', 'Pear', 'Penguin', 'Pumpkin']"}
{"task_id": "Mbpp/306", "solution": "def find_increasing_subsequence_sum(arr):\n    # Initialize a 2D DP table to store the length of the longest increasing subsequence\n    n = len(arr)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            if arr[i - 1] > arr[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # The length of the longest increasing subsequence is stored in dp[n]\n    return dp[n][n]\n\n# Example usage:\n# arr = [5, 3, 2, 9, 6, 5]\n# print(find_increasing_subsequence_sum(arr))  # Output: 9"}
{"task_id": "Mbpp/308", "solution": "def calculate_products(list1, list2):\n    \"\"\"\n    Calculate the product of elements in list1 with their corresponding elements in list2.\n\n    :param list1: A list of integers.\n    :param list2: A list of integers.\n    :return: A dictionary where keys are from list1 and values are the products with elements from list2.\n    \"\"\"\n    # Correcting the iteration over the second list\n    for j, factor2 in enumerate(list2):\n        product = list1[j] * factor2\n        # Storing the product in a dictionary\n        if j in dict:\n            dict[j] = product\n        else:\n            dict[j] = product\n\n    return dict\n\n# Example usage:\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nresult = calculate_products(list1, list2)"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"Return the maximum of two numbers.\"\"\"\n    if a >= b:\n        return a\n    else:\n        return b\n\n# Test the function\nassert maximum(5, 10) == 10\nassert maximum(2, 7) == 7\nassert maximum(-3, 0) == 0\nassert maximum(0, -5) == -5"}
{"task_id": "Mbpp/310", "solution": "# Original incorrect function\ndef string_to_tuple(s):\n    return tuple(s)\n\n# Corrected function using list comprehension\ndef string_to_tuple_correct(s):\n    return tuple(char for char in s)\n\n# Test cases"}
{"task_id": "Mbpp/311", "solution": "def find_and_set_left_most_unset_bit(binary_str):\n    # Convert binary string to integer to easily access bits\n    binary_num = int(binary_str, 2)\n    \n    # Find the leftmost unset bit using bitwise operations\n    left_most_unset_bit_index = 0\n    while (binary_num & (1 << left_most_unset_bit_index)) == 0:\n        left_most_unset_bit_index += 1\n    \n    # Ensure the leftmost unset bit is set correctly\n    # Convert the index back to binary string format\n    left_most_unset_bit = bin(left_most_unset_bit_index)[2:]\n    \n    # Set the leftmost unset bit in the original binary string\n    binary_str = binary_str[:left_most_unset_bit_index] + '1' + binary_str[left_most_unset_bit_index:]\n\n    return binary_str\n\n# Test cases to validate the solution\nassert find_and_set_left_most_unset_bit('1100') == '11001'\nassert find_and_set_left_most_unset_bit('1011') == '10111'\nassert find_and_set_left_most_unset_bit('1111') == '11111'  # All bits are already set, no change needed\n"}
{"task_id": "Mbpp/312", "solution": "import math\n\n# Function to calculate the volume of a cone\ndef volume_cone(r, h):\n    \"\"\"\n    Calculate the volume of a cone given the radius (r) and height (h).\n    :param r: float, the radius of the base of the cone.\n    :param h: float, the height of the cone.\n    :return: float, the volume of the cone.\n    \"\"\"\n    return (1/3) * math.pi * r**2 * h\n\n# Test the function with the given values\nassert math.isclose(volume_cone(5, 12), 314.15926535897927, rel_tol=0.001)\n\n# Additional test cases for validation"}
{"task_id": "Mbpp/388", "solution": "def highest_power_of_2(n):\n    \"\"\"\n    Finds the highest power of 2 that is less than or equal to n.\n    \"\"\"\n    # Initial value of power_of_2 is 0, which is the power of 2 that is less than any number\n    power_of_2 = 0\n\n    while power_of_2 <= n:\n        power_of_2 += 1\n\n    return power_of_2\n\n# Test the function with some examples\nn = 15"}
{"task_id": "Mbpp/389", "solution": "def lucas_numbers(n):\n    \"\"\"\n    Function to compute the nth Lucas number.\n    \n    The Lucas sequence is similar to the Fibonacci sequence but starts with 2 and 1 instead of 0 and 1.\n    The nth Lucas number (L_n) can be computed using the formula:\n    L_n = L_(n-1) + L_(n-2)\n    with initial conditions L_0 = 2 and L_1 = 1.\n    \n    Args:\n    n (int): The position of the Lucas number to compute.\n    \n    Returns:\n    int: The nth Lucas number.\n    \"\"\"\n    lucas_sequence = [2, 1]  # Initial conditions for the Lucas sequence\n\n    # Correctly fill the Lucas sequence list by properly handling indexing\n    for i in range(2, n):\n        lucas_sequence.append(lucas_sequence[i-1] + lucas_sequence[i-2])\n\n    return lucas_sequence[n-1]\n\n# Test the function with some examples"}
{"task_id": "Mbpp/390", "solution": "def format_list_elements(lst, format_str):\n    \"\"\"\n    Formats each element in the list using the provided format string.\n    \n    Args:\n    lst (list): The list to be formatted.\n    format_str (str): The format string to be applied to each element.\n    \n    Returns:\n    list: The list with each element formatted according to the format string.\n    \"\"\"\n    return [format_str.format(**element) for element in lst]\n\n# Example usage:\n# Test the function with a simple list and format string\nexample_list = [1, 2.0, 'three', None]\nformat_str = \"{:.1f} {} {}\".format\n\n# Expected output: ['1.0', '2.0', 'three', 'None']\nformatted_list = format_list_elements(example_list, format_str)"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(list1, list2, list3):\n    # Ensure that list2 is a list of tuples where each tuple contains (student_id, name, grade)\n    if not all(isinstance(item, tuple) and len(item) == 3 for item in list2):\n        raise ValueError(\"List2 must contain tuples with exactly 3 elements: (student_id, name, grade)\")\n\n    # Initialize an empty dictionary to store the result\n    result_dict = {}\n\n    # Loop through list1 and list2 to create a dictionary where student IDs are keys and names and grades are values\n    for student_id, name, grade in list2:\n        if student_id in result_dict:\n            # If the student ID already exists, append the new grade to the existing list of grades\n            result_dict[student_id]['grades'].append(grade)\n        else:\n            # If the student ID does not exist, create a new entry with the student's name and a list containing the grade\n            result_dict[student_id] = {'name': name, 'grades': [grade]}\n\n    # Return the resulting dictionary\n    return result_dict\n\n# Example usage:\n# list1 = ['ID1', 'ID2', 'ID3']\n# list2 = [('ID1', 'John', 'A'), ('ID2', 'Jane', 'B'), ('ID3', 'Mike', 'C')]\n# list3 = ['A', 'B', 'C']\n\n# Call the function and print the result"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize memoization dictionary\n    memo = {}\n    \n    # Recursive function to compute the maximum sum\n    def helper(n):\n        # Check if the value is in the memoization dictionary\n        if n in memo:\n            return memo[n]\n        \n        # Base cases for division\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        \n        # Calculate the sum for the current division\n        current_sum = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        \n        # Store the result in memoization dictionary\n        memo[n] = current_sum\n        \n        return current_sum\n    \n    # Call the helper function with the input n\n    return helper(n)\n\n# Test the function with the given assertion\nassert get_max_sum(60) == 106"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(tup):\n    \"\"\"Check if a tuple contains no duplicates.\"\"\"\n    return len(tup) == len(set(tup))\n\n# Test case\nassert check_distinct((1, 4, 5, 6, 1, 4)) == False\nassert check_distinct((1, 2, 3, 4, 5)) == True"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    :param string: The input string.\n    :return: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None\n\n# Test cases\nassert first_non_repeating_character(\"abcabc\") == None\nassert first_non_repeating_character(\"abc\") == 'a'\nassert first_non_repeating_character(\"abcd\") == 'd'\nassert first_non_repeating_character(\"abcdcba\") == 'c'"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    # Sort the numbers\n    sorted_numbers = sorted([a, b, c])\n    \n    # Calculate the median\n    n = len(sorted_numbers)\n    if n % 2 == 1:\n        # If odd, return the middle number\n        return sorted_numbers[n // 2]\n    else:\n        # If even, return the average of the two middle numbers\n        return (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2.0\n\n# Test the function\nassert median_numbers(25, 55, 65) == 55.0"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Calculate the sum of digits in a list of integers.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The sum of the digits in the provided list.\n    \"\"\"\n    total = 0\n    for num in numbers:\n        total += sum(int(digit) for digit in str(num))\n    return total\n\n# Example usage:\n# Incorrectly formatted input (not a list)\n# Expected output: Error message indicating incorrect input format\ntry:\n    print(sum_of_digits([123, 456]))  # This should raise a TypeError\nexcept TypeError as e:\n    print(f\"Error: {e} - Input must be a list of integers.\")\n\n# Correctly formatted input\n# Expected output: 9 (since 1+2+3 + 4+5+6 = 9 + 15 = 24)"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"Return the minimum of two numbers a and b.\"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n\n# Test cases\nassert minimum(1, 2) == 1\nassert minimum(3, 5) == 3\nassert minimum(-10, 0) == -10\nassert minimum(0, -5) == -5"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n    \n    Args:\n        tuplex (tuple): The tuple to search within.\n        element (str): The element to check for existence.\n        \n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex\n\n# Test case\nassert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r') == True"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(num):\n    \"\"\"\n    Determine if the parity (odd or even nature) of the given number is odd.\n    \n    :param num: The number to check for odd parity.\n    :return: True if the number is odd, False otherwise.\n    \"\"\"\n    if num % 2 == 1:\n        return True  # The number is odd\n    else:\n        return False  # The number is even\n\n# Test cases\nassert find_Parity(12) == False  # Expected: False, because 12 is even\nassert find_Parity(5) == True   # Expected: True, because 5 is odd\nassert find_Parity(0) == False  # Expected: False, because 0 is even\nassert find_Parity(7) == True   # Expected: True, because 7 is odd"}
{"task_id": "Mbpp/409", "solution": "def find_min_product(tuples):\n    min_product = (None, float('inf'))  # Initialize with a non-comparable tuple and infinity\n    for product_tuple in tuples:\n        # Convert each tuple to a list to facilitate element-wise comparison\n        list_product = list(product_tuple)\n        # Calculate the product of elements in the list\n        product_value = 1\n        for num in list_product:\n            product_value *= num\n        # Correctly compare the product value with the current min_product\n        if product_value < min_product[0] or (product_value == min_product[0] and product_tuple[1] < min_product[1]):\n            min_product = (product_tuple, product_value)\n    return min_product\n\n# Example usage:\ntuples = [(2, 3), (1, 4), (5, 6)]\nresult = find_min_product(tuples)"}
{"task_id": "Mbpp/410", "solution": "def handle_heterogeneous_list(lst):\n    \"\"\"\n    Function to handle a heterogeneous list and find the minimum value.\n    \"\"\"\n    # Convert all elements to strings to ensure uniformity\n    lst = [str(item) for item in lst]\n    \n    # Initialize minimum to a large value\n    min_value = float('inf')\n    \n    # Iterate through the list to find the minimum string value\n    for element in lst:\n        # Convert the string back to its original type if possible\n        try:\n            value = int(element)\n        except ValueError:\n            # If conversion to integer fails, keep it as a string\n            pass\n        \n        # Update the minimum value if the current element is smaller\n        if value < min_value:\n            min_value = value\n    \n    return min_value\n\n# Test the function with a heterogeneous list"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    Remove all odd numbers from a given list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    list: A new list with all odd numbers removed.\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]\n\n# Test cases\nassert remove_odd([1, 2, 3]) == [2]\nassert remove_odd([4, 5, 6, 7, 8]) == [4, 6, 8]\nassert remove_odd([]) == []\nassert remove_odd([9, 10, 11, 12, 13]) == [10, 12]"}
{"task_id": "Mbpp/413", "solution": "def correct_list_index(n, lst):\n    \"\"\"\n    Correctly checks if the index 'n' is within the bounds of the list 'lst'.\n    \"\"\"\n    # Corrected condition to ensure n is within the list's length\n    if n >= len(lst):\n        return True\n    else:\n        return False\n\n# Test cases to validate the function"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n    :param seq1: List or iterable of values.\n    :param seq2: List or iterable of values.\n    :return: Boolean indicating whether there is an overlap.\n    \"\"\"\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False\n\n# Test cases\nassert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False\nassert overlapping([1, 2, 3], [2, 4, 6]) == True\nassert overlapping(['a', 'b', 'c'], ['b', 'c', 'd']) == True\nassert overlapping([], [1, 2, 3]) == False"}
{"task_id": "Mbpp/415", "solution": "def max_product_pair(nums):\n    # Initialize maximum product and corresponding pair\n    max_product = float('-inf')\n    max_pair = (None, None)\n    \n    # Iterate through the list of numbers\n    for i in range(len(nums)):\n        # Initialize current product and pair\n        current_product = 1\n        current_pair = (nums[i],)\n        \n        # Update current product considering both positive and negative numbers\n        for j in range(i, len(nums)):\n            current_product *= (-1 ** (j - i)) * nums[j]\n            current_pair = (nums[j],)  # Update pair\n        \n            # Check if current product is greater than max_product\n            if current_product > max_product:\n                max_product = current_product\n                max_pair = current_pair\n    \n    return max_pair\n\n# Example usage\nnums = [-2, -3, 4, -1, 5]"}
{"task_id": "Mbpp/418", "solution": "def find_max_length_elements(text):\n    # Split the text into words\n    words = text.split()\n    \n    # Initialize an empty list to store words with max length\n    max_length_words = []\n    \n    # Iterate through each word\n    for word in words:\n        # Check if the length of the current word is equal to the max length found so far\n        if len(word) == max(len(word) for word in words):\n            # If it is, append it to the list\n            max_length_words.append(word)\n    \n    return max_length_words\n\n# Example usage:\ntext = \"This is a test. This is only a test. The quick brown fox jumps over the lazy dog.\""}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    return total_sum * len(numbers)\n\n# Test case\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]) == 243"}
{"task_id": "Mbpp/420", "solution": "def generate_even_numbers(n):\n    \"\"\"\n    Generate a list of even numbers from 0 up to but not including n.\n    \"\"\"\n    return [i for i in range(n // 2)]\n\n# Test the function with different values of n"}
{"task_id": "Mbpp/421", "solution": "def join_tuple_with_delimiter(tup, delimiter):\n    \"\"\"\n    Join elements of a tuple with a specified delimiter.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    delimiter (str): The string to be used as a delimiter between elements.\n    \n    Returns:\n    str: The joined string with elements of the tuple separated by the specified delimiter.\n    \"\"\"\n    return delimiter.join(tup)\n\n# Test the function\ntup = ('apple', 'banana', 'cherry')\ndelimiter = ' '"}
{"task_id": "Mbpp/422", "solution": "def average_of_cubes(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    \n    # Calculate the average by dividing the sum by n\n    average = sum_of_cubes / n\n    \n    return average\n\n# Test the function with a few examples"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(tup):\n    \"\"\"Extract the last character from each string in the given tuple.\"\"\"\n    return [s[-1] for s in tup]\n\n# Test the function\nassert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param lst: List of lists.\n    :param element: Element to search for in sublists.\n    :return: Number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n\n# Test the function\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"}
{"task_id": "Mbpp/426", "solution": "def filter_odd_numbers(numbers):\n    \"\"\"\n    Filters a list of numbers to include only odd numbers.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    list: A new list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]\n\n# Test the function with an empty list\nassert filter_odd_numbers([]) == []\n\n# Test the function with a list containing odd and even numbers\nassert filter_odd_numbers([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n\n# Additional test cases for robustness\nassert filter_odd_numbers([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 3, 5, 7, 9]\nassert filter_odd_numbers([-1, -3, -5]) == [-1, -3, -5]\nassert filter_odd_numbers([]) == []"}
{"task_id": "Mbpp/427", "solution": "from datetime import datetime\n\ndef format_date(date_str):\n    \"\"\"\n    Formats a date string to include leading zeros for the month if necessary.\n    :param date_str: str, a date string in 'YYYY-MM-DD' format\n    :return: str, the formatted date string with leading zeros for the month if necessary\n    \"\"\"\n    # Split the date string into year, month, and day components\n    year, month, day = map(int, date_str.split('-'))\n    \n    # Format the month with leading zeros if necessary\n    formatted_month = '0' + str(min(10, month))\n    \n    # Construct the formatted date string\n    formatted_date = f\"{year}-{formatted_month}-{day}\"\n    \n    return formatted_date\n\n# Test cases\ndates = ['2022-03-15', '2022-04-30', '2022-05-01', '2022-06-15', '2022-07-05']\n\nfor date in dates:\n    print(f\"Original date: {date}\")\n    formatted_date = format_date(date)\n    print(f\"Formatted date: {formatted_date}\")\n    assert formatted_date == f\"{date.replace('-','')}\", f\"Failed for date: {date}\"\n    print()"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    # Initialize variables for shell sort\n    gap = len(arr) // 2\n    while gap > 0:\n        # Inner loop to sort segments of size 'gap'\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\n\n# Test the function with the provided example\nassert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"}
{"task_id": "Mbpp/429", "solution": "def combine_lists(list1, list2):\n    # Incorrect return statement initially returns two lists\n    # Correcting the return statement to return a single tuple\n    return (list1, list2)\n\n# Test the function\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nresult = combine_lists(list1, list2)\n\n# Expected output is a tuple, not two separate lists\nassert type(result) == tuple\nassert result == ((1, 2, 3), (4, 5, 6))\n"}
{"task_id": "Mbpp/430", "solution": "def find_directrix(a, b, c):\n    \"\"\"\n    This function calculates the directrix of a parabola given its standard form equation:\n    y = (1/4p) * (x - a) ** 2 + b\n\n    Parameters:\n    a (float): The x-coordinate of the vertex.\n    b (float): The y-coordinate of the vertex.\n    c (float): The constant term.\n\n    Returns:\n    float: The distance from the vertex to the directrix.\n    \"\"\"\n    # Extract the parameter p from the equation\n    # y = (1/4p) * (x - a)^2 + b\n    # Rearrange to solve for p\n    # b = (1/4p) * (a)^2\n    # p = 4b / a^2\n\n    p = 4 * b / a**2\n\n    # The directrix is located at x = a + p\n    directrix = a + p\n\n    return directrix\n\n# Testing the function with correct parameters\nassert find_directrix(0, 0, 1) == 1.0, \"Test case 1 failed\"\nassert find_directrix(3, 6, 9) == 3.75, \"Test case 2 failed\""}
{"task_id": "Mbpp/432", "solution": "def calculate_median_trapezium(base1, base2):\n    \"\"\"\n    Calculate the median (average of the two bases) of a trapezium.\n    \n    Parameters:\n    base1 (float): The length of the first base.\n    base2 (float): The length of the second base.\n    \n    Returns:\n    float: The median length of the trapezium.\n    \"\"\"\n    # The correct formula for the median of a trapezium is the average of the two bases\n    median_length = (base1 + base2) / 2\n    return median_length\n\n# Test cases to validate the function\nassert calculate_median_trapezium(5, 10) == 7.5\nassert calculate_median_trapezium(3, 7) == 5.0\nassert calculate_median_trapezium(15, 20) == 17.5\n"}
{"task_id": "Mbpp/433", "solution": "def calculate_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    return length * width\n\n# Testing the function"}
{"task_id": "Mbpp/435", "solution": "def last_digit(n):\n    \"\"\"Return the last digit of the number n.\"\"\"\n    return n % 10\n\n# Test cases to ensure the function works correctly\n# The issue mentioned suggests checking inputs \"[][]\", which likely refers to invalid or unexpected inputs.\n# Here, we'll test with a variety of valid integers to confirm the function's correctness.\n\n# Valid test cases"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(numbers):\n    \"\"\"\n    Returns a list containing only the negative numbers from the input list.\n    \n    :param numbers: List of numbers\n    :return: List of negative numbers\n    \"\"\"\n    return [num for num in numbers if num < 0]\n\n# Test case\nassert neg_nos([-1, 4, 5, -6]) == [-1, -6]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(s):\n    \"\"\"\n    Remove odd characters from a string.\n    \n    :param s: str, the input string\n    :return: str, the string with odd characters removed\n    \"\"\"\n    # Convert the string to a list of characters\n    char_list = list(s)\n    \n    # Remove odd-indexed characters (0-based index)\n    char_list = char_list[1::2]\n    \n    # Join the list back into a string\n    return ''.join(char_list)\n\n# Test cases\nassert remove_odd(\"python\") == \"yhn\"\nassert remove_odd(\"hello\") == \"ello\"\nassert remove_odd(\"world\") == \"rld\"\nassert remove_odd(\"a\") == \"a\"\nassert remove_odd(\"123\") == \"23\""}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    # Convert each integer to a string and join them together\n    # Then convert the resulting string back to an integer\n    return int(''.join(map(str, numbers)))\n\n# Test the function\nassert multiple_to_single([11, 33, 50]) == 113350"}
{"task_id": "Mbpp/440", "solution": "def find_adverb_position(text):\n    \"\"\"\n    This function identifies the position of adverbs in a given text.\n    Adverbs are identified based on a more comprehensive pattern than just ending with 'ly'.\n    The function returns the positions of all adverbs found in the text as a list of integers.\n    \"\"\"\n    import re\n\n    # Define a regular expression pattern to match adverbs\n    # This pattern includes words ending with 'ly', but also considers other common adverb patterns\n    adverb_pattern = r'\\b([a-z]+)\\s*ly\\b|\\b([a-z]+)\\s*[!,;:?\\s]*[a-z]+\\b'\n\n    # Find all adverb matches in the text\n    adverb_positions = re.findall(adverb_pattern, text)\n\n    return adverb_positions\n\n# Example usage\ntext = \"She quickly ran. He surprisingly won. They usually eat early. This strangely tastes odd.\""}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given its side length.\n\n    Args:\n        side_length (int): The length of a side of the cube.\n\n    Returns:\n        int: The surface area of the cube.\n    \"\"\"\n    # A cube has 6 faces, each of which is a square with side length 'side_length'\n    # The area of one face is side_length ** 2\n    # The total surface area is 6 * (side_length ** 2)\n    surface_area = 6 * (side_length ** 2)\n    return surface_area\n\n# Test the function with the given assertion\nassert surfacearea_cube(5) == 150"}
{"task_id": "Mbpp/445", "solution": "def multiply_tuples(tup1, tup2):\n    \"\"\"\n    Function to multiply corresponding elements of two tuples.\n    \n    Args:\n    tup1 (tuple): A tuple of numbers.\n    tup2 (tuple): Another tuple of numbers.\n    \n    Returns:\n    tuple: A new tuple containing the product of corresponding elements from tup1 and tup2.\n    \"\"\"\n    # Ensure both tuples have the same length\n    if len(tup1) != len(tup2):\n        raise ValueError(\"Tuples must have the same length to be multiplied element-wise.\")\n    \n    # Initialize an empty tuple to store the results\n    result = tuple()\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(tup1)):\n        # Multiply the corresponding elements\n        result.append(tup1[i] * tup2[i])\n    \n    return result\n\n# Example usage\ntup1 = (2, 3, 4)\ntup2 = (6, 7, 8)\nresult = multiply_tuples(tup1, tup2)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tuple_list, element_list):\n    \"\"\"\n    Count the occurrence of all elements in the list within a tuple.\n    \n    Args:\n        tuple_list (tuple): A tuple containing elements to be checked.\n        element_list (list): A list of elements to count occurrences of in tuple_list.\n        \n    Returns:\n        int: The total count of occurrences of elements in element_list within tuple_list.\n    \"\"\"\n    count = 0\n    for element in element_list:\n        count += tuple_list.count(element)\n    return count\n\n# Test case\nassert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(lst):\n    \"\"\"\n    Function to find cubes of individual elements in a list.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        list: A list containing the cubes of the elements in the input list.\n    \"\"\"\n    return [x**3 for x in lst]\n\n# Test the function with the provided example\nassert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"}
{"task_id": "Mbpp/448", "solution": "def generate_perrin_numbers(n):\n    \"\"\"\n    Generate the first n Perrin numbers.\n    \n    :param n: int, the number of Perrin numbers to generate.\n    :return: list, a list containing the first n Perrin numbers.\n    \"\"\"\n    perrin_numbers = []\n    a, b = 1, 1\n    for _ in range(n):\n        a, b = b, 2 * b + a\n        perrin_numbers.append(b)\n    return perrin_numbers\n\ndef check_perrin_numbers(perrin_numbers):\n    \"\"\"\n    Check if a list of numbers is a sequence of Perrin numbers and if they are divisible by 5.\n    \n    :param perrin_numbers: list, a list of numbers presumed to be Perrin numbers.\n    :return: bool, True if all numbers in the list are Perrin numbers and divisible by 5, False otherwise.\n    \"\"\"\n    for i in range(len(perrin_numbers)):\n        if perrin_numbers[i] % 5 != 0:\n            return False\n    return True\n\n# Example usage\nperrin_numbers = generate_perrin_numbers(10)"}
{"task_id": "Mbpp/450", "solution": "def extract_strings(input_list, size):\n    \"\"\"\n    Extract a specified number of strings from the input list.\n    \n    Parameters:\n    input_list (list): The list of strings to extract from.\n    size (int): The number of strings to extract.\n    \n    Returns:\n    list: A list containing the specified number of strings from the input list.\n    \"\"\"\n    # Calculate the correct starting index based on the length of strings\n    start_index = 0\n    if size > len(input_list):\n        start_index = len(input_list)\n    \n    # Slice the list correctly\n    extracted_strings = input_list[start_index : start_index + size]\n    \n    return extracted_strings\n\n# Test the function\ninput_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\nsize = 3\nexpected_output = [\"apple\", \"banana\", \"cherry\"]\n"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    return string.replace(' ', '')\n\n# Test case\nassert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"}
{"task_id": "Mbpp/453", "solution": "def even_factors_sum(n):\n    \"\"\"\n    Calculate the sum of even factors of a given number 'n'.\n    \n    Args:\n    n (int): The number for which the sum of even factors is to be calculated.\n    \n    Returns:\n    int: The sum of even factors of 'n'.\n    \"\"\"\n    # Initialize the sum to zero\n    sum_even_factors = 0\n    \n    # Iterate through numbers from 2 to n (inclusive)\n    for i in range(2, n + 1):\n        # Check if 'i' is even and a factor of 'n'\n        if i % 2 == 0 and n % i == 0:\n            # Add 'i' to the sum if it is an even factor\n            sum_even_factors += i\n    \n    return sum_even_factors\n\n# Example usage:\n# Test the function with a few examples"}
{"task_id": "Mbpp/454", "solution": "def text_match_wordz(text):\n    \"\"\"\n    Check if the text contains the word 'z'.\n    \n    :param text: The input text to check.\n    :return: True if the word 'z' is found, False otherwise.\n    \"\"\"\n    return 'z' in text.lower()\n\n# Test the function\nassert text_match_wordz(\"pythonz.\") == True\nassert text_match_wordz(\"hello\") == False\nassert text_match_wordz(\"thisisazword\") == True"}
{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month):\n    \"\"\"\n    Check if the given month number contains 31 days.\n    \n    Args:\n        month (int): The number representing the month (1-12).\n        \n    Returns:\n        bool: True if the month has 31 days, False otherwise.\n    \"\"\"\n    # Months with 31 days\n    thirty_one_days_months = [1, 3, 5, 7, 8, 10, 12]\n    \n    if month in thirty_one_days_months:\n        return True\n    else:\n        return False\n\n# Test case\nassert check_monthnumb_number(5) == True, \"The function did not return True for month 5.\""}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\n\n# Test the function\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"}
{"task_id": "Mbpp/457", "solution": "def process_list_of_lists(input_list):\n    \"\"\"\n    This function takes a list of lists as input and returns a new list where each inner list\n    has been flattened into a single list of integers.\n    \"\"\"\n    return [item for sublist in input_list for item in sublist]\n\n# Test cases with adjusted input format\n# Original incorrect test case\n# assert process_list_of_lists([1, 2, 3]) == [1, 2, 3]  # This will fail because the input is not a list of lists\n\n# Corrected test cases with input as lists of integers\nassert process_list_of_lists([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]\nassert process_list_of_lists([[7], [8, 9]]) == [7, 8, 9]\nassert process_list_of_lists([]) == []\n"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (int or float): The length of the rectangle.\n        width (int or float): The width of the rectangle.\n\n    Returns:\n        int: The area of the rectangle.\n    \"\"\"\n    return length * width\n\n# Test the function\nassert rectangle_area(10, 20) == 200"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(input_string):\n    result = ''\n    for char in input_string:\n        if char.islower():\n            result += char\n    return result\n\n# Test case\nassert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"}
{"task_id": "Mbpp/460", "solution": "def extract_first_elements(lst):\n    \"\"\"Extract the first element from each sublist in a nested list.\"\"\"\n    return [item[0] for item in lst]\n\n# Test the function\nnested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nexpected_result = [1, 4, 7]"}
{"task_id": "Mbpp/462", "solution": "from itertools import combinations\n\ndef convert_combinations_to_list(combinations_iterator):\n    \"\"\"\n    Converts an iterator of tuples from itertools.combinations to a list.\n    \n    Args:\n    combinations_iterator (iterator): An iterator yielding tuples representing combinations.\n    \n    Returns:\n    list: A list containing the combinations from the iterator.\n    \"\"\"\n    return list(combinations_iterator)\n\n# Example usage\ncombinations = convert_combinations_to_list(combinations(range(5), 2))"}
{"task_id": "Mbpp/463", "solution": "def calculate_product(initial_product, items):\n    \"\"\"\n    Calculate the product of a list of items given an initial product.\n    \n    Args:\n        initial_product (int): The initial product value.\n        items (list): A list of integers representing the items to multiply.\n        \n    Returns:\n        int: The final product after multiplying all items with the initial product.\n    \"\"\"\n    # Handle the case where the initial product becomes zero\n    if initial_product == 0:\n        return 0\n    \n    # Initialize the product with the initial product\n    current_product = initial_product\n    \n    # Iterate through each item and update the product\n    for item in items:\n        # Ensure the item is not zero to avoid division by zero\n        if item != 0:\n            current_product *= item\n    \n    return current_product\n\n# Test cases to validate the function"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    \"\"\"\n    Function to drop empty items from a given dictionary.\n    \n    Args:\n        dictionary (dict): A dictionary containing items, some of which may be None.\n        \n    Returns:\n        dict: The original dictionary with all None values removed.\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}\n\n# Test case\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None}) == {'c1': 'Red', 'c2': 'Green'}"}
{"task_id": "Mbpp/468", "solution": "def max_product(nums):\n    \"\"\"\n    This function calculates the maximum product of an increasing subsequence in a list of numbers.\n    It handles the case of negative numbers correctly by ensuring that the product is maximized considering the absolute values.\n    \"\"\"\n    # Initialize variables\n    max_product = float('-inf')\n    start = 0\n    current_product = 1\n\n    # Iterate through the list\n    for i in range(len(nums)):\n        # Update current product considering the absolute values\n        current_product *= abs(nums[i])\n\n        # Update maximum product and start index if current product is greater\n        if current_product > max_product:\n            max_product = current_product\n            start = i\n\n    return max_product\n\n# Example usage\nnums = [-2, -3, 4, -1, 5, -6]"}
{"task_id": "Mbpp/470", "solution": "def pairwise_sum(tup):\n    \"\"\"\n    Calculate the pairwise sum of elements in a tuple.\n    \n    Args:\n    tup (tuple): A non-empty tuple of integers.\n    \n    Returns:\n    int: The sum of all pairwise additions of elements in the tuple.\n    \"\"\"\n    total_sum = 0\n    for i in range(len(tup)):\n        total_sum += tup[i] + tup[i + 1]\n    return total_sum\n\n# Test cases to ensure the function works correctly\ntup = (1, 2, 3, 4)\nassert pairwise_sum(tup) == 10  # (1+2) + (2+3) + (3+4) = 10\n\ntup = (5, 6, 7)\nassert pairwise_sum(tup) == 18  # (5+6) + (6+7) = 18\n\ntup = (8, 9)\nassert pairwise_sum(tup) == 17  # (8+9) = 17\n\ntup = ()\nassert pairwise_sum(tup) == 0  # No elements, sum is 0\n\ntup = [1, 2, 3]\nassert pairwise_sum(tup) == 6  # (1+2) + (2+3) = 6\n"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    Finds the product of the array elements modulo n.\n    \n    Args:\n    arr (list): A list of integers.\n    n (int): The modulus value.\n    \n    Returns:\n    int: The product of the array elements modulo n.\n    \"\"\"\n    product = 1\n    for num in arr:\n        product *= num\n        product %= n  # Update product modulo n after each multiplication\n    \n    return product\n\n# Test the function with the provided example\nassert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    \"\"\"\n    Check if the given list contains consecutive numbers.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # Check for consecutive numbers\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i + 1] - sorted_lst[i] != 1:\n            return False\n    \n    return True\n\n# Test cases\nassert check_Consecutive([1, 2, 3, 4, 5]) == True\nassert check_Consecutive([1, 3, 5, 7, 9]) == False\nassert check_Consecutive([2, 4, 6, 8]) == True\nassert check_Consecutive([1, 2, 3, 4, 6]) == False"}
{"task_id": "Mbpp/473", "solution": "def list_intersection_with_tuples(lst1, lst2):\n    # Convert inner lists to tuples\n    lst1 = [tuple(item) for item in lst1]\n    lst2 = [tuple(item) for item in lst2]\n    \n    # Find the intersection using set operations\n    intersection = set(lst1) & set(lst2)\n    \n    # Convert the intersection back to a list\n    return list(intersection)\n\n# Test cases to validate the solution\n# Case 1: Two lists with common elements as tuples"}
{"task_id": "Mbpp/474", "solution": "def replace_char(word, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n    \n    :param word: The input string.\n    :param char_to_replace: The character to be replaced.\n    :param replacement_char: The character to replace the specified character with.\n    :return: The modified string.\n    \"\"\"\n    return word.replace(char_to_replace, replacement_char)\n\n# Test the function\nassert replace_char(\"polygon\", 'y', 'l') == \"pollgon\""}
{"task_id": "Mbpp/475", "solution": "def sort_dict_by_value(my_dict):\n    \"\"\"Sorts a dictionary by its values in ascending order.\"\"\"\n    return {key: value for key, value in sorted(my_dict.items(), key=lambda item: item[1])}\n\n# Test case with the correct function name\ntest_dict = {'apple': 5, 'banana': 3, 'cherry': 1}\nsorted_dict = sort_dict_by_value(test_dict)"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    # Check if the array is empty\n    if not arr:\n        return None\n    \n    # Find the minimum and maximum values\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Calculate the sum of the minimum and maximum values\n    big_sum = min_val + max_val\n    \n    return big_sum\n\n# Test cases\nassert big_sum([1, 2, 3]) == 4\nassert big_sum([]) == None"}
{"task_id": "Mbpp/477", "solution": "def is_lower(input_str):\n    \"\"\"\n    Converts the given string to lower case.\n    \n    :param input_str: The input string to convert to lower case.\n    :return: The input string converted to lower case.\n    \"\"\"\n    return input_str.lower()\n\n# Test case\nassert is_lower(\"InValid\") == \"invalid\""}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(input_str):\n    result = \"\"\n    for char in input_str:\n        if char.isupper():\n            result += char\n    return result\n\n# Test cases\nassert remove_lowercase(\"PYTHon\") == 'PYTH'\nassert remove_lowercase(\"HELLOWorld\") == 'HELLO'\nassert remove_lowercase(\"PythonProgramming\") == 'PYTHONPROGRAMMING'"}
{"task_id": "Mbpp/479", "solution": "def first_Digit(number):\n    \"\"\"\n    Returns the first digit of the given number.\n    \n    :param number: An integer.\n    :return: The first digit of the number.\n    \"\"\"\n    # Convert the number to a string to easily access the first character\n    first_char = str(number)[0]\n    \n    # Check if the number is positive to avoid negative sign issues\n    if first_char >= '0':\n        return int(first_char)\n    else:\n        return None  # or raise an exception if negative numbers are not allowed\n\n# Test cases\nassert first_Digit(123) == 1\nassert first_Digit(456) == 4\nassert first_Digit(789) == 7\nassert first_Digit(-123) == None  # or raise ValueError if negative numbers are not allowed"}
{"task_id": "Mbpp/554", "solution": "def odd_numbers(input_list):\n    \"\"\"\n    This function filters out odd numbers from the input list using list comprehension and the modulo operator.\n    It also handles an empty input list by returning an empty list.\n    \"\"\"\n    if not input_list:  # Check if the list is empty\n        return []\n    return [num for num in input_list if num % 2 != 0]\n\n# Test cases"}
{"task_id": "Mbpp/555", "solution": "def sum_of_cubes(n):\n    \"\"\"\n    Calculate the sum of cubes of the first n natural numbers.\n    \n    The correct formula for the sum of cubes of the first n natural numbers is:\n    sum = (n * (n + 1) * (2 * n + 1)) // 6\n    \n    This formula is derived from the mathematical relationship between the sum of cubes and the sum of natural numbers.\n    \"\"\"\n    return (n * (n + 1) * (2 * n + 1)) // 6\n\n# Test the function with some examples"}
{"task_id": "Mbpp/556", "solution": "def count_odd_xor_pairs(numbers):\n    \"\"\"\n    Counts pairs of numbers whose XOR is odd.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The count of pairs whose XOR is odd.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 != 0:\n                count += 1\n    return count\n\n# Test cases\n# Ensure the test inputs are properly formatted as lists of integers\ntest_cases = [\n    [1, 2, 3],  # Expected output: 1 (1^2 = 1, 2^3 = 1)\n    [4, 5, 6],  # Expected output: 0 (4^5 = 21, 5^6 = 61, both are even)\n    [7, 8, 9],  # Expected output: 2 (7^8 = 15, 8^9 = 1)\n    [10, 11, 12],  # Expected output: 0 (10^11 = 2040, 11^12 = 6656, both are even)\n    [13, 14, 15],  # Expected output: 2 (13^14 = 7, 14^15 = 3)\n]\n\n# Run test cases\nfor test in test_cases:\n    result = count_odd_xor_pairs(test)\n    print(f\"Test case {test}: {result}\")"}
{"task_id": "Mbpp/557", "solution": "def toggle_case(s):\n    \"\"\"\n    Toggles the case of each character in the string without converting the entire string to uppercase or lowercase first.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n\n# Test cases"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    This function calculates the distance between two numbers based on their digits.\n    The distance is calculated as the sum of the absolute differences between corresponding digits.\n    \"\"\"\n    if isinstance(num1, int) and isinstance(num2, int):\n        # Convert both numbers to strings to easily access digits\n        str_num1 = str(num1)\n        str_num2 = str(num2)\n\n        # Calculate the distance by summing the absolute differences of corresponding digits\n        distance = sum(abs(int(str_num1[i]) - int(str_num2[i])) for i in range(len(str_num1)))\n\n        return distance\n    else:\n        raise ValueError(\"Both inputs must be integers.\")\n\n# Example usage:"}
{"task_id": "Mbpp/559", "solution": "def solve_problem(array_length):\n    \"\"\"\n    This function takes the length of an array as an argument and returns the sum of all elements in the array.\n    \"\"\"\n    # Assuming the array is filled with integers starting from 0 up to (array_length - 1)\n    array = list(range(array_length))\n    \n    # Calculate the sum of all elements in the array\n    total_sum = sum(array)\n    \n    return total_sum\n\n# Example usage:\n# The function should correctly handle an array of length 5"}
{"task_id": "Mbpp/560", "solution": "def union_sorted_tuples(tup1, tup2):\n    \"\"\"\n    This function finds the union of elements in two tuples and outputs them in sorted order.\n    :param tup1: First tuple\n    :param tup2: Second tuple\n    :return: Union of elements in sorted order\n    \"\"\"\n    # Convert input lists to tuples\n    tup1 = tuple(tup1)\n    tup2 = tuple(tup2)\n\n    # Find the union of the two tuples\n    union = tup1 | tup2\n\n    # Sort the union tuple\n    sorted_union = sorted(union)\n\n    return sorted_union\n\n# Example usage with input lists containing inner lists\n# Incorrect input format (lists within lists)\n# Incorrect_input = [[1, 2], [3, 4], [5, 6]]\n# Corrected_input = (1, 2), (3, 4), (5, 6)\n\n# Corrected_input = (1, 2), (3, 4), (5, 6)\ncorrected_input = (1, 2), (3, 4), (5, 6)\n\n# Call the function with corrected input\nresult = union_sorted_tuples(corrected_input)\n\n# Print the result"}
{"task_id": "Mbpp/562", "solution": "def longest_sublist_length(lst):\n    \"\"\"\n    Finds the length of the longest sublist in a given list.\n\n    Args:\n        lst (list): A list of integers or strings.\n\n    Returns:\n        int: The length of the longest sublist.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty.\")\n    \n    max_length = 0\n    current_length = 1\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            current_length += 1\n        else:\n            current_length = 1\n            max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Test cases"}
{"task_id": "Mbpp/563", "solution": "import re\n\ndef extract_quoted_words(text):\n    # Use regular expression to match and split words within quotation marks\n    quoted_words = re.findall(r'\"([^\"]*)\"', text)\n    return quoted_words\n\n# Example usage\ntext = \"This is a \"test\" sentence with \"quoted words\" and \"more.\""}
{"task_id": "Mbpp/564", "solution": "def count_Pairs(numbers, target):\n    \"\"\"\n    This function counts the number of pairs in the list of integers where each pair sums up to the target integer.\n    \n    Args:\n        numbers (list): A list of integers.\n        target (int): The target sum for the pairs.\n        \n    Returns:\n        int: The count of pairs that sum up to the target.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] + numbers[j] == target:\n                count += 1\n    return count\n\n# Test cases\nassert count_Pairs([1, 2, 3, 4, 5], 6) == 2  # (1+5) and (2+4)\nassert count_Pairs([1, 2, 3, 4], 5) == 0  # No pairs sum to 5\nassert count_Pairs([1, 2, 3], 4) == 0  # No pairs sum to 4\nassert count_Pairs([1, 2, 3, 4], 3) == 1  # (1+2)"}
{"task_id": "Mbpp/565", "solution": "def split_string(input_string):\n    return list(input_string)\n\n# Test cases\nassert split_string(\"hello\") == ['h', 'e', 'l', 'l', 'o']\nassert split_string(\"Python\") == ['P', 'y', 't', 'h', 'o', 'n']\nassert split_string(\"123\") == [1, 2, 3]\nassert split_string(\" \") == [ ' ' ]\n\n# Additional test case to ensure spaces are handled correctly\nassert split_string(\"Hello World\") == ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"Return the sum of the digits of a non-negative integer n.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\n# Test case\nassert sum_digits(345) == 12"}
{"task_id": "Mbpp/567", "solution": "def find_increasing_sequence(lst):\n    \"\"\"\n    This function finds the longest increasing subsequence in a list.\n    \"\"\"\n    # Correcting the loop condition to iterate up to len(lst) - 1\n    n = len(lst)\n    increasing_sequence = []\n\n    for i in range(n - 1):  # Changed from range(n - 2) to range(n - 1)\n        if lst[i] > lst[i + 1]:\n            # If current element is greater than the next one, it's part of an increasing subsequence\n            increasing_sequence.append(lst[i])\n            if len(increasing_sequence) > len(increasing_sequence[:]):  # Update the sequence if it becomes longer\n                increasing_sequence = increasing_sequence[:]\n\n    return increasing_sequence\n\n# Test cases"}
{"task_id": "Mbpp/568", "solution": "def create_empty_dictionaries(N):\n    \"\"\"\n    Creates a list of N empty dictionaries.\n    \n    Args:\n    N (int): The number of dictionaries to create.\n    \n    Returns:\n    list: A list containing N empty dictionaries.\n    \"\"\"\n    # Using list comprehension to create N empty dictionaries\n    return [{'key': 'value'} for _ in range(N)]\n\n# Testing the function\nempty_dicts = create_empty_dictionaries(5)"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(sublists):\n    # Function to sort a single sublist\n    def sort_sublist(sublist):\n        return sorted(sublist)\n\n    # Apply the sorting function to each sublist in the main list\n    return [sort_sublist(sublist) for sublist in sublists]\n\n# Test the function with the provided example\nassert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']])\n\n# Additional test cases for thoroughness\nassert sort_sublists([['red', 'blue'], ['yellow', 'purple'], ['pink', 'violet', 'indigo']]) == [['red', 'blue'], ['yellow', 'purple'], ['pink', 'violet', 'indigo']]\nassert sort_sublists([['apple'], ['banana'], ['cherry']] ) == [['apple'], ['banana'], ['cherry']]\nassert sort_sublists([]) == []"}
{"task_id": "Mbpp/572", "solution": "def process_lists(*lists):\n    # Ensure each input is a list\n    for item in lists:\n        if not isinstance(item, list):\n            raise ValueError(f\"Input {item} is not a list.\")\n    \n    # Process each list directly\n    for list_ in lists:\n        # Example processing: sum all elements in each list\n        total = sum(list_)\n        print(f\"Total of elements in list: {total}\")\n    \n    # Example: return the sum of all processed lists\n    return sum(process_lists(*lists))\n\n# Test the function with multiple lists\nresult = process_lists([1, 2, 3], [4, 5, 6], [7, 8, 9])"}
{"task_id": "Mbpp/573", "solution": "def unique_product(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Initialize the product to 1\n    product = 1\n    \n    # Iterate over the unique elements and multiply them\n    for num in unique_elements:\n        product *= num\n    \n    return product\n\n# Test the function with the provided example\nassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000\n\n# Additional test cases"}
{"task_id": "Mbpp/576", "solution": "def is_sublist(main_list, sub_list):\n    \"\"\"\n    Check if sub_list is a sublist of main_list maintaining the order of elements.\n    \n    Args:\n    main_list (list): The main list.\n    sub_list (list): The sub list to be checked.\n    \n    Returns:\n    bool: True if sub_list is a sublist of main_list in order, False otherwise.\n    \"\"\"\n    # Iterate through both lists simultaneously\n    for i in range(min(len(main_list), len(sub_list))):\n        if main_list[i] != sub_list[i]:\n            # If a mismatch is found, return False\n            return False\n    return True\n\n# Test cases"}
{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    # Calculate factorial\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    \n    # Extract the last digit using modulo operation\n    last_digit = fact % 10\n    return last_digit\n\n# Example usage with an integer argument"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n\n# Test the function with the provided example\nassert interleave_lists([1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n\n# Additional test cases\nassert interleave_lists([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]\nassert interleave_lists([], [], []) == []\nassert interleave_lists([1, 2], [3, 4], [5, 6]) == [1, 3, 5, 2, 4, 6]"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(t1, t2):\n    # Convert tuples to sets to easily find dissimilar elements\n    set1 = set(t1)\n    set2 = set(t2)\n    \n    # Find the elements in set1 but not in set2\n    dissimilar_in_t1 = set1 - set2\n    \n    # Find the elements in set2 but not in set1\n    dissimilar_in_t2 = set2 - set1\n    \n    # Combine both sets of dissimilar elements\n    dissimilar_elements = dissimilar_in_t1.union(dissimilar_in_t2)\n    \n    return list(dissimilar_elements)\n\n# Test the function with the provided example\nassert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"}
{"task_id": "Mbpp/580", "solution": "def handle_nested_tuples(data):\n    \"\"\"\n    Function to handle nested tuples by recursively iterating through them.\n    \"\"\"\n    # Base case: if data is not a tuple, return immediately\n    if not isinstance(data, tuple):\n        return data\n\n    # Initialize an empty list to store processed values\n    processed_values = []\n\n    # Recursive function to handle nested tuples\n    def process_nested(tup):\n        nonlocal processed_values\n        for item in tup:\n            if isinstance(item, tuple):\n                # If item is a tuple, recursively process it\n                processed_values.extend(process_nested(item))\n            else:\n                # Process non-tuple items\n                processed_values.append(item)\n\n    # Call the recursive function\n    process_nested(data)\n\n    # Return the list of processed values\n    return processed_values\n\n# Test the function with some data containing nested tuples\ndata = ((1, 2), ('a', 'b'), (3, (4, 5)))"}
{"task_id": "Mbpp/581", "solution": "import math\n\ndef calculate_square_pyramid_surface_area(base_length):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    Args:\n        base_length (float): The length of the base of the pyramid.\n\n    Returns:\n        float: The surface area of the square pyramid.\n    \"\"\"\n    # Correct formula for the surface area of a square pyramid\n    # Lateral surface area + base area\n    lateral_surface_area = 2 * math.sqrt(2) * base_length ** 2\n    base_area = base_length ** 2\n    total_surface_area = lateral_surface_area + base_area\n\n    return total_surface_area\n\n# Test the function with a sample input\nbase_length = 5\nsurface_area = calculate_square_pyramid_surface_area(base_length)"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    # Correct indexing for accessing calculated values in the list\n    catalan_values = [1]  # Base case: C(0) = 1\n    for i in range(1, n):  # Loop from 1 to n-1 to calculate C(n)\n        catalan_values.append(sum(catalan_values[:i] * catalan_values[i:]))\n    \n    return catalan_values[n-1]\n\n# Test the function with some values"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(items, n):\n    # Sort the items by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Return the first n items from the sorted list\n    return sorted_items[:n]\n\n# Test the function with the provided example\nitems = [{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}]\nn = 1\nassert expensive_items(items, n)[0]['name'] == 'Item-2' and expensive_items(items, n)[0]['price'] == 555.22\n\n# Additional test cases for further validation\nitems = [{'name': 'Expensive Item-1', 'price': 1000.0}, {'name': 'Expensive Item-2', 'price': 2000.0}, {'name': 'Item-3', 'price': 10.0}]\nn = 2\nassert expensive_items(items, n)[0]['name'] == 'Expensive Item-2' and expensive_items(items, n)[1]['name'] == 'Expensive Item-1'\n\nitems = [{'name': 'Cheapest Item', 'price': 1.0}, {'name': 'Second Cheapest', 'price': 2.0}, {'name': 'Most Expensive', 'price': 999.0}]\nn = 3\nassert expensive_items(items, n)[0]['name'] == 'Most Expensive' and expensive_items(items, n)[1]['name'] == 'Second Cheapest' and expensive_items(items, n)[2]['name'] == 'Cheapest Item'"}
{"task_id": "Mbpp/586", "solution": "def split_and_append(first_part, second_part):\n    \"\"\"\n    Splits a list into two parts and appends the first part to the end of the second part.\n    \n    Args:\n        first_part (list): The first part of the list to append.\n        second_part (list): The second part of the list.\n        \n    Returns:\n        list: The modified second part with the first part appended at the end.\n    \"\"\"\n    # Check if the input lists are not empty\n    if not first_part and not second_part:\n        return \"Error: Both input lists cannot be empty.\"\n    \n    # Split the lists\n    first_part_copy = first_part.copy()  # Create a copy to avoid modifying the original list\n    split_second_part = second_part[:len(first_part)]\n    remaining_second_part = second_part[len(first_part):]\n    \n    # Append the first part to the end of the modified second part\n    modified_second_part = split_second_part + first_part_copy\n    \n    return modified_second_part\n\n# Test cases"}
{"task_id": "Mbpp/587", "solution": "# Function to convert a list to a tuple\ndef list_to_tuple(lst):\n    return tuple(lst)\n\n# Test cases\n# Correct input\nassert list_to_tuple([1, 2, 3]) == (1, 2, 3)\n\n# Empty list\nassert list_to_tuple([]) == ()\n\n# Single element list\nassert list_to_tuple([4]) == (4)\n\n# Incorrect input (empty square brackets)\n# Updated assertion to correctly handle this case\nassert list_to_tuple([][]) == ()\n\n# Testing with various edge cases\nassert list_to_tuple([None]) == (None)\nassert list_to_tuple([True, False]) == (True, False)\nassert list_to_tuple([None, True, False]) == (None, True, False)\n"}
{"task_id": "Mbpp/588", "solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0\n    \n    min_val = min(lst)\n    max_val = max(lst)\n    \n    return max_val - min_val\n\n# Test cases\nassert big_diff([1, 2, 3, 4]) == 3\nassert big_diff([-1, -2, -3, -4]) == 7\nassert big_diff([0, 0, 0]) == 0\nassert big_diff([5, 5, 5, 5]) == 0"}
{"task_id": "Mbpp/589", "solution": "import math\n\ndef perfect_squares(start, end):\n    \"\"\"\n    Returns a list of perfect squares between the given range [start, end].\n    \"\"\"\n    perfect_squares_list = []\n    for num in range(start, end + 1):\n        square = num ** 2\n        if math.isqrt(square) ** 2 == square:  # Check if the square root is an integer\n            perfect_squares_list.append(square)\n    return perfect_squares_list\n\n# Example usage:"}
{"task_id": "Mbpp/590", "solution": "import cmath\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Converts polar coordinates (r, theta) to complex number representation.\n    theta should be in radians.\n    \n    Parameters:\n    r (float): The magnitude (radius) of the complex number.\n    theta (float): The angle (in radians) of the complex number.\n    \n    Returns:\n    complex: The complex number represented in rectangular form.\n    \"\"\"\n    if theta % (2 * cmath.pi) == 0:\n        # If theta is an integer multiple of 2*pi, no imaginary part is needed\n        return complex(r, 0)\n    else:\n        # For non-integer multiples of pi, calculate the imaginary part\n        imaginary_part = r * (1j if theta % (2 * cmath.pi) != 0 else 0)\n        return complex(r, imaginary_part)\n\n# Test cases"}
{"task_id": "Mbpp/591", "solution": "def swap_List(lst):\n    # Swapping the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n\n# Test case\nassert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"}
{"task_id": "Mbpp/592", "solution": "def sum_of_products_of_consecutive_binomial_coefficients(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    The correct formula to calculate the sum of the product of consecutive binomial coefficients\n    for the first n terms is:\n    sum = (2**(n-1)) * (1 + 2 + ... + n)\n\n    This can be derived from the properties of binomial coefficients and their products.\n\n    Args:\n        n (int): The number of terms in the sequence.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Calculate the sum of the first n natural numbers\n    sum_of_n = n * (n + 1) // 2\n\n    # Calculate the product of consecutive binomial coefficients\n    product_sum = 2**(n - 1) * sum_of_n\n\n    return product_sum\n\n# Example usage:\n# Testing the function with a few values of n\nresults = {n: sum_of_products_of_consecutive_binomial_coefficients(n) for n in range(1, 6)}"}
{"task_id": "Mbpp/593", "solution": "def remove_leading_zeros_from_ip(ip_address):\n    \"\"\"\n    Remove leading zeros from each segment of the IP address.\n\n    Args:\n        ip_address (str): The IP address as a string.\n\n    Returns:\n        str: The IP address with leading zeros removed from each segment.\n    \"\"\"\n    # Split the IP address into its segments\n    segments = ip_address.split('.')\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each segment\n    for segment in segments:\n        # Remove leading zeros from the current segment\n        cleaned_segment = segment.lstrip('0')\n        \n        # Append the cleaned segment to the result\n        result += cleaned_segment\n    \n    return result\n\n# Test the function with an example IP address\nip_address = \"192.168.0.1\""}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(numbers):\n    \"\"\"\n    Calculate the difference between the first even and the first odd number in the list.\n    \n    Args:\n        numbers (list): A list of integers.\n        \n    Returns:\n        int: The difference between the first even and the first odd number in the list.\n    \"\"\"\n    # Check if the list contains at least one even and one odd number\n    if not any(num % 2 == 0 for num in numbers) or not any(num % 2 != 0 for num in numbers):\n        raise ValueError(\"List must contain at least one even and one odd number.\")\n    \n    # Find the first even and first odd numbers\n    first_even = next(num for num in numbers if num % 2 == 0)\n    first_odd = next(num for num in numbers if num % 2 != 0)\n    \n    # Calculate the difference\n    return first_even - first_odd\n\n# Test the function\nassert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"}
{"task_id": "Mbpp/596", "solution": "import sys\n\ndef calculate_tuple_size(tup):\n    \"\"\"\n    Calculate the size of a tuple in bytes using sys.getsizeof().\n\n    Args:\n    tup (tuple): The tuple to measure the size of.\n\n    Returns:\n    int: The size of the tuple in bytes.\n    \"\"\"\n    # sys.getsizeof() returns the size of the object itself, not the size of each element.\n    # Therefore, we need to ensure we are measuring the tuple as a whole.\n    return sys.getsizeof(tup)\n\n# Test the function with a simple tuple"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays into one sorted array\n    merged = sorted(arr1 + arr2)\n    \n    # Return the kth element from the merged array\n    return merged[k - 1]\n\n# Test the function with the provided example\nassert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6"}
{"task_id": "Mbpp/598", "solution": "def is_armstrong_number(n):\n    # Ensure the input is a positive integer\n    if not isinstance(n, int) or n < 0:\n        return \"Error: Input must be a non-negative integer.\"\n\n    # Convert the number to a string to easily access each digit\n    digits = list(str(n))\n\n    # Calculate the sum of cubes of the digits\n    sum_of_cubes = sum(int(digit)**3 for digit in digits)\n\n    # Check if the sum of cubes is equal to the original number\n    return sum_of_cubes == n\n\n# Testing the function with various inputs"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n    \n    Args:\n        n (int): The number of natural numbers to consider.\n        \n    Returns:\n        Tuple: A tuple containing the sum and average of the first n natural numbers.\n    \"\"\"\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the average\n    average_n = sum_n / n\n    \n    return sum_n, average_n\n\n# Test the function\nresult = sum_average(10)"}
{"task_id": "Mbpp/600", "solution": "def is_Even(n):\n    \"\"\"\n    Check if the given number is even.\n    \"\"\"\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n\n# Test cases\nassert is_Even(1) == False, \"Test case 1 failed\"\nassert is_Even(2) == True, \"Test case 2 failed\"\nassert is_Even(0) == True, \"Test case 3 failed\"\nassert is_Even(4) == True, \"Test case 4 failed\""}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(string):\n    \"\"\"\n    Finds the first repeated character in a given string.\n\n    :param string: The input string.\n    :return: The first repeated character in the string, or None if no repetition is found.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            return char  # First repeated character found\n        char_count[char] = 1\n\n    return None  # No repeated character found\n\n# Test cases\nassert first_repeated_char(\"abcabc\") == \"a\"\nassert first_repeated_char(\"abcd\") == None\nassert first_repeated_char(\"aaabbb\") == \"a\"\nassert first_repeated_char(\"123456\") == None"}
{"task_id": "Mbpp/603", "solution": "def is_lucid(n):\n    \"\"\"Check if a number is lucid (a lucid number is a prime number that is not 1).\"\"\"\n    # Lucid numbers are prime numbers greater than 1\n    if n > 1 and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n        return True\n    else:\n        return False\n\n# Test cases"}
{"task_id": "Mbpp/604", "solution": "def reverse_word_order(sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the order of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a sentence\n    reversed_sentence = ' '.join(reversed_words)\n    \n    return reversed_sentence\n\n# Test the function\noriginal_sentence = \"Hello world this is a test\"\nreversed_sentence = reverse_word_order(original_sentence)"}
{"task_id": "Mbpp/605", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n# Testing the function with the value 13"}
{"task_id": "Mbpp/606", "solution": "import math\n\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n    \n    :param degrees: int or float representing degrees\n    :return: float representing radians\n    \"\"\"\n    return degrees * (math.pi / 180)\n\n# Test case\nassert abs(radian_degree(90) - 1.5707963267948966) < 1e-9, \"Test case failed: radian_degree(90) should be approximately 1.5708\""}
{"task_id": "Mbpp/607", "solution": "import re\n\ndef match_pattern(text, pattern):\n    # Ensure the pattern is a raw string\n    pattern = r\"{}\".format(pattern)\n    \n    # Use re.search() with the raw string pattern\n    match = re.search(pattern, text)\n    \n    if match:\n        return True\n    else:\n        return False\n\n# Example usage\ntext = \"Hello, World! This is a test.\"\npattern = \"World\"\nresult = match_pattern(text, pattern)\n"}
{"task_id": "Mbpp/608", "solution": "def nth_bell_number(n):\n    # Initialize the first Bell number\n    bell_numbers = [1]\n    \n    # Generate Bell numbers up to the nth term\n    for i in range(1, n):\n        next_bell_number = sum([bell_numbers[j] * (i // j) for j in range(1, i + 1)])\n        bell_numbers.append(next_bell_number)\n    \n    return bell_numbers[n - 1]\n\n# Test the function with some examples"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the kth element from the list.\n    \n    Args:\n    lst (list): The list to modify.\n    k (int): The index of the element to remove.\n    \n    Returns:\n    list: The list after removing the kth element.\n    \"\"\"\n    if k < 0 or k >= len(lst):\n        raise IndexError(\"Index out of range\")\n    \n    # Correctly remove the element at index k\n    lst.pop(k)\n    \n    return lst\n\n# Test cases"}
{"task_id": "Mbpp/611", "solution": "def validate_column_index(matrix, n):\n    \"\"\"\n    Validate if a column index is within the bounds of the matrix.\n    \n    Parameters:\n    - matrix (list): A list representing a matrix where each inner list represents a row.\n    - n (int): The column index to validate.\n\n    Returns:\n    - bool: True if the column index is valid, False otherwise.\n    \"\"\"\n    # Calculate the number of columns in the matrix\n    num_columns = len(matrix[0])\n    \n    # Validate the column index\n    if n < 0 or n >= num_columns:\n        return False\n    else:\n        return True\n\n# Example usage:\n# Test cases\ntest_cases = [\n    ({[1, 2], [3, 4]}, 0),  # Valid: 0-based index for the first column\n    ({[1, 2], [3, 4]}, 5),  # Invalid: 5 is out of bounds\n    ([], 0),  # Invalid: Empty matrix has no columns\n    ({[1], [2]}, 1),  # Valid: 1-based index for the second column\n    ({[1], [2]}, 3),  # Invalid: 3 is out of bounds\n]\n\n# Run test cases\nfor matrix, n in test_cases:\n    result = validate_column_index(matrix, n)\n    print(f\"Matrix: {matrix}, Column Index: {n}, Valid: {result}\")"}
{"task_id": "Mbpp/612", "solution": "def check_input(input_list):\n    \"\"\"\n    Function to check if the input is correctly formatted as a list of lists.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        return False, \"Input must be a list.\"\n\n    # Check if each element in the list is a list\n    for item in input_list:\n        if not isinstance(item, list):\n            return False, \"Each element in the list must be a list.\"\n\n    # If all checks pass, return True and an empty message\n    return True, \"\"\n\n# Test cases\ntest_cases = [\n    # Correctly formatted list of lists\n    ([1, 2, 3], [4, 5, 6], [7, 8, 9]),\n    # Single list (not a list of lists)\n    ([1, 2, 3]),\n    # Non-list input\n    \"Not a list\",\n    # Mixed types in a list\n    ([1, \"two\", 3]),\n    # Empty list\n    []\n]\n\nfor input, expected in test_cases:\n    result, message = check_input(input)\n    if result != expected:\n        print(f\"Failed for input: {input} - Expected {expected}, but got {result} with message: {message}\")\n    else:\n        print(f\"Passed for input: {input} - Expected {expected}, got {result} with message: {message}\")"}
{"task_id": "Mbpp/614", "solution": "def cumulative_sum(lst):\n    \"\"\"\n    Calculate the cumulative sum of a list of tuples.\n    \n    Args:\n        lst (list): A list of tuples where each tuple contains two integers.\n        \n    Returns:\n        int: The cumulative sum of the elements in the list.\n    \"\"\"\n    if not lst:\n        # Handle the edge case of an empty list\n        return 0\n    \n    cumulative_sum = 0\n    for tup in lst:\n        cumulative_sum += tup[0] + tup[1]\n    \n    return cumulative_sum\n\n# Test cases"}
{"task_id": "Mbpp/615", "solution": "# Define the function to calculate the average of tuples\ndef average_tuple(tuples):\n    # Ensure the input is a tuple of tuples\n    if not isinstance(tuples, tuple) or not all(isinstance(t, tuple) for t in tuples):\n        raise ValueError(\"Input must be a tuple of tuples.\")\n    \n    # Calculate the average by summing all elements and dividing by the count\n    total = sum(sum(t) for t in tuples)\n    count = len(tuples)\n    return total / count\n\n# Example usage\n# Pass a tuple of tuples as input\ndata = ((1, 2), (3, 4), (5, 6))\nresult = average_tuple(data)\n\n# Print the result"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(t1, t2):\n    \"\"\"\n    Perform element-wise modulo operation on two tuples of the same length.\n    \n    Args:\n        t1, t2: Tuples of the same length.\n        \n    Returns:\n        Tuple with elements being the result of element-wise modulo operation.\n    \"\"\"\n    return tuple(a % b for a, b in zip(t1, t2))\n\n# Test the function\nassert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divide each element of list1 by the corresponding element in list2.\n    \n    :param list1: A list of numbers.\n    :param list2: A list of numbers.\n    :return: A new list where each element is the result of dividing the corresponding elements from list1 and list2.\n    \"\"\"\n    return [a / b if b != 0 else float('inf') for a, b in zip(list1, list2)]\n\n# Test the function\nassert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"}
{"task_id": "Mbpp/619", "solution": "def distinguish_numbers(input_string):\n    \"\"\"\n    Distinguishes between words and numbers in an input string.\n    \n    Args:\n    input_string (str): The input string to be analyzed.\n    \n    Returns:\n    list: A list containing only the numbers found in the input string.\n    \"\"\"\n    # Initialize an empty list to store numbers\n    numbers = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            # If it is, append it to the numbers list\n            numbers.append(char)\n    \n    return numbers\n\n# Example usage:\n# Test the function with some strings\ntest_strings = [\n    \"Hello world 123\",  # Expected output: [1, 2, 3]\n    \"I have 2 apples\",  # Expected output: [2]\n    \"No numbers here\",   # Expected output: []\n    \"45 apples 678\",    # Expected output: [4, 5, 6, 7, 8]\n]\n\n# Print results for each test string\nfor test in test_strings:\n    print(f\"Input: '{test}' -> Found Numbers: {distinguish_numbers(test)}\")"}
{"task_id": "Mbpp/620", "solution": "def find_largest_subset_divisibility_info():\n    # Initialize a dictionary to store divisibility information\n    divisibility_info = {}\n\n    # Example numbers to demonstrate the functionality\n    numbers = [2, 3, 5, 7, 11, 13]\n\n    # Populate the dictionary with divisibility information\n    for i in numbers:\n        for j in numbers:\n            if i % j == 0:\n                # If i is divisible by j, store j in the dictionary with i as the key\n                if j not in divisibility_info:\n                    divisibility_info[j] = []\n                divisibility_info[j].append(i)\n\n    # Function to find the largest subset based on divisibility info\n    def find_largest_subset(divisibility_info):\n        max_subset_size = 0\n        largest_subset = []\n\n        # Iterate through each key in the dictionary\n        for key in divisibility_info:\n            subset = divisibility_info[key]\n            subset_size = len(subset)\n\n            # Update the max_subset_size if the current subset size is larger\n            if subset_size > max_subset_size:\n                max_subset_size = subset_size\n                largest_subset = subset\n\n        return max_subset_size, largest_subset\n\n    # Find the largest subset size and the corresponding subset\n    max_size, largest_subset = find_largest_subset(divisibility_info)\n\n    return max_size, largest_subset\n\n# Example usage\nmax_size, largest_subset = find_largest_subset_divisibility_info()"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, size):\n    \"\"\"\n    Calculate the median of two lists of integers.\n\n    Parameters:\n    list1 (list): A list of integers.\n    list2 (list): Another list of integers.\n    size (int): The total number of elements to consider when calculating the median.\n\n    Returns:\n    float: The median of the combined lists after considering the first 'size' elements from each list.\n    \"\"\"\n    # Combine the two lists into one\n    combined_list = list1 + list2\n\n    # Sort the combined list\n    combined_list.sort()\n\n    # If the combined list length is odd, the median is the middle element\n    if len(combined_list) % 2 != 0:\n        return combined_list[size // 2]\n    # If the combined list length is even, the median is the average of the two middle elements\n    else:\n        return (combined_list[size // 2 - 1] + combined_list[size // 2]) / 2\n\n# Test the function\nlist1 = [1, 3, 5]\nlist2 = [2, 4, 6]\nsize = 3\n"}
{"task_id": "Mbpp/623", "solution": "def nth_power(base, exponent):\n    \"\"\"\n    Calculate the nth power of a number.\n    \n    Args:\n    base (int or float): The base number.\n    exponent (int): The power to which the base is raised.\n    \n    Returns:\n    int or float: The result of the base raised to the exponent.\n    \"\"\"\n    if not (isinstance(base, (int, float)) and isinstance(exponent, int)):\n        raise ValueError(\"Both base and exponent must be of type int or float.\")\n    \n    return base ** exponent\n\n# Testing the function with valid inputs"}
{"task_id": "Mbpp/624", "solution": "def to_uppercase(input_str):\n    \"\"\"\n    Converts a given string to uppercase.\n    \n    Args:\n    input_str (str): The string to convert to uppercase.\n    \n    Returns:\n    str: The input string converted to uppercase.\n    \"\"\"\n    return input_str.upper()\n\n# Test cases to ensure the function works correctly with valid strings\ntest_cases = [\n    (\"hello\", \"HELLO\"),\n    (\"Python\", \"PYTHON\"),\n    (\"[[]]\", \"[][]\"),  # This should handle the invalid input correctly\n    (\"world\", \"WORLD\"),\n    (\"123\", \"123\")\n]\n\n# Iterate through the test cases and print results\nfor input_str, expected_output in test_cases:\n    result = to_uppercase(input_str)\n    print(f\"Input: '{input_str}' -> Expected: '{expected_output}' -> Actual: '{result}'\")"}
{"task_id": "Mbpp/626", "solution": "import math\n\ndef largest_triangle_area_in_semicircle(radius):\n    # Handle negative radius\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    \n    # The largest triangle inscribed in a semicircle is a right triangle\n    # with the hypotenuse equal to the diameter of the semicircle\n    # and the legs equal to the radius of the semicircle\n    # The area of such a triangle is (1/2) * base * height = (1/2) * radius * radius\n    return 0.5 * radius * radius\n\n# Test cases"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    return string.replace(' ', '%20')\n\n# Test the function\nassert replace_spaces(\"My Name is Dawood\") == 'My%20Name%20is%20Dawood'"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a list containing only the even numbers.\n    \"\"\"\n    even_numbers = []\n    for num in numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers\n\n# Test the function with valid input"}
{"task_id": "Mbpp/630", "solution": "def get_adjacent_coordinates(x, y):\n    \"\"\"\n    This function returns a list of 8 adjacent coordinates around the given (x, y).\n    It considers the 8 possible offsets in both x and y directions.\n    \"\"\"\n    adjacent_coords = []\n    \n    # Move left\n    adjacent_coords.append((x - 1, y))\n    adjacent_coords.append((x - 1, y - 1))\n    \n    # Move right\n    adjacent_coords.append((x + 1, y))\n    adjacent_coords.append((x + 1, y - 1))\n    \n    # Move up\n    adjacent_coords.append((x, y - 1))\n    adjacent_coords.append((x + 1, y))\n    \n    # Move down\n    adjacent_coords.append((x - 1, y - 1))\n    adjacent_coords.append((x + 1, y + 1))\n    \n    return adjacent_coords\n\n# Example usage\nx, y = 3, 2\nadjacents = get_adjacent_coordinates(x, y)"}
{"task_id": "Mbpp/631", "solution": "def swap_spaces_and_underscores(s):\n    \"\"\"\n    Function to swap spaces with underscores and vice versa.\n    \"\"\"\n    # Replace spaces with underscores\n    s = s.replace(' ', '_')\n    \n    # Replace underscores with spaces\n    s = s.replace('_', ' ')\n    \n    return s\n\n# Test cases"}
{"task_id": "Mbpp/632", "solution": "def handle_non_zero_elements(original_list):\n    # Initialize an empty list to store non-zero elements\n    non_zero_elements = []\n    \n    # Iterate over the original list using a for loop\n    for element in original_list:\n        # Check if the element is non-zero\n        if element != 0:\n            # Append the element to the non_zero_elements list without modifying the original list\n            non_zero_elements.append(element)\n    \n    # Return the list of non-zero elements\n    return non_zero_elements\n\n# Example usage\noriginal_list = [1, 2, 0, 3, 4, 0]\nresult = handle_non_zero_elements(original_list)"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(a, b):\n    \"\"\"\n    Calculate the XOR of two numbers and return their sum.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    \n    Returns:\n    int: The sum of the XOR of the two numbers.\n    \"\"\"\n    xor_result = a ^ b  # Calculate XOR\n    return xor_result + b  # Return the sum\n\n# Test cases to validate the function\nassert pair_xor_Sum(3, 5) == 8, \"Test case 1 failed\"\nassert pair_xor_Sum(10, 7) == 17, \"Test case 2 failed\"\nassert pair_xor_Sum(0, 0) == 0, \"Test case 3 failed\"\n"}
{"task_id": "Mbpp/635", "solution": "def heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1     # left = 2*i + 1\n    r = 2 * i + 2     # right = 2*i + 2\n\n    # Check if left child of root exists and is greater than root\n    if l < n and arr[largest] < arr[l]:\n        largest = l\n\n    # Check if right child of root exists and is greater than root\n    if r < n and arr[largest] < arr[r]:\n        largest = r\n\n    # Change root, if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    # Extract elements from heap and append to sorted list\n    sorted_list = []\n    while len(sorted_list) < n:\n        sorted_list.append(arr[0])\n        arr[0] = arr[-1]  # Replace root with last item\n        heapify(arr, len(arr) - 1, 0)\n\n    return sorted_list\n\n# Test the heap sort function\ntest_data = [12, 11, 13, 5, 6, 7]\nsorted_list = heap_sort(test_data)"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(amount_spent, amount_earned):\n    \"\"\"\n    Check if the given amount spent and earned result in neither profit nor loss.\n    \n    Args:\n        amount_spent (int): The amount of money spent.\n        amount_earned (int): The amount of money earned.\n        \n    Returns:\n        bool: True if the amount spent equals the amount earned, False otherwise.\n    \"\"\"\n    return amount_spent == amount_earned\n\n# Test the function\nassert noprofit_noloss(1500, 1200) == False  # Expected False because 1500 != 1200\nassert noprofit_noloss(1000, 1000) == True   # Expected True because 1000 == 1000"}
{"task_id": "Mbpp/638", "solution": "def wind_chill_index(temp_celsius, wind_speed_mph):\n    # Convert temperature from Celsius to Kelvin\n    temp_kelvin = temp_celsius + 273.15\n    \n    # Wind chill formula adapted for Celsius\n    wind_chill_index = 13.12 + 0.6215 * temp_kelvin - 11.37 * wind_speed_mph**0.16\n    \n    return wind_chill_index\n\n# Test the function with some values\ntemp_celsius = 5  # Example temperature in Celsius\nwind_speed_mph = 10  # Example wind speed in miles per hour\n\n# Expected result for 5\u00b0C and 10 mph wind speed\nexpected_result = 0\n"}
{"task_id": "Mbpp/639", "solution": "def filter_names(names):\n    \"\"\"\n    Filter out names that start with an uppercase letter.\n\n    Args:\n        names (list): A list of strings representing names.\n\n    Returns:\n        list: A new list containing names that start with a lowercase letter.\n    \"\"\"\n    if not names:  # Check if the input list is empty\n        return []\n    else:\n        filtered_names = [name for name in names if name[0].islower()]\n        return filtered_names\n\n# Example usage:\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\"]\nfiltered_names = filter_names(names)"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Check if a number is a nonagonal number.\n    \n    A nonagonal number is a figurate number that extends the concept of triangular and square numbers to the nine-sided polygon (nonagon).\n    The nth nonagonal number is given by the formula: n(7n - 5) / 2.\n    \n    Args:\n        n (int): The position of the nonagonal number.\n        \n    Returns:\n        int: The nth nonagonal number.\n    \"\"\"\n    if n <= 0:\n        return 0  # Base case: 0th nonagonal number is 0\n    \n    return n * (7 * n - 5) // 2\n\n# Test cases\nassert is_nonagonal(10) == 325  # 10th nonagonal number should be 325"}
{"task_id": "Mbpp/643", "solution": "def check_z_position(word):\n    \"\"\"\n    Check if 'z' is not at the start or end of a word.\n    \n    Args:\n    word (str): The word to check.\n    \n    Returns:\n    bool: True if 'z' is not at the start or end of the word, False otherwise.\n    \"\"\"\n    # Split the word into characters to easily access each character's position\n    chars = list(word)\n    \n    # Check if 'z' is at position 0 (start) or at the last position\n    if chars[0] == 'z' or chars[-1] == 'z':\n        return False\n    \n    # If 'z' is neither at the start nor the end, return True\n    return True\n\n# Test cases"}
{"task_id": "Mbpp/644", "solution": "def reverse_array_up_to_k(arr, k):\n    \"\"\"\n    Reverses the array elements up to the specified position 'k'.\n    \n    Args:\n        arr (list): The input list.\n        k (int): The position up to which the array should be reversed.\n        \n    Returns:\n        list: The reversed array up to position 'k'.\n    \"\"\"\n    # If k is greater than the length of the array, return the original array\n    if k > len(arr):\n        return arr\n    \n    # Reverse the array from the second element to the end\n    reversed_part = arr[k:] + arr[:k-1][::-1]\n    \n    # Combine the first part (up to k-1) with the reversed part\n    return reversed_part\n\n# Test cases"}
{"task_id": "Mbpp/720", "solution": "def convert_dict_to_tuple_dict(input_dict):\n    \"\"\"\n    Convert a dictionary to a tuple where each key-value pair is represented as a tuple within a list.\n    \"\"\"\n    # Ensure the input is a dictionary\n    if not isinstance(input_dict, dict):\n        raise ValueError(\"Input must be a dictionary.\")\n    \n    # Convert the dictionary to a list of tuples\n    # Each tuple contains a key-value pair\n    tuple_list = list(input_dict.items())\n    \n    # Convert the list of tuples to a single tuple\n    result_tuple = tuple(tuple_list)\n    \n    return result_tuple\n\n# Example usage\nexample_dict = {\"name\": \"John\", \"age\": 30}"}
{"task_id": "Mbpp/721", "solution": "def navigate_matrix(matrix):\n    \"\"\"\n    Function to navigate through a matrix and print its elements correctly.\n    \n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix.\n    \n    Returns:\n    None\n    \"\"\"\n    # Initialize starting position\n    row, col = 0, 0\n    \n    # Nested while loop to navigate through the matrix\n    while row < len(matrix):\n        print(matrix[row][col])\n        # Update position based on movement direction (right or down)\n        if col < len(matrix[row]) - 1:\n            col += 1\n        else:\n            row += 1\n        # Ensure we don't go out of bounds\n        if row < len(matrix):\n            break\n\n# Example usage\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nnavigate_matrix(matrix)"}
{"task_id": "Mbpp/722", "solution": "def solve_problem(input_dict, a, b):\n    \"\"\"\n    This function takes a dictionary, and two floats as arguments.\n    It performs calculations based on the dictionary and returns the result.\n    \"\"\"\n    # Ensure the first argument is a dictionary\n    if not isinstance(input_dict, dict):\n        raise ValueError(\"The first argument must be a dictionary.\")\n    \n    # Ensure the second and third arguments are floats\n    if not isinstance(a, float) or not isinstance(b, float):\n        raise ValueError(\"The second and third arguments must be floats.\")\n    \n    # Perform calculations based on the dictionary\n    # Example logic: multiply 'a' by the value associated with 'key1' in the dictionary,\n    # then add 'b' to the result\n    result = a * input_dict.get('key1', 1) + b\n    \n    return result\n\n# Example usage:\n# Dictionary with 'key1' having a value of 2\ninput_dict = {'key1': 2}\n\n# Values to use for calculation\na = 3.5\nb = 4.2\n\n# Call the function with the correct arguments\nresult = solve_problem(input_dict, a, b)"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    Count the number of indices where the values in two lists are the same.\n    \n    :param list1: A list of integers.\n    :param list2: A list of integers of the same length as list1.\n    :return: The count of indices where list1[i] == list2[i] for all i in range(len(list1)).\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count\n\n# Test case\nassert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    # Calculate the base to the power\n    result = 1\n    for _ in range(power):\n        result *= base\n    \n    # Convert the result to a string to easily sum its digits\n    result_str = str(result)\n    \n    # Sum all the digits of the result\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum\n\n# Test the function with the provided example\nassert power_base_sum(2, 100) == 115"}
{"task_id": "Mbpp/725", "solution": "import re\n\ndef extract_quotation(text):\n    # Using regular expression to match and extract quoted text\n    # r'\\s*\"(.*?)\\s*\"' matches quoted text surrounded by whitespace or nothing\n    return re.findall(r'\\s*\"(.*?)\\s*', text)\n\n# Example usage:\ntext = \"Hello, \"world\"! How are you? I'm \"fine.\"\nquotations = extract_quotation(text)\n\n# Output: ['Hello, world!', 'How are you?', 'I\\'m fine.']"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(tup):\n    \"\"\"\n    Function to multiply consecutive elements in a tuple.\n    \n    Args:\n        tup (tuple): A tuple of numbers (t_1, ..., t_{N+1}).\n        \n    Returns:\n        tuple: A tuple of length N where the i-th element is t_i * t_{i+1}.\n    \"\"\"\n    result = []\n    for i in range(len(tup) - 1):\n        result.append(tup[i] * tup[i + 1])\n    return tuple(result)\n\n# Test case\nassert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)"}
{"task_id": "Mbpp/728", "solution": "def process_lists(lists):\n    \"\"\"\n    Processes multiple lists by performing an operation (e.g., concatenation, summing) on them.\n    \n    Args:\n        lists (list): A list of lists where each sublist represents a set of values to process.\n        \n    Returns:\n        list: The result of processing the provided lists.\n        \n    Raises:\n        ValueError: If any sublist is an empty list.\n    \"\"\"\n    result = []\n    for sublist in lists:\n        if not sublist:  # Check if the sublist is empty\n            raise ValueError(\"One or more sublists are empty.\")\n        result.extend(sublist)  # Extend the result list with the sublist\n    \n    return result\n\n# Example usage\ntry:\n    print(process_lists([[1, 2, 3], [4, 5], []]))  # Expected output: [1, 2, 3, 4, 5]\n    print(process_lists([[], [], []]))  # Raises ValueError: One or more sublists are empty.\nexcept ValueError as e:\n    print(e)"}
{"task_id": "Mbpp/730", "solution": "def remove_consecutive_duplicates(lst):\n    \"\"\"\n    Remove consecutive duplicates from a list while keeping distinct elements intact.\n    \n    Args:\n    lst (list): A list of elements.\n    \n    Returns:\n    list: A new list with consecutive duplicates removed.\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i - 1]:\n            result.append(lst[i])\n    return result\n\n# Test cases"}
{"task_id": "Mbpp/731", "solution": "import math\n\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone given the radius r and height h.\n\n    Args:\n        r (float): The radius of the base of the cone.\n        h (float): The height of the cone.\n\n    Returns:\n        float: The lateral surface area of the cone.\n    \"\"\"\n    # Formula for the lateral surface area of a cone: \u03c0 * r * l\n    # where l is the slant height, calculated as \u221a(r^2 + h^2)\n    slant_height = math.sqrt(r**2 + h**2)\n    lateral_surface_area = math.pi * r * slant_height\n    return lateral_surface_area\n\n# Test the function with the provided values\nassert lateralsurface_cone(5, 12) == 204.20352248333654"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \n    :param text: The string to be processed.\n    :return: The modified string with spaces, commas, or dots replaced by colons.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n\n# Test the function\nassert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, num):\n    \"\"\"\n    Finds the index of the first occurrence of a given number in a sorted array.\n\n    Args:\n        arr (list): A sorted list of integers.\n        num (int): The number to find in the array.\n\n    Returns:\n        int: The index of the first occurrence of the given number in the array, or -1 if the number is not found.\n    \"\"\"\n    try:\n        return arr.index(num)\n    except ValueError:\n        return -1\n\n# Test cases\nassert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\nassert find_first_occurrence([1, 3, 5, 7, 9], 5) == -1\nassert find_first_occurrence([1, 2, 3, 4, 5], 3) == 2\nassert find_first_occurrence([10, 20, 30, 40], 10) == 0"}
{"task_id": "Mbpp/734", "solution": "def sublist_product_sum(sublists):\n    \"\"\"\n    Calculate the sum of products of all possible sublists.\n\n    Args:\n    sublists (list): A list of lists where each inner list represents a sublist.\n\n    Returns:\n    int: The sum of products of all possible sublists.\n    \"\"\"\n    total_product = 0\n    for i in range(len(sublists)):\n        for j in range(i + 1, len(sublists) + 1):\n            sublist = sublists[i:j]\n            product = 1\n            for element in sublist:\n                product *= element\n            total_product += product\n    return total_product\n\n# Example usage:\nsublists = [[1, 2, 3], [4, 5], [6]]"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    # Convert the number to binary string\n    binary_str = bin(n)[2:]  # bin() returns '0bxxxxxx', so [2:] to remove '0b'\n    \n    # Find the length of the binary string\n    length = len(binary_str)\n    \n    # Check if the length is odd to determine the middle bit\n    if length % 2 == 1:\n        # The middle bit is the (length // 2) + 1 index\n        middle_index = (length // 2) + 1\n        # Toggle the middle bit (change 0 to 1 and 1 to 0)\n        binary_str[middle_index] = 1 - binary_str[middle_index]\n    else:\n        # If even, there is no single middle bit, so leave the binary string as is\n        pass\n    \n    # Return the modified binary string\n    return binary_str\n\n# Test cases"}
{"task_id": "Mbpp/736", "solution": "def insert_into_sorted_list(nums, val):\n    \"\"\"\n    Inserts a value into a sorted list at the correct position.\n\n    Args:\n        nums (list): A sorted list of integers.\n        val (int): The value to be inserted.\n\n    Returns:\n        list: The updated sorted list with the given value inserted at the correct position.\n    \"\"\"\n    # Edge case: if the list is empty\n    if not nums:\n        return [val]\n\n    # Find the insertion point\n    insertion_point = None\n    for i in range(len(nums)):\n        if nums[i] < val:\n            insertion_point = i + 1\n            break\n\n    # Insert the value at the correct position\n    nums.insert(insertion_point, val)\n\n    return nums\n\n# Testing the function with various inputs"}
{"task_id": "Mbpp/737", "solution": "import re\n\ndef check_string_starts_with_vowel(s):\n    # Define the pattern to match any vowel (case-insensitive)\n    pattern = r'^[aeiou]*'\n    \n    # Use re.match to check if the string starts with the vowel pattern\n    if re.match(pattern, s):\n        return True\n    else:\n        return False\n\n# Test cases"}
{"task_id": "Mbpp/739", "solution": "def find_smallest_triangular_with_n_digits(n):\n    # Initialize variables\n    triangular_number = 1\n    digit_count = 1\n    \n    # Loop to find the smallest triangular number with exactly n digits\n    while len(str(triangular_number)) > n:\n        triangular_number += 1\n        digit_count += 1\n    \n    return triangular_number\n\n# Test the function with some examples"}
{"task_id": "Mbpp/740", "solution": "def create_dict_from_tuple(tup):\n    \"\"\"\n    Create a dictionary from a tuple where each element becomes a key in the dictionary.\n    \"\"\"\n    # Adjusting the loop to include the last element\n    result_dict = {}\n    for i, item in enumerate(tup):\n        result_dict[item] = i  # Assigning the index to the corresponding item\n    return result_dict\n\n# Test the function\ntuple_test = (1, 'a', 3.0, 'b', 4)"}
{"task_id": "Mbpp/741", "solution": "def all_characters_same(s):\n    \"\"\"\n    Check if all characters in the string are the same.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    bool: True if all characters in the string are the same, False otherwise.\n    \"\"\"\n    # Check if the string length is 1\n    if len(s) == 1:\n        return True\n    \n    # Compare the first character with all other characters\n    return s[0] == s[1]\n\n# Test cases"}
{"task_id": "Mbpp/742", "solution": "import math\n\ndef calculate_tetrahedron_area(side_length):\n    \"\"\"\n    Calculate the area of a regular tetrahedron given the side length.\n\n    Args:\n        side_length (float): The length of a side of the tetrahedron.\n\n    Returns:\n        float: The area of the tetrahedron.\n    \"\"\"\n    # Correct formula for the area of a regular tetrahedron\n    area = (math.sqrt(2) / 4) * math.pow(side_length, 2)\n    return area\n\n# Test the function with a side length of 3\nside_length = 3\nexpected_area = 3 * math.sqrt(2) / 2  # Known area for a regular tetrahedron with side length 3\n\nassert calculate_tetrahedron_area(side_length) == expected_area, \"The function did not return the expected area.\"\n"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, k):\n    \"\"\"\n    Rotate a given list to the right by k positions.\n    \n    Args:\n        lst (list): The list to be rotated.\n        k (int): The number of positions to rotate to the right.\n        \n    Returns:\n        list: The rotated list.\n    \"\"\"\n    # Calculate the length of the list\n    n = len(lst)\n    \n    # If k is greater than the length of the list, rotate to the left\n    if k > n:\n        k = k % n\n    \n    # Rotate the list to the right\n    return lst[-k:] + lst[:-k]\n\n# Test the function\noriginal_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nk = 3\nrotated_list = rotate_right(original_list, k)"}
{"task_id": "Mbpp/744", "solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n    \n    Args:\n        tup (tuple): A tuple containing values.\n        \n    Returns:\n        bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    for value in tup:\n        if value is None:\n            return True\n    return False\n\n# Test cases\nassert check_none((10, 4, 5, 6, None)) == True\nassert check_none((10, 4, 5, 6)) == False\nassert check_none((None, 4, 5, 6)) == True\nassert check_none((10, 4, 5, 6, 7)) == False"}
{"task_id": "Mbpp/745", "solution": "def is_divisible_by_digits(n):\n    # Convert the number to a string to iterate over its digits\n    digits = str(n)\n    \n    # Initialize a flag to check if all digits divide the number\n    all_divisible = True\n    \n    # Iterate over each digit in the number\n    for digit in digits:\n        # Check if the digit divides the number evenly\n        if n % int(digit) != 0:\n            # If any digit does not divide the number evenly, set the flag to False\n            all_divisible = False\n            break\n    \n    # Return the result of the check\n    return all_divisible\n\n# Test cases to verify the correctness of the function"}
{"task_id": "Mbpp/748", "solution": "def safe_iter(words):\n    \"\"\"\n    Iterates over a list of words safely without modifying it during iteration.\n    \"\"\"\n    for index, word in enumerate(words, start=1):  # Start index at 1 to avoid 0-based indexing\n        # Perform operations on each word without modifying the original list\n        # For example, here we just print each word\n        print(f\"Word {index}: {word}\")\n\n# Test the function with a list of words\nwords = ['apple', 'banana', 'cherry']\nsafe_iter(words)"}
{"task_id": "Mbpp/749", "solution": "def sort_and_convert_to_ints(input_list):\n    # Filter out non-numeric strings and sort the numeric strings\n    sorted_numeric_strings = sorted([s for s in input_list if isinstance(s, str) and s.isdigit()])\n\n    # Convert the sorted numeric strings back to integers\n    sorted_integers = [int(s) for s in sorted_numeric_strings]\n\n    return sorted_integers\n\n# Example usage\ninput_list = ['abc', '34', '25', '678', '12', '90', '345']\nresult = sort_and_convert_to_ints(input_list)"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds a tuple to a list.\n    \n    Args:\n        lst (list): The original list.\n        tup (tuple): The tuple to be added.\n        \n    Returns:\n        list: The updated list with the tuple appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst\n\n# Test case\nassert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    # Updated loop range and comparison condition\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n\n# Example usage\narr = [3, 2, 1, 4, 5]"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_number(n):\n    # Initialize the first Jacobsthal number\n    a, b = 1, 1\n    \n    # Base case: Jacobsthal number for n = 0 is 0\n    if n == 0:\n        return 0\n    \n    # Loop from n to 1 to compute Jacobsthal numbers\n    for i in range(1, n + 1):\n        # Calculate the next Jacobsthal number using the correct formula\n        # J(n) = 2 * J(n-1) - J(n-2) with initial conditions J(0) = 0 and J(1) = 1\n        a, b = b, 2 * b - a\n    \n    return b\n\n# Test the function with a few values"}
{"task_id": "Mbpp/753", "solution": "def min_k_by_second(records, k):\n    \"\"\"\n    Finds the minimum k records based on the second element of each tuple.\n\n    :param records: A list of tuples, where each tuple contains two elements.\n    :param k: The number of records to find.\n    :return: A list of k tuples, representing the k minimum records based on the second element.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]\n\n# Example usage:\nrecords = [(3, 5), (1, 2), (4, 7), (2, 6), (5, 3)]\nk = 3\nresult = min_k_by_second(records, k)"}
{"task_id": "Mbpp/754", "solution": "def extract_common_index_list(l1, l2, l3):\n    # Initialize an empty list to store common indices\n    common_indices = []\n    \n    # Iterate over the length of the shortest list to ensure all lists are considered\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index in all three lists are equal\n        if l1[i] == l2[i] == l3[i]:\n            # If they are equal, append the index to the common_indices list\n            common_indices.append(i)\n    \n    return common_indices\n\n# Example usage:\nl1 = [1, 2, 3, 4]\nl2 = [3, 4, 5, 6]\nl3 = [4, 5, 6, 7]\n\n# Test the function with the example lists\ncommon_indices = extract_common_index_list(l1, l2, l3)"}
{"task_id": "Mbpp/755", "solution": "def process_list(input_list):\n    \"\"\"\n    Processes a list of items.\n    \n    Args:\n        input_list (list): A list of items to process.\n        \n    Returns:\n        list: The processed list.\n    \"\"\"\n    # Check if the input list is empty\n    if not input_list:\n        return []\n    \n    # Process each item in the list (example: multiply by 2)\n    processed_list = [item * 2 for item in input_list]\n    \n    return processed_list\n\n# Test cases"}
{"task_id": "Mbpp/757", "solution": "def find_reversed_pairs(lst):\n    # Initialize an empty list to store pairs of reversed strings\n    reversed_pairs = []\n\n    # Iterate over the list of strings\n    for i in range(len(lst)):\n        # Check if the i-th string is equal to its reverse\n        if lst[i] == lst[i][::-1]:\n            # If it is, append the pair to the list\n            reversed_pairs.append((lst[i], lst[i]))\n\n    # Return the list of pairs\n    return reversed_pairs\n\n# Example usage:\nstrings = [\"racecar\", \"madam\", \"level\", \"rotator\"]"}
{"task_id": "Mbpp/758", "solution": "# Correctly creating a list of tuples using enumeration\n\ndef create_tuple_list():\n    # Using enumeration to create a list of tuples\n    tuple_list = [(i, j) for i in range(5) for j in range(5)]\n    return tuple_list\n\n# Testing the function"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(number_str):\n    try:\n        float_number = float(number_str)\n        return str(float_number).replace('.', '') == '00'\n    except ValueError:\n        return False\n\n# Test cases\ntest_cases = [\n    \"123.11\",  # Expected: True\n    \"123.123\",  # Expected: False (exceeds 2 decimal places)\n    \".123\",     # Expected: False (not a whole number)\n    \"123\",      # Expected: False (no decimal part)\n    \"123.1\",    # Expected: True\n    \"123.11.1\"  # Expected: False (more than 2 decimal places)\n]\n\n# Iterate through test cases and print results\nfor case in test_cases:\n    print(f\"Input: '{case}' -> Expected: {is_decimal(case)} -> {is_decimal(case)}\")"}
{"task_id": "Mbpp/760", "solution": "def unique_Element(lst):\n    \"\"\"\n    Check if a list contains only one distinct element.\n    \n    Args:\n        lst (list): A list of numbers.\n        \n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if the length of the set is 1 (which means all elements are the same)\n    return len(unique_elements) == 1\n\n# Test cases"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    \"\"\"\n    Check if the given month number contains 30 days.\n    \n    Args:\n        month (int): The number representing the month (1-12).\n        \n    Returns:\n        bool: True if the month has 30 days, False otherwise.\n    \"\"\"\n    # Define the months with 30 days\n    thirty_days_months = [4, 6, 9, 11]\n    \n    # Check if the given month is in the list of thirty days months\n    return month in thirty_days_months\n\n# Test the function\nassert check_monthnumber_number(6) == True\nassert check_monthnumber_number(7) == False"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, K):\n    # Initialize minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate through the array\n    for i in range(len(arr)):\n        # Check if the difference between current element and next is less than or equal to K\n        if abs(arr[i] - arr[i + 1]) <= K:\n            # Update the minimum difference if the current difference is smaller\n            min_diff = min(min_diff, abs(arr[i] - arr[i + 1]))\n    \n    return min_diff\n\n# Example usage:\n# Test the function with an array and a difference value\narr = [1, 5, 9, 2, 7]\nK = 3"}
{"task_id": "Mbpp/764", "solution": "def count_digits_in_string(input_string):\n    \"\"\"Function to count the number of digits in an input string.\"\"\"\n    return len([char for char in input_string if char.isdigit()])\n\n# Test the function\nassert count_digits_in_string(\"12345\") == 5\nassert count_digits_in_string(\"abc123\") == 3\nassert count_digits_in_string(\"123\") == 3\nassert count_digits_in_string(\"abc\") == 0\n"}
{"task_id": "Mbpp/765", "solution": "def is_polite_number(n):\n    \"\"\"\n    Determines if a number is polite based on the definition:\n    A number is polite if it can be expressed as the sum of two or more consecutive positive integers.\n    \"\"\"\n    # Check if n is a non-negative integer\n    if not isinstance(n, int) or n < 0:\n        return False\n\n    # Initialize variables\n    sum_of_integers = 0\n    current_integer = 1\n\n    # Iterate to find if n can be expressed as the sum of consecutive integers\n    while sum_of_integers < n:\n        sum_of_integers += current_integer\n        current_integer += 1\n\n    # If the sum matches n, it's a polite number\n    if sum_of_integers == n:\n        return True\n    else:\n        return False\n\n# Test cases"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i + 1]))\n    return pairs\n\n# Test the function with the provided example\nassert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, sum):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] + numbers[j] == sum:\n                count += 1\n    return count\n\n# Test cases\nassert get_pairs_count([1, 1, 1, 1], 2) == 6\nassert get_pairs_count([2, 2, 3], 5) == 3\nassert get_pairs_count([1, 4, 7], 8) == 2\nassert get_pairs_count([5, 3], 8) == 0\n"}
{"task_id": "Mbpp/769", "solution": "def find_unique_elements(list1, list2):\n    # Check if both lists are empty\n    if not list1 and not list2:\n        return []\n    \n    unique_elements = []\n    for element in list1:\n        if element not in list2:\n            unique_elements.append(element)\n    \n    return unique_elements\n\n# Example usage\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5]\n"}
{"task_id": "Mbpp/770", "solution": "def sum_of_fourth_powers_of_odds(limit):\n    \"\"\"\n    Calculate the sum of the fourth powers of all odd numbers up to a given limit.\n    \n    Args:\n    limit (int): The upper limit for the range of numbers to consider.\n    \n    Returns:\n    int: The sum of the fourth powers of all odd numbers up to the given limit.\n    \"\"\"\n    sum = 0\n    for num in range(1, limit + 1, 2):  # Iterate over odd numbers\n        sum += num ** 4\n    return sum\n\n# Example usage:\n# Test the function with a specific limit\nlimit = 10\nresult = sum_of_fourth_powers_of_odds(limit)"}
{"task_id": "Mbpp/771", "solution": "def check_braces(string):\n    opening_braces = {'{': '}', '[': ']', '(': ')'}\n    closing_braces = {'}': '{', '}': '[', ']': '('}\n\n    stack = []\n    for char in string:\n        if char in opening_braces:\n            stack.append(char)\n        elif char in closing_braces:\n            if not stack or opening_braces[stack.pop()] != char:\n                return False\n    return len(stack) == 0\n\n# Test cases"}
{"task_id": "Mbpp/772", "solution": "def remove_length(text, k):\n    # Split the text into words\n    words = text.split()\n    \n    # Create a new list to store the words to keep\n    kept_words = []\n    \n    # Iterate through each word\n    for word in words:\n        # Check if the word's length is not equal to k\n        if len(word) != k:\n            kept_words.append(word)\n    \n    # Join the kept words back into a string\n    result = ' '.join(kept_words)\n    \n    return result\n\n# Test the function with the provided example\nassert remove_length('The person is most value tet', 3) == 'person is most value'"}
{"task_id": "Mbpp/773", "solution": "def find_substring(main_string, substring):\n    \"\"\"\n    Finds the position of a given substring within a main string.\n    \n    Parameters:\n    main_string (str): The main string in which to search for the substring.\n    substring (str): The substring to search for within the main string.\n    \n    Returns:\n    int: The position of the substring within the main string, or None if the substring is not found.\n    \"\"\"\n    # Convert both strings to lowercase for case-insensitive search\n    main_string = main_string.lower()\n    substring = substring.lower()\n\n    # Initialize position to -1 if substring is not found\n    position = -1\n\n    # Use the index method to find the starting position of the substring\n    start = main_string.index(substring)\n\n    # If the substring is found, update the position to the starting index\n    if start != -1:\n        position = start\n\n    return position\n\n# Test cases"}
{"task_id": "Mbpp/775", "solution": "def check_odd_occurrences(arr):\n    \"\"\"\n    Check if every odd index contains an odd number of occurrences.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if every odd index contains an odd number of occurrences, False otherwise.\n    \"\"\"\n    odd_indices_count = {i: arr[i] * (arr[i] > 0) for i in range(len(arr)) if i % 2 != 0}\n    \n    # Check if all values in the odd indices count dictionary are odd\n    return all(value % 2 != 0 for value in odd_indices_count.values())\n\n\n# Test cases\n# Edge case: An empty list\nassert check_odd_occurrences([]) == True, \"Test case 1 failed\"\n\n# Edge case: A list with only even indices\nassert check_odd_occurrences([1, 2, 3, 4, 5]) == True, \"Test case 2 failed\"\n\n# Edge case: A list with only one element at an odd index\nassert check_odd_occurrences([1, 2, 3]) == True, \"Test case 3 failed\"\n\n# Normal case: A list with a mix of odd and even indices\nassert check_odd_occurrences([1, 2, 3, 1, 2, 3, 1]) == True, \"Test case 4 failed\"\n\n# Negative case: A list with an even number of occurrences at an odd index\nassert check_odd_occurrences([1, 1, 2, 2]) == False, \"Test case 5 failed\"\n"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    # Create an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list\n    for element in lst:\n        # If the element is not in the set, add it\n        if element not in unique_elements:\n            unique_elements.add(element)\n    \n    # Return the sum of unique elements\n    return sum(unique_elements)\n\n# Test the function with the provided example\nassert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21"}
{"task_id": "Mbpp/778", "solution": "def group_consecutive_duplicates(lst):\n    \"\"\"\n    Groups consecutive duplicates in a list into sublists.\n    \n    :param lst: List of items.\n    :return: List of sublists containing consecutive duplicates.\n    \"\"\"\n    result = []\n    last_item = None\n    \n    for item in lst:\n        if last_item is None or item == last_item:\n            if last_item is not None:\n                result.append([last_item])\n            last_item = item\n        else:\n            result.append([item])\n    \n    return result\n\n# Test cases"}
{"task_id": "Mbpp/780", "solution": "from itertools import combinations\n\ndef sum_of_combinations(tuples):\n    \"\"\"\n    Calculate the sum of elements in all combinations of tuples.\n    \n    Parameters:\n    - tuples (list): A list of tuples.\n    \n    Returns:\n    - int: The sum of all elements in the combinations of tuples.\n    \"\"\"\n    total_sum = 0\n    for combo in combinations(tuples, 2):  # Considering pairs for simplicity, adjust as needed\n        # Each combo is a tuple of tuples, unpack it to sum its elements\n        total_sum += sum(element for pair in combo for element in pair)\n    return total_sum\n\n# Example usage:\ntuples = [(1, 2), (3, 4), (5, 6)]"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"Returns the count of divisors of the given number n.\"\"\"\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return len(divisors)\n\n# Test cases to verify the function"}
{"task_id": "Mbpp/782", "solution": "def sum_odd_length_subarrays(arr):\n    \"\"\"\n    Function to sum elements of subarrays with odd lengths in an array.\n    \n    Parameters:\n    arr (list): The input list of integers.\n    \n    Returns:\n    int: The sum of elements in subarrays with odd lengths.\n    \"\"\"\n    total_sum = 0\n    for i in range(len(arr)):\n        # Check if the length of the current subarray is odd\n        if len(arr[i:]) % 2 != 0:\n            # Calculate the sum of this subarray\n            subarray_sum = sum(arr[i:])\n            # Add to the total sum\n            total_sum += subarray_sum\n    return total_sum\n\n# Example usage:\n# arr = [1, 2, 3, 4, 5]\n# print(sum_odd_length_subarrays(arr))  # Output: 9 (1+2+5)\n\n# Test cases"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(numbers):\n    \"\"\"\n    Function to find the product of the first even and odd number in a given list.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The product of the first even and odd numbers in the list.\n    \"\"\"\n    if not numbers:\n        return None\n    \n    first_even = next((num for num in numbers if num % 2 == 0), None)\n    first_odd = next((num for num in numbers if num % 2 != 0), None)\n    \n    if first_even is None or first_odd is None:\n        return None\n    \n    return first_even * first_odd\n\n# Test cases\nassert mul_even_odd([1,3,5,7,4,1,6,8])==4\nassert mul_even_odd([2,4,6,8,10,12,14,16])==8\nassert mul_even_odd([1,1,1,1,5,5,5,5])==5\nassert mul_even_odd([]) == None"}
{"task_id": "Mbpp/785", "solution": "def split_and_convert_to_tuple(s):\n    # Split the string into a list of integers\n    int_list = [int(x) for x in s.split()]\n    \n    # Convert the list to a tuple\n    result_tuple = tuple(int_list)\n    \n    return result_tuple\n\n# Test the function\ninput_string = \"123 456 789\"\nexpected_output = (123, 456, 789)"}
{"task_id": "Mbpp/786", "solution": "def find_insertion_point(arr):\n    # Adjust the loop range to start from len(arr) - 2 down to 0\n    for i in range(len(arr) - 2, -1, -1):\n        if arr[i] == 42:  # Assuming we are looking for the index where 42 is present\n            return i  # Return the first index where 42 is found\n    return -1  # Return -1 if 42 is not found in the array\n\n# Example usage:\narr = [1, 23, 45, 67, 89, 42, 100]"}
{"task_id": "Mbpp/787", "solution": "def text_match_three(text):\n    \"\"\"\n    Check if a string contains 'abbb' starting from the first 'a'.\n    \"\"\"\n    return 'abbb' in text\n\n# Test cases\nassert not text_match_three(\"ac\"), \"Expected failure: 'abbb' not found in 'ac'\"\nassert text_match_three(\"abbab\") == True, \"Expected success: 'abbb' found in 'abbab'\"\nassert text_match_three(\"ababab\") == False, \"Expected failure: 'abbb' not found in 'ababab'\""}
{"task_id": "Mbpp/788", "solution": "def process_list_and_string(input_list, output_string):\n    \"\"\"\n    This function takes a list and a string as parameters.\n    It iterates over the list and appends each element to the string.\n    Finally, it returns the resulting string.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result_string = \"\"\n    \n    # Iterate over each element in the input list\n    for item in input_list:\n        # Append each item to the result string\n        result_string += str(item)\n    \n    # Return the final string\n    return result_string\n\n# Example usage:\n# List: [1, 2, 'three', 4.0]\n# String: \"\"\n# Expected output: \"123.0\"\n\n# Test the function\ninput_list = [1, 2, 'three', 4.0]\noutput_string = process_list_and_string(input_list, \"\")"}
{"task_id": "Mbpp/790", "solution": "def check_even_indices(lst):\n    \"\"\"\n    Check if all elements at even indices in the list are even numbers.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    bool: True if all elements at even indices are even, False otherwise.\n    \"\"\"\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if not (lst[i] % 2 == 0):  # Check if the number is even\n            return False\n    return True\n\n# Testing the function with different inputs\n# 1. Empty list"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(data, depth=0):\n    \"\"\"\n    Remove nested tuples from a list, handling non-tuple elements properly.\n    \n    Args:\n    data (list): The list to process.\n    depth (int, optional): The current depth in the recursion. Defaults to 0.\n    \n    Returns:\n    list: The list after removing nested tuples.\n    \"\"\"\n    result = []\n    for item in data:\n        if isinstance(item, tuple):\n            # Recursively handle nested tuples\n            new_item = remove_nested(item, depth + 1)\n            if new_item:  # Check if the recursion returned a non-empty list\n                result.append(new_item)\n        else:\n            # Add non-tuple elements directly to the result\n            result.append(item)\n    return result\n\n# Test cases to validate the function\n# Test with a simple list"}
{"task_id": "Mbpp/792", "solution": "def count_list(lst):\n    \"\"\"\n    Count the number of lists in a given list of lists.\n    \n    :param lst: A list containing nested lists.\n    :return: The count of lists in the provided list.\n    \"\"\"\n    count = 0\n    for item in lst:\n        if isinstance(item, list):\n            count += 1\n    return count\n\n# Test case\nassert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"}
{"task_id": "Mbpp/793", "solution": "def find_last_position(lst, element):\n    \"\"\"\n    Finds the last index of an element in a list.\n\n    Args:\n        lst (list): The list to search in.\n        element (any): The element to find in the list.\n\n    Returns:\n        int: The last index of the element in the list, or -1 if the element is not found.\n    \"\"\"\n    try:\n        return lst.rfind(element)\n    except ValueError:\n        return -1\n\n# Test cases"}
{"task_id": "Mbpp/794", "solution": "import re\n\ndef check_string_pattern(s):\n    # Regular expression pattern to match 'a' followed by any characters and ending with 'b'\n    pattern = r'^a.*b$'\n    \n    # Use re.match to check if the string matches the pattern\n    if re.match(pattern, s):\n        return True\n    else:\n        return False\n\n# Test cases"}
{"task_id": "Mbpp/796", "solution": "def sum_values_of_dict(d):\n    \"\"\"\n    Function to sum the values of a dictionary.\n    \n    Args:\n    d (dict): A dictionary with key-value pairs.\n    \n    Returns:\n    int: The sum of all values in the dictionary.\n    \"\"\"\n    total = 0\n    for value in d.values():\n        total += value\n    return total\n\n# Example usage:\n# dictionary_example = {'a': 1, 'b': 2, 'c': 3}\n# print(sum_values_of_dict(dictionary_example))  # Output: 6\n\n# Test cases\n# dictionary_with_zero_values = {'x': 0}\n# print(sum_values_of_dict(dictionary_with_zero_values))  # Output: 0\n\n# dictionary_with_negative_values = {'y': -1, 'z': -2}\n# print(sum_values_of_dict(dictionary_with_negative_values))  # Output: -3\n\n# dictionary_with_large_values = {'p': 1000000, 'q': 2000000}\n# print(sum_values_of_dict(dictionary_with_large_values))  # Output: 3000000"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    Calculate the sum of all odd natural numbers within the range l and r.\n    \n    :param l: The lower limit of the range.\n    :param r: The upper limit of the range.\n    :return: The sum of all odd natural numbers in the range [l, r].\n    \"\"\"\n    sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            sum += num\n    return sum\n\n# Test the function\nassert sum_in_range(2, 5) == 8"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"Return the sum of elements in the array.\"\"\"\n    return sum(arr)\n\n# Test case\nassert _sum([1, 2, 3]) == 6"}
{"task_id": "Mbpp/799", "solution": "def rotate_bits(n, k):\n    \"\"\"\n    Rotate the bits of the number n by k positions to the right.\n    \n    Parameters:\n    n (int): The number to rotate.\n    k (int): The number of positions to rotate by.\n    \n    Returns:\n    int: The rotated number.\n    \"\"\"\n    # Ensure k is within the valid range for bit rotation\n    if k < 0 or k > n:\n        raise ValueError(\"k must be between 0 and n-1 for bit rotation\")\n    \n    # Perform the rotation using bitwise operations\n    return (n << k) | (n >> (n - k))\n\n# Test cases"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')\n\n# Test case\nassert remove_all_spaces('python  program') == 'pythonprogram'"}
{"task_id": "Mbpp/801", "solution": "def count_equal_numbers(num1, num2, num3):\n    \"\"\"\n    This function counts the number of equal numbers among the three input integers.\n    \n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n        num3 (int): The third integer.\n        \n    Returns:\n        int: The count of equal numbers among num1, num2, and num3.\n    \"\"\"\n    count = 0\n    for i in [num1, num2, num3]:\n        if i == max(set([num1, num2, num3])):  # Find the maximum number\n            count += 1  # Increase the count if the current number equals the max\n    return count\n\n# Test cases"}
{"task_id": "Mbpp/803", "solution": "def is_perfect_square(n):\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root * root == n\n\n# Test cases\nassert not is_perfect_square(10), \"10 is not a perfect square\"\nassert is_perfect_square(4), \"4 is a perfect square\"\nassert not is_perfect_square(-9), \"Negative numbers are not perfect squares\"\nassert is_perfect_square(0), \"0 is a perfect square\""}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    Check if the product of numbers in a list is even.\n    \n    Args:\n        numbers (list): A list of integers.\n        \n    Returns:\n        bool: True if the product is even, False otherwise.\n    \"\"\"\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    return product % 2 == 0\n\n# Test cases\nassert is_product_even([1, 2, 3]) == False, \"Failed for [1, 2, 3]\"\nassert is_product_even([2, 4, 6]) == True, \"Failed for [2, 4, 6]\"\nassert is_product_even([1, 2]) == True, \"Failed for [1, 2]\"\nassert is_product_even([]) == False, \"Failed for an empty list\""}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lst):\n    \"\"\"\n    This function finds the list with the maximum sum of elements in a given list of lists.\n    \"\"\"\n    max_list = []  # Initialize max_list as an empty list\n    \n    # Iterate through each sub-list\n    for sub_list in lst:\n        # Calculate the sum of the current sub-list\n        sub_list_sum = sum(sub_list)\n        \n        # If the current sub-list sum is greater than the sum of max_list\n        if sub_list_sum > sum(max_list):\n            # Update max_list with the current sub-list\n            max_list = sub_list\n    \n    return max_list\n\n# Test cases to validate the function\ntest_cases = [\n    ([1, 2, 3], [4, 5, 6], [7, 8, 9]),  # Expected: [4, 5, 6]\n    ([1, 2], [3, 4], [5, 6]),  # Expected: [3, 4]\n    ([1], [], [2]),  # Expected: []\n    ([2], [1], [3]),  # Expected: [3]\n    ([1, 1, 1], [2, 2, 2], [3, 3, 3]),  # Expected: [2, 2, 2]\n]\n\nfor test in test_cases:\n    result = max_sum_list(test)\n    print(f\"Test case {test} passed: {result} vs expected {test}\")"}
{"task_id": "Mbpp/806", "solution": "def handle_inputs(input_list):\n    \"\"\"\n    This function takes a list of inputs and returns a list of processed outputs.\n    It handles both successful and failed inputs.\n    \"\"\"\n    processed_outputs = []\n    for input_data in input_list:\n        try:\n            # Example of a function that might fail for certain inputs\n            result = process_input(input_data)\n            if result is not None:\n                processed_outputs.append(result)\n        except Exception as e:\n            # Handle failed inputs by logging the error\n            print(f\"Error processing input: {input_data}. Error details: {str(e)}\")\n            processed_outputs.append(\"Failed to process input\")\n\n    return processed_outputs\n\ndef process_input(input_data):\n    \"\"\"\n    Placeholder for a function that might fail for certain inputs.\n    This function should be implemented based on the specific requirements.\n    \"\"\"\n    # Example of a function that might fail (e.g., division by zero)\n    try:\n        return input_data / 0  # This will raise a ZeroDivisionError\n    except ZeroDivisionError:\n        return None\n\n# Test cases to validate the function\ntest_cases = [\n    [1, 2, 3, 4],  # Expected: [0.5, 1.0, 1.5]\n    [\"hello\", \"world\"],  # Expected: [\"Failed to process input\"]\n    [None, 5, \"hello\"],  # Expected: [None, 5, \"Failed to process input\"]\n    [0, 0],  # Expected: [\"Failed to process input\"]\n]\n\nfor test in test_cases:\n    print(f\"Testing with input: {test}\")\n    result = handle_inputs(test)\n    print(f\"Expected: {test}, Got: {result}\")\n    assert result == test, f\"Expected {test} but got {result}\"\n    print(\"PASS\")"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    \"\"\"\n    Finds the first odd number in a given list of numbers.\n    \n    :param numbers: A list of numbers.\n    :return: The first odd number in the list, or None if there are no odd numbers.\n    \"\"\"\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None\n\n# Test cases\nassert first_odd([1, 3, 5]) == 1\nassert first_odd([2, 4, 6, 8]) == None\nassert first_odd([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 1"}
{"task_id": "Mbpp/808", "solution": "def process_tuples(tuples):\n    \"\"\"\n    This function processes a list of tuples.\n    It iterates over each tuple and performs some operation (e.g., summing elements).\n    \"\"\"\n    result = 0\n    for t in tuples:\n        result += t[0] * t[1]\n    return result\n\n# Example usage:\n# Incorrect input format (nested brackets)\n# Expected output: 6\n# Actual output: TypeError\n\n# Correct input format\ntest_cases = [(2, 3), (4, 5), (6, 7)]\n\n# Testing the function with correct input format\nfor t in test_cases:\n    print(f\"Processing tuple {t}: {process_tuples(t)}\")"}
{"task_id": "Mbpp/809", "solution": "def compare_tuples(t1, t2):\n    \"\"\"\n    Compare two tuples element-wise based on their positions.\n    \"\"\"\n    # Ensure both tuples have the same length\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must have the same length\")\n\n    # Compare elements position-wise\n    for i in range(len(t1)):\n        if t1[i] != t2[i]:\n            return False\n\n    return True\n\n# Test cases"}
