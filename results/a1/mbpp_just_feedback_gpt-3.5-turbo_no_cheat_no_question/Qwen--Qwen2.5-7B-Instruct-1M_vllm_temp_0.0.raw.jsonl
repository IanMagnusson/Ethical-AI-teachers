{"task_id": "Mbpp/2", "solution": "def similar_elements(tup1, tup2):\n    # Convert the tuples to sets and find the intersection\n    result = set(tup1) & set(tup2)\n    return result\n\n# Test the function with the provided test case\nassert similar_elements((3, 4, 5, 6), (5, 7, 4, 10)) == {4, 5}"}
{"task_id": "Mbpp/3", "solution": "def is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    \"\"\"\n    if n <= 1:\n        return True  # Mistakenly returning True for non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False  # Correctly identifying non-prime numbers\n    return True  # Correctly identifying prime numbers\n\n# Test cases to verify the correctness of the function\ntest_cases = [(10, True), (11, False), (13, True), (14, False), (15, True), (16, False), (17, True)]\nall_passed = True\nfor n, expected in test_cases:\n    result = is_prime(n)\n    if result != expected:\n        print(f\"Test failed for: {n}. Expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All test cases passed!\")"}
{"task_id": "Mbpp/4", "solution": "import heapq\n\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)\n\n# Test the function with the provided test case\nassert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(x, y):\n    # Calculate the XOR of x and y\n    xor = x ^ y\n    # Check if the result is a power of 2 (only one bit set)\n    return xor and not (xor & (xor - 1))\n\n# Test the function with the provided test case\nassert differ_At_One_Bit_Pos(13, 9) == True"}
{"task_id": "Mbpp/7", "solution": "def split_text(text):\n    \"\"\"\n    Splits the given text into words, ensuring that the text is not wrapped in\n    extra square brackets and double quotes before splitting.\n    \n    Example:\n    split_text('[\"This is\", \"a test.\"]') should return ['This is', 'a test.']\n    \"\"\"\n    # Remove any leading or trailing square brackets and double quotes\n    text = text.strip('[\"]')\n    # Split the text by spaces\n    words = text.split()\n    return words\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        ('[\"This is\", \"a test.\"]', ['This is', 'a test.']),\n        ('[\"Another\", \"example\"]', ['Another', 'example']),\n        ('[\"SingleWord\"]', ['SingleWord']),\n        ('[\"   Multiple   Words   \"]', ['Multiple', 'Words']),\n        ('[\"NoSpaces\"]', ['NoSpaces'])\n    ]\n    \n    all_passed = True\n    for text, expected in test_cases:\n        result = split_text(text)\n        if result != expected:\n            print(f\"Failed: {text} -> {result}, expected {expected}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Running the check function to validate the solution\ncheck()"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    # Use a list comprehension to square each element in the input list\n    return [i ** 2 for i in nums]\n\n# Test the function with the provided test case\nassert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "Mbpp/9", "solution": "def check_string_format(strings):\n    \"\"\"\n    Checks if the input strings are correctly formatted as individual strings inside a list.\n    \n    Parameters:\n    strings (list): A list of strings to be checked.\n    \n    Returns:\n    bool: True if all strings are correctly formatted, False otherwise.\n    \"\"\"\n    return all(isinstance(s, str) for s in strings)\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (['ab'], True),\n    (['hello', 'world'], True),\n    (['123'], True),\n    ([''], True),\n    (['ab', 123], False),  # Incorrect, because 123 is not a string\n    (['ab', 'cd', 'ef'], True),\n    ([''], True),\n    (['a'], True),\n    (['abc', 'def'], True),\n    (['123', '456'], True)\n]\n\ndef run_tests():\n    all_passed = True\n    for inputs, expected in test_cases:\n        result = check_string_format(inputs)\n        if result != expected:\n            print(f\"Test failed for input: {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the following line to run the tests\n# run_tests()"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    # Find the first occurrence of the character\n    first_occurrence = string.find(char)\n    # Find the last occurrence of the character\n    last_occurrence = string.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return string\n    \n    # Remove the first and last occurrence of the character\n    new_string = string[:first_occurrence] + string[first_occurrence+1:last_occurrence] + string[last_occurrence+1:]\n    \n    return new_string\n\n# Test the function with the provided test case\nassert remove_Occ(\"hello\", \"l\") == \"heo\""}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row in ascending order\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n\n# Test the function with the provided test case\nassert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(a, b, c):\n    # Calculate the area of the triangular base\n    base_area = (a * b) / 2\n    # Calculate the volume of the prism\n    volume = base_area * c\n    return volume\n\n# Test the function with the provided test case\nassert find_Volume(10, 8, 6) == 240"}
{"task_id": "Mbpp/16", "solution": "def is_valid_identifier(s):\n    \"\"\"\n    Checks if the input string s is a valid Python identifier.\n    A valid identifier starts with a letter (a-z or A-Z) or an underscore (_),\n    followed by any number of letters, digits (0-9), or underscores.\n    \n    Args:\n    s (str): The string to check.\n    \n    Returns:\n    bool: True if s is a valid identifier, False otherwise.\n    \"\"\"\n    if not s:\n        return False\n\n    if s[0].isalpha() or s[0] == '_':\n        for char in s[1:]:\n            if not (char.isalnum() or char == '_'):\n                return False\n        return True\n    return False\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"valid_identifier\", True),\n        (\"1_invalid\", False),\n        (\"_valid\", True),\n        (\"invalid-identifier\", False),\n        (\"\", False),\n        (\"valid123\", True),\n        (\"__hidden\", True),\n        (\"no_special#chars\", False)\n    ]\n    \n    all_passed = True\n    for identifier, expected in test_cases:\n        result = is_valid_identifier(identifier)\n        if result != expected:\n            print(f\"Failed for {identifier}: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Running the check function\ncheck()"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side):\n    # Calculate the perimeter of the square\n    perimeter = 4 * side\n    return perimeter\n\n# Test the function with the provided test case\nassert square_perimeter(10) == 40"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(s1, s2):\n    # Create a set of characters to be removed for faster lookup\n    chars_to_remove = set(s2)\n    # Use a list comprehension to filter out unwanted characters\n    result = [char for char in s1 if char not in chars_to_remove]\n    # Join the list back into a string and return\n    return ''.join(result)\n\n# Test the function with the provided test case\nassert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    # Check if the array contains any duplicate elements\n    return len(arr) != len(set(arr))\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"\n    Check if a number is a Woodall number.\n    \n    A Woodall number is of the form W(n) = n * 2^n - 1 for n >= 1.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    i = 1\n    while True:\n        woodall = i * (2 ** i) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        i += 1\n\n# Check function to verify the correctness of the generated function.\ndef check_woodall():\n    test_cases = [\n        (1, True),\n        (7, True),\n        (21, False),\n        (15, False),\n        (23, True),\n        (0, False),\n        (-5, False),\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = is_woodall(n)\n        if result != expected:\n            print(f\"Failed for {n}: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Call the check function to verify the results\ncheck_woodall()"}
{"task_id": "Mbpp/56", "solution": "def check(num):\n    # Calculate twice the reverse of the number and subtract 1\n    if num == 2 * int(str(num)[::-1]) - 1:\n        return True\n    else:\n        return False\n\n# Test the function with provided data points"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(nums):\n    # Convert each number in the list to a string\n    str_nums = list(map(str, nums))\n    # Sort the list of strings in reverse order (descending)\n    str_nums.sort(reverse=True)\n    # Join the sorted strings to form the largest number\n    largest_num = ''.join(str_nums)\n    # Convert the result back to an integer\n    return int(largest_num)\n\n# Test the function with the provided test case\nassert find_Max_Num([1, 2, 3]) == 321"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a, b):\n    # Check if the signs of a and b are opposite\n    return (a ^ b) < 0\n\n# Test the function with the provided test case\nassert opposite_Signs(1, -2) == True"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    # Calculate the nth octagonal number using the formula\n    return n * (3 * n - 2)\n\n# Test the function with the provided test case\nassert is_octagonal(5) == 65"}
{"task_id": "Mbpp/61", "solution": "def count_Substrings(S):\n    # Initialize the count of substrings\n    count = 0\n    # Iterate over all possible starting points of substrings\n    for start in range(len(S)):\n        sum_digits = 0\n        # Iterate over all possible ending points of substrings\n        for end in range(start, len(S)):\n            # Add the current digit to the sum\n            sum_digits += int(S[end])\n            # Check if the sum of digits is equal to the length of the substring\n            if sum_digits == end - start + 1:\n                count += 1\n    return count\n\n# Test the function with the provided test case\nassert count_Substrings('112112') == 6"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(lst):\n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/63", "solution": "def calculate_max_difference(input_data):\n    \"\"\"\n    Calculate the maximum difference between corresponding elements of two lists of tuples.\n    \n    Args:\n    input_data (list of tuples): A list of tuples where each tuple contains two integers.\n    \n    Returns:\n    int: The maximum difference between corresponding elements of the two lists.\n    \"\"\"\n    # Ensure the input is a list of tuples\n    if not all(isinstance(item, tuple) and len(item) == 2 for item in input_data):\n        raise ValueError(\"Input must be a list of tuples, each containing exactly two integers.\")\n    \n    # Calculate the maximum difference\n    max_diff = max(abs(a - b) for a, b in input_data)\n    return max_diff\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([(-1, 4), (3, 8), (5, 2)], 6),\n                  ([(-10, 10), (0, 0), (1, 1)], 20),\n                  ([(-5, 5), (0, 0), (5, 5)], 10)]\n    \n    all_passed = True\n    for input_data, expected in test_cases:\n        result = calculate_max_difference(input_data)\n        if result != expected:\n            print(f\"Test failed for input {input_data}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/64", "solution": "def subject_marks(test_list):\n    # Sort the list of tuples based on the second element of each tuple\n    test_list.sort(key=lambda x: x[1])\n    return test_list\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(data):\n    # Initialize sum to 0\n    total_sum = 0\n    # Iterate through each element in the list\n    for element in data:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # If it's a list, recursively call the function to sum its elements\n            total_sum += recursive_list_sum(element)\n        else:\n            # If it's not a list, add the element to the total sum\n            total_sum += element\n    return total_sum\n\n# Test the function with the provided test case\nassert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"}
{"task_id": "Mbpp/66", "solution": "def pos_count(lst):\n    # Initialize a counter to count positive numbers\n    count = 0\n    # Iterate through the list\n    for num in lst:\n        # Check if the current number is positive\n        if num > 0:\n            # Increment the counter if the number is positive\n            count += 1\n    return count\n\n# Test the function with the provided test case\nassert pos_count([1, -2, 3, -4]) == 2"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number.\n    \"\"\"\n    if n == 0:\n        return 1\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]\n\n# Test cases to verify the correctness of the function\ndef check_bell_number():\n    test_cases = [(0, 1), (1, 1), (2, 2), (3, 5), (4, 15), (5, 52)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = bell_number(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}.\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Run the test cases\ncheck_bell_number()"}
{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing\n\n# Test the function with the provided test case\nassert is_Monotonic([6, 5, 4, 4]) == True"}
{"task_id": "Mbpp/69", "solution": "def merge_sublists(lst):\n    \"\"\"\n    Merges sublists within a list, ensuring that the function handles edge cases such as empty lists or sublists,\n    and correctly manages scenarios where a sublist is longer than the original list.\n    \n    >>> merge_sublists([[1, 2], [3, 4], [5, 6]])\n    [1, 2, 3, 4, 5, 6]\n    >>> merge_sublists([[], [1, 2], [3, 4, 5]])\n    [1, 2, 3, 4, 5]\n    >>> merge_sublists([[1, 2, 3], [], [4, 5]])\n    [1, 2, 3, 4, 5]\n    >>> merge_sublists([])\n    []\n    \"\"\"\n    if not lst:  # Check if the main list is empty\n        return []\n    \n    merged_list = []\n    for sublist in lst:\n        if not sublist:  # Check if any sublist is empty\n            continue\n        merged_list.extend(sublist)  # Extend the main list with elements of the sublist\n    \n    return merged_list\n\n# Test cases to verify the correctness of the function\ndef check_solution():\n    test_cases = [([[], [1, 2], [3, 4, 5]], [1, 2, 3, 4, 5]),\n                  ([], []),\n                  ([[1, 2, 3], [], [4, 5]], [1, 2, 3, 4, 5]),\n                  ([[1, 2], [3, 4], [5, 6]], [1, 2, 3, 4, 5, 6])]\n    \n    all_passed = True\n    for i, (input_data, expected) in enumerate(test_cases):\n        result = merge_sublists(input_data)\n        if result != expected:\n            print(f\"Test case {i+1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/70", "solution": "def get_equal(test_list):\n    # Check if all tuples in the list have the same length\n    res = all(len(i) == len(test_list[0]) for i in test_list)\n    return res\n\n# Test cases to validate the function\nassert get_equal([(11, 22, 33), (44, 55, 66)]) == True\nassert get_equal([(1, 2), (3, 4), (5, 6)]) == True\nassert get_equal([(1, 2, 3), (4, 5, 6)]) == True\nassert get_equal([(1, 2), (3, 4, 5)]) == False"}
{"task_id": "Mbpp/71", "solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element.\n\n# Example usage:"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    # A number can be represented as the difference of two squares if and only if it is not of the form 4k+2\n    return n % 4 != 2\n\n# Test the function with the provided test case\nassert dif_Square(5) == True"}
{"task_id": "Mbpp/74", "solution": "def compare_patterns_to_sequences(patterns, sequences):\n    \"\"\"\n    Compares given patterns to sequences using two dictionaries.\n    \n    Args:\n    patterns (list of str): A list of patterns to compare.\n    sequences (list of str): A list of sequences to compare against patterns.\n    \n    Returns:\n    dict: A dictionary with pattern as key and a list of matching sequences as value.\n    \"\"\"\n    pattern_to_sequences = {}\n    for pattern in patterns:\n        pattern_to_sequences[pattern] = []\n    \n    for sequence in sequences:\n        for pattern in patterns:\n            if all(char in sequence for char in pattern):\n                pattern_to_sequences[pattern].append(sequence)\n    \n    return {k: v for k, v in pattern_to_sequences.items() if v}\n\n# Test cases to verify the solution\ndef check_solution():\n    patterns = ['abc', 'bcd', 'xyz']\n    sequences = ['abcd', 'bcde', 'xyz', 'hello', 'world']\n    expected_output = {\n        'abc': ['abcd'],\n        'bcd': ['bcde'],\n        'xyz': ['xyz']\n    }\n    \n    result = compare_patterns_to_sequences(patterns, sequences)\n    if result == expected_output:\n        print(\"Test passed.\")\n    else:\n        print(f\"Test failed. Expected {expected_output}, but got {result}\")\n\n# Run the test\ncheck_solution()"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples where all elements are divisible by K\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res\n\n# Test the function with the provided test case\nassert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"}
{"task_id": "Mbpp/77", "solution": "def is_Diff(n):\n    # Check if the number is divisible by 11\n    if n % 11 == 0:\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert is_Diff(12345) == False"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    # Check if the length of the word is odd\n    return len(word) % 2 != 0\n\n# Test the function with the provided test case\nassert word_len(\"Hadoop\") == False"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    # Calculate the nth tetrahedral number using the formula\n    return n * (n + 1) * (n + 2) // 6\n\n# Test the function with the provided test case\nassert tetrahedral_number(5) == 35"}
{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    # Calculate the volume of a sphere using the formula (4/3) * \u03c0 * r^3\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/84", "solution": "def newman_conway(n):\n    if n <= 0:\n        return None\n    elif n == 1:\n        return 1\n\n    # Initialize the sequence array with the first two elements\n    sequence = [0, 1]\n\n    # Compute the sequence up to the nth element\n    for i in range(2, n + 1):\n        sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n\n    return sequence[n]\n\n# Test the function with provided data points\ndef check():\n    test_cases = [(1, 1), (10, 6), (20, 10), (30, 18), (100, 56)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = newman_conway(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All tests passed!\")\n\ncheck()"}
{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    # Calculate the surface area of a sphere using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * radius ** 2\n    return surface_area\n\n# Test the function with the provided test case\nassert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    # Calculate the nth centered hexagonal number\n    return 3 * n * (n - 1) + 1\n\n# Test the function with the provided test case\nassert centered_hexagonal_number(10) == 271"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    # Merge the three dictionaries using the update method\n    result = dict1.copy()\n    result.update(dict2)\n    result.update(dict3)\n    return result\n\n# Test the function with the provided test case\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" }) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency_dict = {}\n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    # Return the dictionary containing the frequency of each element\n    return frequency_dict\n\n# Test the function with the provided test case\nassert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == ({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    # Subtract 1 from n to find the closest smaller number\n    return n - 1\n\n# Test the function with the provided test case\nassert closest_num(11) == 10"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    # Find the maximum length of the words in the list\n    max_length = max(len(word) for word in words)\n    return max_length\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/91", "solution": "def find_substring(test_list, test_str):\n    # Check if the test_str is a substring of any string in test_list\n    res = any(test_str in sub for sub in test_list)\n    return res\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(num):\n    # Check if the input is a non-integer\n    if not isinstance(num, int):\n        return False\n    \n    # Check if the number is negative\n    if num < 0:\n        return False\n    \n    # Convert the number to a string to easily check adjacent digits\n    num_str = str(num)\n    length = len(num_str)\n    \n    # An undulating number must have at least three digits\n    if length < 3:\n        return False\n    \n    # Check if the number is undulating\n    for i in range(1, length):\n        if num_str[i] == num_str[i-1]:\n            return False\n    \n    # Check if the number alternates between two digits\n    if num_str[0] == num_str[1] or num_str[-1] == num_str[-2]:\n        return False\n    \n    return True\n\n# Test cases to verify the correctness of the function"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    # Calculate a to the power of b\n    return a ** b\n\n# Test the function with the provided test case\nassert power(3, 4) == 81"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    res = min(test_list, key=lambda ele: ele[1])[0]\n    return res\n\n# Test the function with the provided test case\nassert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    # Find the minimum length among all the lists in the list of lists\n    min_length = min(len(sublist) for sublist in list_of_lists)\n    return min_length\n\n# Test the function with the provided test case\nassert Find_Min_Length([[1], [1, 2]]) == 1"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Iterate from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        # If i is a divisor of n\n        if n % i == 0:\n            # Increment the count\n            count += 1\n            # If i is not the square root of n, count the complementary divisor\n            if i != n // i:\n                count += 1\n    return count\n\n# Test the function with the provided test case\nassert divisor(15) == 4"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through each sublist in the given list of lists\n    for sublist in lists:\n        # Update the frequency dictionary with the elements from the current sublist\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n                \n    return frequency_dict\n\n# Test the function with the provided test case\nassert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}"}
{"task_id": "Mbpp/98", "solution": "def multiply_num(nums):\n    # Calculate the product of all numbers in the list\n    product = 1\n    for num in nums:\n        product *= num\n    # Divide the product by the length of the list\n    return product / len(nums)\n\n# Test the function with the provided test case\nassert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    \"\"\"\n    Converts a decimal number to a binary string without leading zeros.\n    Handles negative numbers and empty input.\n    \n    Args:\n    n (int or str): The decimal number to convert.\n    \n    Returns:\n    str: The binary representation of the input number as a string.\n    \"\"\"\n    if not isinstance(n, (int, str)):\n        raise ValueError(\"Input must be an integer or a string representing an integer.\")\n    \n    if isinstance(n, str):\n        n = int(n)\n    \n    if n == 0:\n        return \"0\"\n    \n    is_negative = n < 0\n    n = abs(n)\n    \n    binary_str = \"\"\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    \n    if is_negative:\n        return \"-\" + binary_str\n    else:\n        return binary_str\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (0, \"0\"),\n        (1, \"1\"),\n        (-1, \"-1\"),\n        (2, \"10\"),\n        (-2, \"-10\"),\n        (15, \"1111\"),\n        (-15, \"-1111\"),\n        (\"15\", \"1111\"),\n        (\"1024\", \"10000000000\"),\n        (\"-1024\", \"-10000000000\"),\n        (\"\", \"Input cannot be empty.\"),\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        try:\n            result = decimal_to_binary(n)\n            if result != expected:\n                print(f\"Test failed for input {n}. Expected {expected}, got {result}\")\n                all_passed = False\n        except ValueError as ve:\n            if expected != str(ve):\n                print(f\"Test failed for input {n}. Expected {expected}, got ValueError: {ve}\")\n                all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed.\")\n    else:\n        print(\"Some tests failed.\")\n\n# Uncomment the line below to run the check function\n# check()"}
{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    # Increment the number until a palindrome is found\n    while True:\n        n += 1\n        # Convert the number to a string and check if it reads the same forwards and backwards\n        if str(n) == str(n)[::-1]:\n            return n\n\n# Test the function with the provided test case\nassert next_smallest_palindrome(99) == 101"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    # Return the (k-1)th element of the array using 1-based indexing\n    return arr[k-1]\n\n# Test the function with the provided test case\nassert kth_element([12, 3, 5, 7, 19], 2) == 3"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    # Split the string by underscore and capitalize each word\n    # Then join them without any spaces\n    return ''.join(word.capitalize() or '_' for word in snake_str.split('_'))\n    \n# Test the function with the provided test case\nassert snake_to_camel('python_program') == 'PythonProgram'"}
{"task_id": "Mbpp/103", "solution": "def eulerian(n, m):\n    # Base case: if m is 0 or n-1, return 1\n    if m == 0 or m == n - 1:\n        return 1\n    # Recursive case: Eulerian number formula\n    return (n - m) * eulerian(n - 1, m - 1) + (m + 1) * eulerian(n - 1, m)\n\n# Check function to verify the correctness of the generated function\ndef check_eulerian():\n    test_cases = [\n        (5, 0, 1),\n        (5, 1, 4),\n        (5, 2, 11),\n        (5, 3, 6),\n        (5, 4, 1),\n    ]\n    \n    all_passed = True\n    for n, m, expected in test_cases:\n        result = eulerian(n, m)\n        if result != expected:\n            print(f\"Test failed for eulerian({n}, {m}). Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the following line to run the check function\n# check_eulerian()"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(list_of_lists):\n    # Use list comprehension to sort each sublist in the given list of lists\n    sorted_list = [sorted(sublist) for sublist in list_of_lists]\n    return sorted_list\n\n# Test the function with the provided test case\nassert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"])) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"}
{"task_id": "Mbpp/105", "solution": "def count(test_list):\n    # Count the number of True booleans in the list\n    count = sum(test_list)\n    return count\n\n# Test the function with the provided test case\nassert count([True, False, True]) == 2"}
{"task_id": "Mbpp/106", "solution": "def append_to_tuple(element, original_tuple):\n    \"\"\"\n    Appends an element to a given tuple and returns a new tuple with the element added.\n    \n    Parameters:\n    - element: The element to be added to the tuple.\n    - original_tuple: The original tuple to which the element will be appended.\n    \n    Returns:\n    A new tuple with the element added to the end of the original tuple.\n    \"\"\"\n    # Convert the tuple to a list to enable modification\n    temp_list = list(original_tuple)\n    # Append the element to the list\n    temp_list.append(element)\n    # Convert the list back to a tuple\n    new_tuple = tuple(temp_list)\n    return new_tuple\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [((1, 2, 3), 4, (1, 2, 3, 4)),\n                  ((5, 6), 7, (5, 6, 7)),\n                  ((8,), 9, (8, 9))]\n    \n    all_passed = True\n    for original_tuple, element, expected in test_cases:\n        result = append_to_tuple(element, original_tuple)\n        if result != expected:\n            print(f\"Test failed for: {original_tuple}, {element}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list\n\n# Test the function with the provided test case\nassert merge_sorted_list([25, 24, 15, 4, 5, 29, 110], [19, 20, 11, 56, 25, 233, 154], [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"}
{"task_id": "Mbpp/109", "solution": "def count_odd_rotations(binary_str):\n    \"\"\"\n    Counts the number of binary strings that can be obtained by rotating the given binary string\n    such that the count of numbers with an odd value is odd.\n    \n    :param binary_str: A binary string consisting of '0's and '1's.\n    :return: The count of binary strings with an odd value after rotation.\n    \"\"\"\n    # Count the number of '1's in the binary string\n    ones_count = binary_str.count('1')\n    \n    # If the count of '1's is odd, then all rotations will have an odd value\n    if ones_count % 2 == 1:\n        return len(binary_str)\n    else:\n        # If the count of '1's is even, then no rotation will have an odd value\n        return 0\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"101\", 3),  # All rotations have an odd value\n        (\"100\", 0),  # No rotation has an odd value\n        (\"111\", 3),  # All rotations have an odd value\n        (\"000\", 0),  # No rotation has an odd value\n    ]\n    \n    all_passed = True\n    for binary_str, expected in test_cases:\n        result = count_odd_rotations(binary_str)\n        if result != expected:\n            print(f\"Test failed for input {binary_str}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the common elements with the first list's elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the nested lists starting from the second list\n    for lst in nested_lists[1:]:\n        # Update the common elements to only include elements present in the current list\n        common_elements.intersection_update(lst)\n    \n    # Return the set of common elements\n    return common_elements\n\n# Test the function with the provided test case\nassert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])"}
{"task_id": "Mbpp/113", "solution": "def convert_to_ints(nested_list):\n    \"\"\"\n    Converts a nested list of strings representing integers into a flat list of integers.\n    Handles edge cases like empty lists and lists containing empty strings.\n    \n    :param nested_list: List of lists containing string representations of integers.\n    :return: A flat list of integers.\n    \"\"\"\n    result = []\n    for sublist in nested_list:\n        for item in sublist:\n            if item:  # Check if the string is not empty\n                try:\n                    result.append(int(item))\n                except ValueError:\n                    print(f\"Warning: '{item}' is not a valid integer and will be ignored.\")\n    return result\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    ([['1', '2', '3'], ['4', '5', '6']], [1, 2, 3, 4, 5, 6]),\n    ([['10', '20', '30'], ['40', '50', '60']], [10, 20, 30, 40, 50, 60]),\n    ([[''], ['']], [], \"Should handle empty strings and return an empty list.\"),\n    ([[''], ['']], [], \"Another test case for empty strings.\"),\n    ([['1'], [''], ['2']], [1, 2], \"Should ignore empty strings and convert valid integers.\"),\n    ([[''], ['']], [], \"Test case for a list containing only empty strings.\")\n]\n\nall_passed = True\nfor i, (input_data, expected) in enumerate(test_cases):\n    result = convert_to_ints(input_data)\n    if result != expected:\n        print(f\"Test case {i+1} failed: expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All test cases passed!\")"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(nums):\n    # Convert each element in the tuple to a string and join them together\n    str_nums = ''.join(str(num) for num in nums)\n    # Convert the resulting string to an integer\n    return int(str_nums)\n\n# Test the function with the provided test case\nassert tuple_to_int((1, 2, 3)) == 123"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(str1):\n    # Split the string on spaces and return the list of words\n    return str1.split(' ')\n    \n# Test the function with the provided test case\nassert string_to_list(\"python programming\") == ['python', 'programming']"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    # Initialize the result variable\n    result = 0\n    \n    # Iterate through the array\n    for num in arr:\n        # XOR each element with the result\n        result ^= num\n    \n    # Return the result which is the element that appears only once\n    return result\n\n# Test the function with the provided test case\nassert search([1, 1, 2, 2, 3]) == 3"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(test_list):\n    # Calculate the absolute product for each tuple and return the maximum value\n    res = max(abs(a * b) for a, b in test_list)\n    return res\n\n# Test the function with the provided test case\nassert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"}
{"task_id": "Mbpp/123", "solution": "def find_amicable_numbers(limit):\n    \"\"\"\n    Finds all amicable numbers below the given limit.\n    \n    An amicable pair (a, b) consists of two different numbers where the sum of proper divisors\n    of one number equals the other number, and vice versa.\n    \n    Args:\n    limit (int): The upper limit for finding amicable numbers.\n    \n    Returns:\n    list: A list of amicable numbers below the given limit.\n    \"\"\"\n    def sum_of_divisors(n):\n        return sum(i for i in range(1, n) if n % i == 0)\n    \n    amicable_numbers = []\n    for num in range(2, limit):\n        div_sum = sum_of_divisors(num)\n        if div_sum > num and sum_of_divisors(div_sum) == num:\n            amicable_numbers.append(num)\n    \n    return amicable_numbers\n\n# Check function to verify the correctness of the solution\ndef check_amicable_numbers():\n    test_cases = [\n        (500, [220, 284]),\n        (10000, [220, 284, 1184, 1210, 2620, 2924, 5020, 5564, 6232, 6368]),\n    ]\n    \n    all_passed = True\n    for limit, expected in test_cases:\n        result = find_amicable_numbers(limit)\n        if sorted(result) != sorted(expected):\n            print(f\"Failed for limit {limit}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Uncomment the line below to run the check function\n# check_amicable_numbers()"}
{"task_id": "Mbpp/124", "solution": "def calculate_modulus(complex_number):\n    \"\"\"\n    Calculate the modulus of a complex number.\n    \n    Args:\n    complex_number (complex): A complex number in Python's complex number format.\n    \n    Returns:\n    float: The modulus of the complex number.\n    \"\"\"\n    return abs(complex_number)\n\n# Test cases to verify the solution\ndef check_solution():\n    test_cases = [\n        (1 + 1j, 1.4142135623730951),  # Example test case\n        (3 - 4j, 5.0),\n        (0 + 0j, 0.0),\n        (-1 - 1j, 1.4142135623730951)\n    ]\n    \n    all_passed = True\n    for complex_num, expected in test_cases:\n        result = calculate_modulus(complex_num)\n        if not math.isclose(result, expected, rel_tol=1e-9):\n            print(f\"Test failed for: {complex_num}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Importing math for the isclose function\nimport math\n\n# Running the check function to validate the solution\ncheck_solution()"}
{"task_id": "Mbpp/125", "solution": "def find_max_consecutive_ones(nums):\n    \"\"\"\n    Given a binary string, find the maximum number of consecutive 1's in the string.\n    \n    Example:\n    >>> find_max_consecutive_ones(\"11011101111\")\n    4\n    \"\"\"\n    max_count = 0\n    current_count = 0\n    \n    for bit in nums:\n        if bit == '1':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n            \n    return max_count\n\n# Test cases to verify the correctness of the function"}
{"task_id": "Mbpp/126", "solution": "def sum_of_gcds(numbers):\n    \"\"\"\n    Calculate the sum of the greatest common divisors (GCD) of all unique pairs in the list.\n    \n    :param numbers: List of integers\n    :return: Sum of GCDs of all unique pairs\n    \"\"\"\n    from math import gcd\n    from itertools import combinations\n    \n    # Calculate GCD for each unique pair and sum them up\n    return sum(gcd(a, b) for a, b in combinations(numbers, 2))\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([2, 4, 3, 5, 6], 14), ([10, 20, 30], 31), ([1, 2, 3, 4, 5], 10)]\n    \n    all_passed = True\n    for numbers, expected in test_cases:\n        result = sum_of_gcds(numbers)\n        if result != expected:\n            print(f\"Failed for {numbers}. Expected {expected}, got {result}.\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some test cases failed.\")\n\n# Call the check function to verify the solution\ncheck()"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(x, y):\n    # Multiply two integers and return the result\n    return x * y\n\n# Test the function with the provided test case\nassert multiply_int(10, 20) == 200"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, string):\n    # Split the string into words\n    words = string.split(\" \")\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result\n\n# Test the function with the provided test case\nassert long_words(3, \"python is a programming language\") == ['python', 'programming', 'language']"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # Increment the count of the item in the dictionary\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n    \n    return max_item\n\n# Test the function with the provided test case\nassert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == 2"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(text):\n    # Define vowels\n    vowels = \"aeiouAEIOU\"\n    # Convert text to a list for easy manipulation\n    text_list = list(text)\n    # Initialize two pointers\n    left, right = 0, len(text_list) - 1\n    \n    # Traverse the string with two pointers\n    while left < right:\n        # Move the left pointer until a vowel is found\n        if text_list[left] not in vowels:\n            left += 1\n        # Move the right pointer until a vowel is found\n        elif text_list[right] not in vowels:\n            right -= 1\n        # Swap the vowels\n        else:\n            text_list[left], text_list[right] = text_list[right], text_list[left]\n            left += 1\n            right -= 1\n    \n    # Convert the list back to a string\n    return ''.join(text_list)\n\n# Test the function with the provided test case\nassert reverse_vowels(\"Python\") == \"Python\""}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    # Join the elements of the tuple into a single string\n    result = ''.join(tup)\n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(nums):\n    # Initialize sum to 0\n    sum = 0\n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            # Add the negative number to the sum\n            sum += num\n    return sum\n\n# Test the function with the provided test case\nassert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    # Calculate the nth hexagonal number using the formula\n    return n * (2 * n - 1)\n\n# Test the function with the provided test case\nassert hexagonal_num(10) == 190"}
{"task_id": "Mbpp/137", "solution": "def calculate_average(numbers):\n    \"\"\"\n    Calculate the average of a list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers (integers or floats).\n    \n    Returns:\n    float: The average of the numbers in the list.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    \n    return sum(numbers) / len(numbers)\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        ([1, 2, 3, 4, 5], 3.0),\n        ([10, 20, 30, 40, 50], 30.0),\n        ([], None),  # This case will raise a ValueError\n    ]\n    \n    all_passed = True\n    for numbers, expected in test_cases:\n        try:\n            result = calculate_average(numbers)\n            if result != expected:\n                print(f\"Test failed for input {numbers}. Expected {expected}, got {result}\")\n                all_passed = False\n        except ValueError as e:\n            if expected is None:\n                print(f\"Correctly raised ValueError for input {numbers}: {e}\")\n            else:\n                print(f\"Unexpected ValueError for input {numbers}: {e}\")\n                all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/138", "solution": "def can_be_sum_of_powers_of_two(n):\n    \"\"\"\n    Check if the given number can be represented as a sum of non-zero powers of 2.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number can be represented as a sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0 and n != 1:\n            return False\n        n = n // 2\n    return True\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [\n        (5, True),  # 5 = 4 + 1 (2^2 + 2^0)\n        (0, False), # 0 cannot be represented as a sum of non-zero powers of 2\n        (1, True),  # 1 = 2^0\n        (2, True),  # 2 = 2^1\n        (3, True),  # 3 = 2^1 + 2^0\n        (4, True),  # 4 = 2^2\n        (6, True),  # 6 = 4 + 2 (2^2 + 2^1)\n        (7, True),  # 7 = 4 + 2 + 1 (2^2 + 2^1 + 2^0)\n        (8, True),  # 8 = 2^3\n        (9, True),  # 9 = 8 + 1 (2^3 + 2^0)\n        (10, True), # 10 = 8 + 2 (2^3 + 2^1)\n        (11, True), # 11 = 8 + 2 + 1 (2^3 + 2^1 + 2^0)\n        (12, True), # 12 = 8 + 4 (2^3 + 2^2)\n        (13, True), # 13 = 8 + 4 + 1 (2^3 + 2^2 + 2^0)\n        (14, True), # 14 = 8 + 4 + 2 (2^3 + 2^2 + 2^1)\n        (15, True), # 15 = 8 + 4 + 2 + 1 (2^3 + 2^2 + 2^1 + 2^0)\n        (16, True), # 16 = 2^4\n        (17, True), # 17 = 16 + 1 (2^4 + 2^0)\n        (18, True), # 18 = 16 + 2 (2^4 + 2^1)\n        (19, True), # 19 = 16 + 2 + 1 (2^4 + 2^1 + 2^0)\n        (20, True), # 20 = 16 + 4 (2^4 + 2^2)\n        (21, True), # 21 = 16 + 4 + 1 (2^4 + 2^2 + 2^0)\n        (22, True), # 22 = 16 + 4 + 2 (2^4 + "}
{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    # Calculate the circumference of a circle given its radius\n    return 2 * math.pi * radius\n\n# Test the function with the provided test case\nassert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples and convert it to a set to remove duplicates\n    return set([item for sublist in list_of_tuples for item in sublist])\n\n# Test the function with the provided test case\nassert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == set([3, 4, 5, 7, 1])"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    # Iterate over the array from the end to the beginning\n    for cur_size in range(len(arr), 1, -1):\n        # Find the index of the maximum element in the current subarray\n        max_pos = 0\n        for i in range(cur_size):\n            if arr[i] > arr[max_pos]:\n                max_pos = i\n        # If the maximum element is not at the current position, flip it to the front\n        if max_pos != cur_size - 1:\n            # Flip the element to the front\n            arr[:max_pos + 1] = reversed(arr[:max_pos + 1])\n            # Flip the element to its correct position\n            arr[:cur_size] = reversed(arr[:cur_size])\n    return arr\n\n# Test the function with the provided test case\nassert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    # Initialize a counter for the matching elements\n    count = 0\n    # Iterate through the lists using zip to compare elements at the same position\n    for a, b, c in zip(list1, list2, list3):\n        # Increment the counter if elements in all three lists are the same\n        if a == b == c:\n            count += 1\n    return count\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    # Calculate the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Return the absolute difference between the max and min values\n    return abs(max_val - min_val)\n\n# Test the function with the provided test case\nassert max_Abs_Diff((2, 1, 5, 3)) == 4"}
{"task_id": "Mbpp/160", "solution": "def extended_gcd(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm to find the GCD of a and b.\n    Returns a tuple (gcd, x, y) such that ax + by = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)\n\ndef find_modular_inverse(a, n):\n    \"\"\"\n    Find the modular inverse of a under modulo n using the extended Euclidean algorithm.\n    Returns the modular inverse of a under modulo n if it exists, otherwise returns None.\n    \"\"\"\n    gcd, x, _ = extended_gcd(a, n)\n    if gcd != 1:\n        return None  # Modular inverse does not exist if a and n are not coprime\n    else:\n        return x % n\n\n# Example usage:"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(original_list, elements_to_remove):\n    # Use a list comprehension to filter out elements that are in the elements_to_remove list\n    result = [element for element in original_list if element not in elements_to_remove]\n    return result\n\n# Test the function with the provided test case\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    # Calculate the sum of the series (n - 2*i) from i=0 to n // 2\n    return sum(n - 2 * i for i in range(n // 2 + 1))\n\n# Test the function with the provided test case\nassert sum_series(6) == 12"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    # Initialize the count to 0\n    count = 0\n    # Iterate over the string with index\n    for index, char in enumerate(s):\n        # Convert character to lowercase and check if it matches the position\n        if char.lower() == chr(ord('a') + index):\n            count += 1\n    return count\n\n# Test the function with the provided test case\nassert count_char_position(\"xbcefg\") == 2"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    # Initialize the count of even pairs to 0\n    count = 0\n    # Iterate through each pair of integers in the list\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if the XOR of the pair results in an even number\n            if ((nums[i] ^ nums[j]) % 2 == 0):\n                count += 1\n    return count\n\n# Test the function with the provided test case\nassert find_even_pair([5, 4, 7, 2, 1]) == 4"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    # If n is 0, the next power of 2 is 1\n    if n == 0:\n        return 1\n    # If n is already a power of 2, return n itself\n    if (n & (n - 1)) == 0:\n        return n\n    # Otherwise, find the next power of 2\n    power = 1\n    while power < n:\n        power <<= 1\n    return power\n\n# Test the function with the provided test case\nassert next_power_of_2(0) == 1"}
{"task_id": "Mbpp/168", "solution": "def frequency(arr, num):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through the list to count occurrences of num\n    for n in arr:\n        if n == num:\n            count += 1\n    return count\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of the specified slice of the list\n    return sum(nums[start:end+1])\n\n# Test the function with the provided test case\nassert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10) == 29"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    # Calculate the perimeter of a regular pentagon\n    perimeter = 5 * side_length\n    return perimeter\n\n# Test the function to ensure it works as expected\nassert perimeter_pentagon(5) == 25"}
{"task_id": "Mbpp/172", "solution": "def count_occurance(str1):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through the string to find occurrences of 'std'\n    for i in range(len(str1) - 2):\n        # Check if the substring from current position to current position + 3 is 'std'\n        if str1[i:i+3] == 'std':\n            count += 1\n    return count\n\n# Test the function with the provided test case\nassert count_occurance(\"letstdlenstdporstd\") == 3"}
{"task_id": "Mbpp/222", "solution": "def check_type(test_tuple):\n    # Extract the type of the first element in the tuple\n    first_type = type(test_tuple[0])\n    # Check if all elements in the tuple have the same type as the first element\n    return all(isinstance(element, first_type) for element in test_tuple)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, x):\n    # Count occurrences of x in the array\n    count = arr.count(x)\n    # Check if x occurs more than n/2 times\n    return count > n // 2\n\n# Test cases to validate the function\ndef check_function():\n    test_cases = [([1, 2, 3, 3, 3, 3, 4, 5], 8, 3), ([1, 1, 2, 3, 3], 5, 3), ([5, 5, 5, 5, 5, 5], 6, 5)]\n    all_passed = True\n    for arr, n, x in test_cases:\n        if not is_majority(arr, n, x):\n            print(f\"Test failed for array: {arr}, element: {x}\")\n            all_passed = False\n    if all_passed:\n        print(\"All tests passed!\")\n\n# Run the check function to validate the is_majority function\ncheck_function()"}
{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    # Initialize count of set bits to 0\n    count = 0\n    # Loop until n becomes 0\n    while n:\n        # Increment count if the least significant bit is 1\n        count += n & 1\n        # Right shift n by 1 to check the next bit\n        n >>= 1\n    return count\n\n# Test the function with the provided test case\nassert count_Set_Bits(2) == 1"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate through the string, considering only characters at even indices\n    for i in range(0, len(s), 2):\n        result += s[i]\n    return result\n\n# Test the function with the provided test case\nassert odd_values_string('abcdef') == 'ace'"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    # Return the minimum of the three numbers\n    return min(a, b, c)\n\n# Test the function with the provided test case\nassert min_of_three(10, 20, 0) == 0"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(str1, ch):\n    # Replace spaces in the string with the specified character\n    result = str1.replace(' ', ch)\n    return result\n\n# Test the function with the provided test case\nassert replace_blank(\"hello people\", '@') == \"hello@people\""}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    # Sort the list in descending order and slice the first n elements\n    return sorted(lst, reverse=True)[:n]\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/233", "solution": "import math\n\ndef calculate_lateral_surface_area(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    return 2 * math.pi * radius * height\n\n# Test cases to verify the correctness of the function\ndef check_lateral_surface_area():\n    test_cases = [\n        (1, 2, 12.566370614359172),  # Example test case\n        (3, 4, 75.39822368615503),   # Additional test case\n        (0, 5, 0),                  # Edge case: radius is zero\n        (2, 0, 0),                  # Edge case: height is zero\n    ]\n    \n    all_passed = True\n    for radius, height, expected in test_cases:\n        result = calculate_lateral_surface_area(radius, height)\n        if not math.isclose(result, expected, rel_tol=1e-9):\n            print(f\"Test failed for radius={radius}, height={height}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check_lateral_surface_area()"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    # Calculate the volume of the cube\n    volume = side_length ** 3\n    return volume\n\n# Test the function with the provided test case\nassert volume_cube(3) == 27"}
{"task_id": "Mbpp/235", "solution": "def set_even_bits(n):\n    \"\"\"\n    Sets all even bits (0th, 2nd, 4th, ...) of a number to 1.\n    The function ensures that only even bits are set and higher bits are not affected.\n    \n    Args:\n    n (int): The number whose even bits you want to set.\n    \n    Returns:\n    int: The number with even bits set.\n    \"\"\"\n    # Calculate the number of bits in the integer\n    num_bits = n.bit_length()\n    if num_bits == 0:\n        return 0\n\n    # Create a mask with even bits set to 1\n    mask = 0\n    for i in range(0, num_bits + 1, 2):\n        mask |= (1 << i)\n\n    # XOR the number with the mask to set even bits\n    return n ^ mask\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (10, 15),  # Binary: 1010 -> 1111\n        (0, 0),    # Binary: 0000 -> 0000\n        (1, 1),    # Binary: 0001 -> 0001\n        (2, 3),    # Binary: 0010 -> 0011\n        (3, 3),    # Binary: 0011 -> 0011\n        (4, 5),    # Binary: 0100 -> 0101\n        (5, 5),    # Binary: 0101 -> 0101\n        (6, 7),    # Binary: 0110 -> 0111\n        (7, 7),    # Binary: 0111 -> 0111\n        (8, 9),    # Binary: 1000 -> 1001\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = set_even_bits(n)\n        if result != expected:\n            print(f\"Test failed for input {n}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Run the check function to verify the solution\ncheck()"}
{"task_id": "Mbpp/237", "solution": "def create_dict_from_lists(list_of_lists):\n    \"\"\"\n    Convert a list of lists into a dictionary where each key is a tuple created from the list elements.\n    \n    Example:\n    Input: [[1, 2], [3, 4]]\n    Output: {(1, 2): None, (3, 4): None}\n    \"\"\"\n    result_dict = {}\n    for lst in list_of_lists:\n        # Convert the list to a tuple to use it as a dictionary key\n        key = tuple(lst)\n        result_dict[key] = None  # You can replace None with any value you want to associate with the key\n    \n    return result_dict\n\n# Check function to verify the correctness of the generated function\ndef check():\n    test_cases = [([[1, 2], [3, 4]], {(1, 2): None, (3, 4): None}),\n                  ([[5, 6], [7, 8], [9, 10]], {(5, 6): None, (7, 8): None, (9, 10): None})]\n    \n    all_passed = True\n    for input_data, expected in test_cases:\n        actual = create_dict_from_lists(input_data)\n        if actual != expected:\n            print(f\"Test failed for input {input_data}. Expected {expected}, got {actual}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    # Initialize the count of substrings\n    count = 0\n    # Calculate the number of substrings\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            count += 1\n    return count\n\n# Test the function with the provided test case\nassert number_of_substrings(\"abc\") == 6"}
{"task_id": "Mbpp/239", "solution": "def count_good_sequences(n, m, k):\n    \"\"\"\n    Counts the number of good sequences of length n, where each element is between 1 and m,\n    and the sequence contains exactly k subsequences of consecutive equal elements.\n    \"\"\"\n    # Initialize the dp array\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: one way to have a sequence of length 0 with 0 subsequences of consecutive elements\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            # Case 1: The current element is different from the previous one\n            dp[i][j] += dp[i - 1][j] * (m - 1)\n            # Case 2: The current element is the same as the previous one\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n\n    return dp[n][k]\n\n# Example check function to verify the solution with provided data points\ndef check_solution():\n    test_cases = [((2, 3, 1), 3), ((5, 3, 0), 1), ((9, 4, 2), 24), ((7, 5, 3), 96)]\n    all_passed = True\n    for inputs, expected in test_cases:\n        result = count_good_sequences(*inputs)\n        if result != expected:\n            print(f\"Test failed for inputs {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/240", "solution": "def replace_list(lst1, lst2):\n    # Replace the last element of the first list with the elements of the second list\n    lst1[-1:] = lst2\n    return lst1\n\n# Test the function with the provided test case\nassert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"}
{"task_id": "Mbpp/242", "solution": "def count_charac(str1):\n    # Calculate the length of the string\n    length = len(str1)\n    return length\n\n# Test the function with the provided test case\nassert count_charac(\"python programming\") == 18"}
{"task_id": "Mbpp/244", "solution": "import math\n\ndef find_next_perfect_square(n):\n    \"\"\"\n    Find the smallest perfect square greater than the given number n.\n    \n    Args:\n    n (int): The number to find the next perfect square for.\n    \n    Returns:\n    int: The next perfect square greater than n.\n    \"\"\"\n    # Calculate the square root of n and round it up to the nearest integer\n    root = math.ceil(math.sqrt(n))\n    # Return the square of the rounded root\n    return root ** 2\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(3, 4), (15, 16), (9, 16), (25, 36), (0, 1), (1, 4)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = find_next_perfect_square(n)\n        if result != expected:\n            print(f\"Test failed for input {n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Calculate the maximum increasing subsequence sum ending at each index\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Calculate the maximum decreasing subsequence sum starting at each index\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of a bitonic sequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum\n\n# Test the function with the provided test case\nassert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194"}
{"task_id": "Mbpp/247", "solution": "def find_lps(s):\n    \"\"\"\n    Helper function to find the longest palindromic subsequence in the given string.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return \"\"\n    dp = [[\"\" for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = s[i]\n    \n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = s[i] + s[j]\n            elif s[i] == s[j]:\n                dp[i][j] = s[i] + dp[i + 1][j - 1] + s[j]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j], key=len)\n    return dp[0][n - 1]\n\ndef lps(s):\n    \"\"\"\n    Function to find the longest palindromic subsequence in the given string.\n    \"\"\"\n    if not s:\n        return \"\"\n    return find_lps(s)\n\n# Example usage:"}
{"task_id": "Mbpp/250", "solution": "def count_X(test_tup, K):\n    # Count the occurrences of K in the tuple using the count method\n    res = test_tup.count(K)\n    return res\n\n# Test the function with the provided test case\nassert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 4) == 0"}
{"task_id": "Mbpp/251", "solution": "def prepend_to_each_element(original_list, element):\n    \"\"\"\n    Prepend a given element to each element in the original list.\n    \n    Args:\n    original_list: A list of elements.\n    element: The element to prepend to each element in the original list.\n    \n    Returns:\n    A new list with the element prepended to each element in the original list.\n    \"\"\"\n    return [element + item for item in original_list]\n\n# Test cases to verify the correctness of the function\ndef check_solution():\n    test_cases = [([1, 2, 3], 0, [01, 02, 03]),\n                  (['a', 'b', 'c'], 'x', ['x'a, 'x'b, 'x'c]),\n                  ([], 5, [])]\n    \n    all_passed = True\n    for idx, (original, element, expected) in enumerate(test_cases):\n        result = prepend_to_each_element(original, element)\n        if result != expected:\n            print(f\"Test case {idx+1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/252", "solution": "import cmath\n\ndef convert(num):\n    # Convert the complex number to polar coordinates\n    polar_coordinates = cmath.polar(num)\n    return polar_coordinates\n\n# Test the function with the provided test case\nassert convert(1) == (1.0, 0.0)"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    # Initialize a counter to count the integer elements\n    count = 0\n    # Iterate through each element in the list\n    for element in lst:\n        # Check if the element is an integer\n        if type(element) is int:\n            # Increment the counter if the element is an integer\n            count += 1\n    # Return the total count of integer elements\n    return count\n\n# Test the function with the provided test case\nassert count_integer([1, 2, 'abc', 1.2]) == 2"}
{"task_id": "Mbpp/255", "solution": "from itertools import product\n\ndef generate_color_combinations(colors, length):\n    \"\"\"\n    Generate all possible combinations with repetition of colors.\n    \n    :param colors: List of color names.\n    :param length: Length of each combination.\n    :return: List of tuples, each representing a combination of colors.\n    \"\"\"\n    return list(product(colors, repeat=length))\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [(['red', 'blue'], 2, [('red', 'red'), ('red', 'blue'), ('blue', 'red'), ('blue', 'blue')]),\n                  (['green', 'yellow', 'purple'], 1, [('green',), ('yellow',), ('purple',)])]\n    \n    all_passed = True\n    for colors, length, expected in test_cases:\n        result = generate_color_combinations(colors, length)\n        if sorted(result) != sorted(expected):\n            print(f\"Test failed for colors: {colors} with length: {length}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check_function()"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    # If n is less than 2, there are no prime numbers less than n\n    if n < 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Use the Sieve of Eratosthenes algorithm to find all prime numbers less than n\n    for start in range(2, int(n**0.5) + 1):\n        if is_prime[start]:\n            for multiple in range(start*start, n, start):\n                is_prime[multiple] = False\n    \n    # Count and return the number of prime numbers\n    return sum(is_prime)\n\n# Test the function with the provided test case\nassert count_Primes_nums(5) == 2"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(num1, num2):\n    # Return a tuple with the second number first and then the first number\n    return (num2, num1)\n\n# Test the function with the provided test case\nassert swap_numbers(10, 20) == (20, 10)"}
{"task_id": "Mbpp/259", "solution": "def find_max_sum_subarray(arr):\n    \"\"\"\n    Finds the maximum sum of a contiguous subarray within a one-dimensional array of numbers.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The maximum sum of a contiguous subarray.\n    \"\"\"\n    if not arr:  # If the array is empty, return 0\n        return 0\n    \n    max_ending_here = max_so_far = arr[0]\n    \n    for x in arr[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    ([1, 2, 3, 4, 5], 15),\n    ([-1, -2, -3, -4, -5], -1),\n    ([1, -2, 3, 5, -3, 2], 10),\n    ([], 0),\n    ([0, 0, 0, 0], 0)\n]\n\ndef check_function():\n    all_passed = True\n    for idx, (arr, expected) in enumerate(test_cases):\n        result = find_max_sum_subarray(arr)\n        if result != expected:\n            print(f\"Test case {idx + 1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_function()"}
{"task_id": "Mbpp/260", "solution": "def find_nth_newman_shanks_williams_prime(n):\n    \"\"\"\n    Find the nth Newman\u2013Shanks\u2013Williams prime.\n    \n    Newman\u2013Shanks\u2013Williams primes are a special type of prime numbers that are generated\n    using a specific sequence. The sequence starts with 4, and each subsequent term is\n    generated by the formula: a(n) = 2^(2^n) + 1, where n is the index of the term.\n    \n    Parameters:\n    n (int): The index of the Newman\u2013Shanks\u2013Williams prime to find.\n    \n    Returns:\n    int: The nth Newman\u2013Shanks\u2013Williams prime.\n    \"\"\"\n    if n == 0:\n        return 2  # The first Newman\u2013Shanks\u2013Williams prime is 2.\n    \n    index = 1\n    while True:\n        candidate = (2 ** (2 ** index)) + 1\n        if is_prime(candidate):\n            n -= 1\n            if n == 0:\n                return candidate\n        index += 1\n\ndef is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n# Check function to verify the correctness of the generated function.\ndef check():\n    test_cases = [(0, 2), (1, 7), (2, 41), (3, 239), (4, 2801)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = find_nth_newman_shanks_williams_prime(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    # Use a generator expression to perform element-wise division and handle division by zero\n    result = tuple(i / j if j != 0 else 0 for i, j in zip(tuple1, tuple2))\n    return result\n\n# Test the function with the provided test case\nassert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2.0, 2.0, 2.0, 3)"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    # Split the list into two parts based on the length L\n    first_part = lst[:L]\n    second_part = lst[L:]\n    # Return the two parts as a tuple\n    return (first_part, second_part)\n\n# Test the function with the provided test case\nassert split_two_parts([1,1,2,3,4,4,5,1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"}
{"task_id": "Mbpp/264", "solution": "def human_to_dog_years(human_years):\n    \"\"\"\n    Convert human years to dog years.\n    \n    The first two human years are equivalent to 10.5 dog years each.\n    Any additional human years are equivalent to 4 dog years each.\n    \n    Parameters:\n    human_years (int): The age in human years.\n    \n    Returns:\n    float: The age in dog years.\n    \"\"\"\n    if human_years <= 0:\n        return 0\n    elif human_years == 1:\n        return 10.5\n    elif human_years == 2:\n        return 21\n    else:\n        return 21 + (human_years - 2) * 4\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (1, 10.5),\n        (2, 21),\n        (10, 41),\n        (0, 0),\n        (-1, 0)\n    ]\n    \n    all_passed = True\n    for human_years, expected in test_cases:\n        result = human_to_dog_years(human_years)\n        if result != expected:\n            print(f\"Test failed for {human_years} human years. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n-sized chunks.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The size of each chunk.\n    \n    Returns:\n    list: A list of n-sized chunks.\n    \"\"\"\n    return [lst[i:i + n] for i in range(0, len(lst), n)]\n\n# Test cases to verify the correctness of the function"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side):\n    # Calculate the lateral surface area of a cube\n    return 4 * side * side\n\n# Test the function with the provided test case\nassert lateralsurface_cube(5) == 100"}
{"task_id": "Mbpp/267", "solution": "def sum_of_squares_of_odds(n):\n    \"\"\"\n    Calculate the sum of squares of the first n odd natural numbers.\n    \n    Parameters:\n    n (int): The number of initial odd natural numbers to consider.\n    \n    Returns:\n    int: The sum of squares of the first n odd natural numbers.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        return 0\n    sum_squares = 0\n    for i in range(n):\n        odd_number = 2 * i + 1\n        sum_squares += odd_number ** 2\n    return sum_squares\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (0, 0),  # Edge case: n is 0\n        (1, 1),  # Edge case: n is 1\n        (2, 10), # n is 2\n        (3, 35), # n is 3\n        (-1, 0), # Edge case: n is negative\n        (5, 165) # n is 5\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = sum_of_squares_of_odds(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the line below to run the check function\n# check()"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    # Calculate the n'th star number using the formula\n    return 6 * n * (n - 1) + 1\n\n# Test the function with the provided test case\nassert find_star_num(3) == 37"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(c):\n    # Convert the character to its ASCII value and return it\n    return ord(c)\n\n# Test the function with the provided test case\nassert ascii_value('A') == 65"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    # Initialize sum to 0\n    sum = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is even\n        if index % 2 == 0 and value % 2 == 0:\n            sum += value\n    return sum\n\n# Test the function with the provided test case\nassert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    # Initialize sum to 0\n    sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the even number (2 * i)\n        even_number = 2 * i\n        # Add the fifth power of the even number to the sum\n        sum += even_number ** 5\n    return sum\n\n# Test the function with the provided test case\nassert even_Power_Sum(2) == 1056"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(test_list):\n    # Extract the last element of each tuple in the list\n    rear_elements = [sub[-1] for sub in test_list]\n    return rear_elements\n\n# Test the function with the provided test case\nassert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"}
{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    # Use a tuple comprehension to subtract elements of tuple2 from tuple1\n    result = tuple(x - y for x, y in zip(tuple1, tuple2))\n    return result\n\n# Test the function with the provided test case\nassert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"}
{"task_id": "Mbpp/274", "solution": "def calculate_binomial_sum(n):\n    \"\"\"\n    Calculate the sum of binomial coefficients for a given n.\n    \n    Args:\n    n : int - The number of trials.\n    \n    Returns:\n    int - The sum of binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n + 1):\n        # Calculate binomial coefficient using the formula: n! / (i! * (n-i)!)\n        binom_coeff = 1\n        for j in range(min(i, n - i)):\n            binom_coeff *= (n - j) // (j + 1)\n        total_sum += binom_coeff\n    return total_sum\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [(3, 8), (4, 16), (5, 32)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = calculate_binomial_sum(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/276", "solution": "import math\n\ndef volume_cylinder(radius, height):\n    # Calculate the volume of the cylinder\n    volume = math.pi * (radius ** 2) * height\n    return volume\n\n# Test the function with the provided test case\nassert math.isclose(volume_cylinder(10, 5), 1570.7500000000002, rel_tol=0.001)"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dict1, n):\n    # Filter the dictionary to only include entries with values >= n\n    result = {key: value for key, value in dict1.items() if value >= n}\n    return result\n\n# Test the function with the provided test case\nassert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190}, 170) == {'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}"}
{"task_id": "Mbpp/278", "solution": "def count_elements_before_tuple(lst):\n    \"\"\"\n    Counts the number of elements in the list that appear before the first tuple element.\n    \n    Parameters:\n    lst (list): The list containing elements, including a tuple.\n    \n    Returns:\n    int: The count of elements before the first tuple element in the list.\n    \"\"\"\n    for index, element in enumerate(lst):\n        if isinstance(element, tuple):\n            return index\n    return 0  # Return 0 if no tuple is found in the list\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([1, 2, (3, 4), 5, 6], 2),  # 2 elements before the tuple (3, 4)\n                  ([1, 2, 3, 4], 0),          # No tuple in the list\n                  ([], 0),                    # Empty list\n                  ([1, (2, 3), 4, 5], 1)]     # 1 element before the tuple (2, 3)\n    \n    all_passed = True\n    for lst, expected in test_cases:\n        result = count_elements_before_tuple(lst)\n        if result != expected:\n            print(f\"Test failed for: {lst}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    # Calculate the nth decagonal number using the formula\n    return 4 * n * n - 3 * n\n\n# Test the function with the provided test case\nassert is_num_decagonal(3) == 27"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, target):\n    # Iterate through the array with index\n    for index, element in enumerate(arr):\n        # Check if the current element matches the target\n        if element == target:\n            return (True, index)\n    # Return (False, -1) if the target is not found\n    return (False, -1)\n\n# Test the function with the provided test case\nassert sequential_search([11,23,58,31,56,77,43,12,65,19], 31) == (True, 3)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    # Check if the length of the list is the same as the length of the set of the list\n    # If they are the same, all elements are unique\n    return len(lst) == len(set(lst))\n\n# Test the function with the provided test case\nassert all_unique([1, 2, 3]) == True"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    # Subtract each element of the second list from the first list element-wise\n    return [a - b for a, b in zip(list1, list2)]\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/283", "solution": "def validate(num):\n    # Convert the number to a string to iterate over each digit\n    num_str = str(num)\n    # Iterate through each unique digit in the number\n    for digit in set(num_str):\n        # Count the frequency of the current digit in the number\n        if num_str.count(digit) > int(digit):\n            return False\n    return True\n\n# Test the function with the provided test case\nassert validate(1234) == True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    # Check if all items in the list are equal to the given element\n    return all(item == element for item in lst)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/285", "solution": "import re\n\ndef match_pattern(text):\n    \"\"\"\n    This function checks if the given text matches the pattern of 'a' followed by exactly two or three 'b' characters.\n    \n    Args:\n    text (str): The text to be checked against the pattern.\n    \n    Returns:\n    bool: True if the text matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"ab{2,3}$\"\n    match = re.search(pattern, text)\n    return bool(match)\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (\"abbb\", True),\n    (\"aabbb\", False),\n    (\"ab\", True),\n    (\"a\", False),\n    (\"abbbbbb\", False),\n    (\"abc\", False),\n]\n\nall_passed = True\nfor text, expected in test_cases:\n    result = match_pattern(text)\n    if result != expected:\n        print(f\"Test failed for: {text}. Expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All tests passed!\")"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    # Calculate the maximum subarray sum for a single array\n    max_current = max_global = arr[0]\n    for i in range(1, n):\n        max_current = max(arr[i], max_current + arr[i])\n        if max_current > max_global:\n            max_global = max_current\n\n    # Calculate the total sum of the array\n    total_sum = sum(arr)\n\n    # If k is 1, return the result of the single array case\n    if k == 1:\n        return max_global\n\n    # If the total sum is negative, do not add extra sums\n    if total_sum < 0:\n        return max_global\n\n    # Otherwise, the result is total_sum * (k-1) + max_global\n    return max_global + (k - 1) * total_sum\n\n# Test the function with the provided test case\nassert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30"}
{"task_id": "Mbpp/287", "solution": "def generate_even_numbers(n):\n    \"\"\"\n    Generate a list of the first n even natural numbers.\n    \n    Parameters:\n    n (int): The number of even natural numbers to generate.\n    \n    Returns:\n    list: A list containing the first n even natural numbers.\n    \"\"\"\n    if n <= 0:\n        return []\n    return [2 * i for i in range(1, n + 1)]\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (0, []),\n        (1, [2]),\n        (2, [2, 4]),\n        (3, [2, 4, 6]),\n        (4, [2, 4, 6, 8]),\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = generate_even_numbers(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/290", "solution": "def max_length(lists):\n    # Find the maximum length of the sublists\n    max_len = max(len(sublist) for sublist in lists)\n    # Return the maximum length and the sublist with that length\n    return (max_len, [sublist for sublist in lists if len(sublist) == max_len][0])\n\n# Test the function with the provided test case\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"}
{"task_id": "Mbpp/292", "solution": "def find(x, y):\n    # Calculate the quotient using integer division\n    quotient = x // y\n    return quotient\n\n# Test the function with the provided test case\nassert find(10, 3) == 3"}
{"task_id": "Mbpp/293", "solution": "import math\n\ndef otherside_rightangle(side1, side2):\n    # Calculate the third side using Pythagorean theorem\n    third_side = math.sqrt(side1**2 + side2**2)\n    return third_side\n\n# Test the function with the provided test case\nassert otherside_rightangle(7, 8) == 10.63014581273465"}
{"task_id": "Mbpp/294", "solution": "def compare_elements(list1, list2):\n    \"\"\"\n    Compares two lists of elements, ensuring that comparisons are made between elements of the same type.\n    If elements are of different types, they are considered unequal.\n    \n    Parameters:\n    - list1: First list of elements.\n    - list2: Second list of elements.\n    \n    Returns:\n    - A list of boolean values indicating the result of the comparison for each pair of elements.\n    \"\"\"\n    result = []\n    for elem1, elem2 in zip(list1, list2):\n        if type(elem1) == type(elem2):\n            result.append(elem1 == elem2)\n        else:\n            result.append(False)\n    return result\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([1, 'hello', 3.14], [1, 'hello', 3.14], [True, True, True]),\n                  ([1, 'hello', 3.14], [1, 'world', 3], [True, False, True]),\n                  ([], [], []),\n                  ([1, 2, 3], [1, 2, 3, 4], [True, True, True, False])]\n    \n    all_passed = True\n    for list1, list2, expected in test_cases:\n        result = compare_elements(list1, list2)\n        if result != expected:\n            print(f\"Failed for compare_elements({list1}, {list2}). Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Running the check function\ncheck()"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inv_count = 0\n    # Traverse each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If there is an inversion, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    # Iterate through each element in the nested list\n    for element in nested_list:\n        # If the element is a list, extend the flat_list with its elements\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        else:\n            # If the element is not a list, append it to the flat_list\n            flat_list.append(element)\n    return flat_list\n\n# Test the function with the provided test case\nassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(lst):\n    # Initialize a dictionary to keep track of the maximum aggregate for each person\n    max_aggregate_dict = {}\n    \n    # Iterate through each tuple in the list\n    for name, score in lst:\n        # If the name is already in the dictionary, add the score to the existing total\n        if name in max_aggregate_dict:\n            max_aggregate_dict[name] += score\n        else:\n            # Otherwise, initialize the name in the dictionary with the score\n            max_aggregate_dict[name] = score\n    \n    # Find the name with the maximum aggregate score\n    max_name = max(max_aggregate_dict, key=max_aggregate_dict.get)\n    \n    # Return the name with the maximum aggregate score and the score itself as a tuple\n    return (max_name, max_aggregate_dict[max_name])\n\n# Test the function with the provided test case\nassert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)]) == ('Juan Whelan', 212)"}
{"task_id": "Mbpp/300", "solution": "def count_binary_sequences(n):\n    \"\"\"\n    Calculate the count of binary sequences of length 2n, where the first n bits are equal to the last n bits.\n    \n    :param n: Length of the first (and last) half of the binary sequence.\n    :return: The count of such binary sequences.\n    \"\"\"\n    # The count of binary sequences of length 2n where the first n bits are equal to the last n bits is 2^n.\n    return 2 ** n\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(1, 2), (2, 4), (3, 8)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = count_binary_sequences(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}.\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    # Check if the input is a dictionary\n    if not isinstance(d, dict):\n        return 0\n    # If the dictionary is empty, its depth is 1\n    if not d:\n        return 1\n    # Calculate the maximum depth among all values\n    return 1 + max((dict_depth(v) for v in d.values() if isinstance(v, dict)), default=0)\n\n# Test cases to verify the correctness of the function\ndef check():\n    test_cases = [\n        ({}, 1),\n        ({'a': 1}, 1),\n        ({'a': {'b': 1}, 'c': 1}, 2),\n        ({'a': {'b': {'c': 1}}, 'd': 1}, 3),\n        ({'a': {'b': 1, 'c': {'d': 1}}, 'e': 1}, 3),\n    ]\n    \n    all_passed = True\n    for d, expected in test_cases:\n        result = dict_depth(d)\n        if result != expected:\n            print(f\"Test failed for: {d}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Run the check function to verify the solution\ncheck()"}
{"task_id": "Mbpp/305", "solution": "def starts_with_p(phrase):\n    \"\"\"\n    Checks if any word in the given phrase starts with the letter 'p'.\n    \n    Args:\n    phrase (str): The phrase to check.\n    \n    Returns:\n    bool: True if any word starts with 'p', False otherwise.\n    \"\"\"\n    # Split the phrase into words\n    words = phrase.split()\n    \n    # Check each word to see if it starts with 'p'\n    for word in words:\n        if word.lower().startswith('p'):\n            return True\n    return False\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (\"Proud parents\", True),\n    (\"The quick brown fox\", False),\n    (\"Peach pie\", True),\n    (\"An apple a day\", False),\n    (\"\", False),\n    (\"P\", True),\n    (\"p\", True),\n    (\"penguin\", True),\n    (\"Pineapple\", True),\n    (\"apple pie\", False)\n]\n\n# Function to check the test cases\ndef check_function():\n    all_passed = True\n    for phrase, expected in test_cases:\n        result = starts_with_p(phrase)\n        if result != expected:\n            print(f\"Test failed for: \\\"{phrase}\\\". Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Running the check function\ncheck_function()"}
{"task_id": "Mbpp/306", "solution": "def find_max_increasing_subsequence(arr):\n    \"\"\"\n    Finds the maximum sum of an increasing subsequence in the given array.\n    \n    Args:\n    arr (List[int]): The input array of integers.\n    \n    Returns:\n    int: The maximum sum of an increasing subsequence.\n    \"\"\"\n    n = len(arr)\n    dp = [0] * n  # dp[i] will store the maximum sum of increasing subsequence ending at index i\n    \n    # Initialize dp array with the elements of the array\n    for i in range(n):\n        dp[i] = arr[i]\n    \n    # Fill dp array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:  # Corrected condition to compare with arr[j - 1]\n                dp[i] = max(dp[i], dp[j] + arr[i])  # Corrected loop range to i (inclusive)\n    \n    # Find the maximum value in dp array\n    return max(dp)\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [([10, 22, 9, 33, 21, 50, 41, 60], 123), ([5, 4, 3, 2, 1], 5), ([1, 3, 6, 5, 2, 4], 10)]\n    \n    all_passed = True\n    for arr, expected in test_cases:\n        result = find_max_increasing_subsequence(arr)\n        if result != expected:\n            print(f\"Test failed for: {arr}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    # Sort the products in descending order and select the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    return largest_products\n\n# Test the function with the provided test case\nassert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    # Return the larger of the two numbers\n    if a > b:\n        return a\n    else:\n        return b\n\n# Test the function with the provided test case\nassert maximum(5, 10) == 10"}
{"task_id": "Mbpp/310", "solution": "def convert_string_to_tuple(input_string):\n    \"\"\"\n    Converts a given string into a tuple of characters.\n    \n    Parameters:\n    - input_string (str): The string to be converted.\n    \n    Returns:\n    - tuple: A tuple containing each character of the input string as separate elements.\n    \"\"\"\n    return tuple(input_string)\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (\"python 3.0\", ('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')),\n    (\"hello\", ('h', 'e', 'l', 'l', 'o')),\n    (\"\", ()),  # Testing with an empty string\n]\n\ndef check_function():\n    all_passed = True\n    for input_str, expected_output in test_cases:\n        result = convert_string_to_tuple(input_str)\n        if result != expected_output:\n            print(f\"Test failed for input: '{input_str}'. Expected {expected_output}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Running the check function to verify the solution\ncheck_function()"}
{"task_id": "Mbpp/311", "solution": "def set_leftmost_unset_bit(n):\n    \"\"\"\n    Sets the leftmost unset bit of the given integer n.\n    \n    Parameters:\n    n (int): The integer whose leftmost unset bit needs to be set.\n    \n    Returns:\n    int: The integer with the leftmost unset bit set.\n    \"\"\"\n    if n == 0:\n        return 1\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32  # For handling 64-bit integers\n    return n + 1\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (0, 1),\n        (1, 2),\n        (2, 3),\n        (3, 3),\n        (4, 5),\n        (7, 8),\n        (8, 9),\n        (10, 11),\n        (12, 13),\n        (15, 16),\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = set_leftmost_unset_bit(n)\n        if result != expected:\n            print(f\"Test failed for input {n}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/312", "solution": "import math\n\ndef volume_cone(radius, height):\n    # Calculate the volume of a cone using the formula V = (1/3)\u03c0r\u00b2h\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume\n\n# Test the function with the provided test case\nassert math.isclose(volume_cone(5, 12), 314.15926535897927, rel_tol=0.001)"}
{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    # Initialize the power of 2\n    power = 1\n    # Keep multiplying by 2 until it exceeds n\n    while power * 2 <= n:\n        power *= 2\n    return power\n\n# Test the function with the provided test case\nassert highest_Power_of_2(10) == 8"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    # Base cases for the first two Lucas numbers\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    # Recursive call to find the n'th Lucas number\n    return find_lucas(n - 1) + find_lucas(n - 2)\n\n# Test the function with the provided test case\nassert find_lucas(9) == 76"}
{"task_id": "Mbpp/390", "solution": "def add_string(l, s):\n    # Apply the format string to each element in the list\n    res = [s.format(i) for i in l]\n    return res\n\n# Test the function with the provided test case\nassert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(list1, list2, list3):\n    # Create a list of dictionaries using the zipped lists\n    result = [dict(zip([item1], [dict(zip([item2], [item3]))])) for item1, item2, item3 in zip(list1, list2, list3)]\n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {0: 0, 1: 1}\n    \n    def helper(x):\n        # If the result is already computed, return it\n        if x in memo:\n            return memo[x]\n        # Compute the maximum sum recursively\n        max_sum = max(x, helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5))\n        # Store the result in the dictionary\n        memo[x] = max_sum\n        return max_sum\n    \n    return helper(n)\n\n# Test the function with the provided test case\nassert get_max_sum(60) == 106"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(test_tup):\n    # Check if the length of the tuple is the same as the length of the set created from the tuple\n    # If they are the same, it means there are no duplicates\n    return len(test_tup) == len(set(test_tup))\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(input_string):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None\n\n# Test the function with the provided test case\nassert first_non_repeating_character(\"abcabc\") == None"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    # Calculate the median of three numbers\n    if (a <= b <= c) or (c <= b <= a):\n        return b\n    elif (b <= a <= c) or (c <= a <= b):\n        return a\n    else:\n        return c\n\n# Test the function with the provided test case\nassert median_numbers(25, 55, 65) == 55.0"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Calculate the sum of digits from a list of numbers, handling nested and mixed lists.\n    \n    Args:\n    numbers (list): A list of integers, strings, and nested lists containing integers and strings.\n    \n    Returns:\n    int: The sum of all digits extracted from the list.\n    \"\"\"\n    def extract_integers(nested_list):\n        \"\"\"Recursively extract integers from nested lists.\"\"\"\n        for item in nested_list:\n            if isinstance(item, int):\n                yield item\n            elif isinstance(item, list):\n                yield from extract_integers(item)\n    \n    # Extract integers from the input list\n    integers = list(extract_integers(numbers))\n    \n    # Calculate the sum of digits\n    digit_sum = sum(int(digit) for number in integers for digit in str(number))\n    \n    return digit_sum\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([10, 20, 4, 5, 'b', 70, 'a'], 18),\n                  ([[10, 20, 4, 5, 'b', 70, 'a']], 18),\n                  ([], 0),\n                  ([1, 2, [3, 4], [5, [6, 7]]], 28)]\n    \n    all_passed = True\n    for input_list, expected in test_cases:\n        result = sum_of_digits(input_list)\n        if result != expected:\n            print(f\"Test failed for input {input_list}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    # Use the built-in min function to find the minimum of two numbers\n    return min(a, b)\n\n# Test the function with the provided test case\nassert minimum(1, 2) == 1"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(test_tup, K):\n    # Check if K is in test_tup using the 'in' keyword\n    if K in test_tup:\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r') == True"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    # Check if the number is even\n    if n % 2 == 0:\n        return False\n    else:\n        return True\n\n# Test the function with the provided test case\nassert find_Parity(12) == False"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(pairs):\n    # Calculate the product of each tuple and find the minimum product\n    min_product = min([x * y for x, y in pairs])\n    return min_product\n\n# Test the function with the provided test case\nassert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"}
{"task_id": "Mbpp/410", "solution": "def find_max_mixed_types(lst):\n    \"\"\"\n    Finds the maximum element in a list that may contain different types of elements.\n    If the list is empty, returns None.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return None\n\n    max_element = None\n    for element in lst:\n        if max_element is None or type(element) == type(max_element):\n            # If max_element is None or both elements are of the same type\n            if (isinstance(element, (int, float)) and isinstance(max_element, (int, float))) or \\\n               (isinstance(element, (str)) and isinstance(max_element, (str))):\n                # Compare numbers or strings\n                if (element > max_element) or (max_element is None):\n                    max_element = element\n        else:\n            # If types are different, convert to string for comparison\n            if (isinstance(element, (int, float)) and isinstance(max_element, str)) or \\\n               (isinstance(element, str) and isinstance(max_element, (int, float))):\n                # Convert number to string for comparison\n                if str(element) > str(max_element):\n                    max_element = element\n            elif (isinstance(element, str) and isinstance(max_element, str)):\n                # Compare strings\n                if str(element) > str(max_element):\n                    max_element = element\n    return max_element\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([], None),\n                  ([1, 2, 3, 4, 5], 5),\n                  ([1, 'apple', 3, 'banana', 2], 'banana'),\n                  (['apple', 1, 'banana', 2], 'banana'),\n                  ([1.5, 2.5, '3.5'], 2.5),\n                  (['a', 'b', 1, 2], 'b')]\n\n    all_passed = True\n    for inputs, expected in test_cases:\n        result = find_max_mixed_types(inputs)\n        if result != expected:\n            print(f\"Test failed for input {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(lst):\n    # Use list comprehension to filter out odd numbers\n    return [num for num in lst if num % 2 == 0]\n\n# Test the function with the provided test case\nassert remove_odd([1, 2, 3]) == [2]"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(test_list, n):\n    # Extracts the nth element from each tuple in the list\n    res = [sub[n] for sub in test_list]\n    return res\n\n# Test the function with the provided test case\nassert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"}
{"task_id": "Mbpp/414", "solution": "def overlapping(list1, list2):\n    # Check if any value in list1 exists in list2\n    return any(item in list2 for item in list1)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/415", "solution": "def find_two_largest(nums):\n    \"\"\"\n    Finds the two largest numbers in the given list.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    tuple: A tuple containing the two largest numbers.\n    \"\"\"\n    if len(nums) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    # Initialize the two largest numbers\n    first_largest = second_largest = float('-inf')\n    \n    for num in nums:\n        if num > first_largest:\n            second_largest = first_largest\n            first_largest = num\n        elif num > second_largest:\n            second_largest = num\n    \n    return (first_largest, second_largest)\n\n# Example usage:"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(input_list):\n    # Find the element with maximum length using max function with key=len\n    max_element = max(input_list, key=len)\n    return max_element\n\n# Test the function with the provided test case\nassert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(nums):\n    # Round each number in the list and calculate the sum\n    rounded_sum = sum(round(num) for num in nums)\n    # Multiply the sum by the length of the list\n    result = rounded_sum * len(nums)\n    return result\n\n# Test the function with the provided test case\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]) == 243"}
{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    # Calculate the cube sum of the first n even natural numbers\n    return sum([(2 * i) ** 3 for i in range(1, n + 1)])\n\n# Test the function with the provided test case\nassert cube_Sum(2) == 72"}
{"task_id": "Mbpp/421", "solution": "def flatten_and_concatenate(t):\n    \"\"\"\n    Recursively flattens nested tuples and concatenates all elements into a single string.\n    \n    :param t: A tuple that may contain nested tuples.\n    :return: A single string with all elements concatenated.\n    \"\"\"\n    result = []\n    for element in t:\n        if isinstance(element, tuple):\n            result.extend(flatten_and_concatenate(element))\n        else:\n            result.append(str(element))\n    return ''.join(result)\n\n# Test cases to verify the correctness of the function\ndef check_solution():\n    test_cases = [((('a', 'b', ('c', 'd')),), 'abcd'),\n                  (((('e', 'f'), 'g'), ('h', 'i')), 'efgghi'),\n                  ((('j', ('k', 'l', ('m', 'n'))), 'o'), 'jklmnoin')]\n    \n    all_passed = True\n    for inputs, expected in test_cases:\n        result = flatten_and_concatenate(inputs)\n        if result != expected:\n            print(f\"Test failed for input {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    # Calculate the average of the sum of cubes\n    average = sum_of_cubes / n\n    return average\n\n# Test the function with the provided test case\nassert find_Average_Of_Cube(2) == 4.5"}
{"task_id": "Mbpp/424", "solution": "def extract_last_char(tuples):\n    \"\"\"\n    Extracts the last character from each string in the given tuple of strings.\n    \n    Parameters:\n    tuples (tuple): A tuple containing strings.\n    \n    Returns:\n    tuple: A tuple containing the last character of each string from the input tuple.\n    \"\"\"\n    return tuple(s[-1] for s in tuples)\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        ((\"\", \"world\", \"test\"), ('', 'd', 't')),\n        (\"hello\", ('h', 'e', 'l', 'l', 'o')),\n        ([\"a\", \"b\", \"c\"], ('a', 'b', 'c')),\n        ([\"python\", \"programming\"], ('n', 'g'))\n    ]\n    \n    all_passed = True\n    for inputs, expected in test_cases:\n        result = extract_last_char(inputs)\n        if result != expected:\n            print(f\"Test failed for input {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the line below to run the check function\n# check_function()"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to keep track of the occurrences\n    count = 0\n    # Iterate through each sublist in the given list\n    for sublist in lst:\n        # If the current sublist contains the specified element, increment the counter\n        if element in sublist:\n            count += 1\n    return count\n\n# Test the function with the provided test case\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(nums):\n    # Use list comprehension to filter odd numbers\n    return [num for num in nums if num % 2 != 0]\n\n# Test the function with the provided test case\nassert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"}
{"task_id": "Mbpp/427", "solution": "from datetime import datetime\n\ndef convert_date_format(date_str):\n    \"\"\"\n    Converts a date string from \"yyyy-mm-dd\" format to \"dd-mm-yyyy\" format.\n    \n    Parameters:\n    date_str (str): A string representing the date in \"yyyy-mm-dd\" format.\n    \n    Returns:\n    str: A string representing the date in \"dd-mm-yyyy\" format.\n    \"\"\"\n    # Ensure the input is a string and matches the expected format\n    if not isinstance(date_str, str) or not date_str.matches(r'^\\d{4}-\\d{2}-\\d{2}$'):\n        raise ValueError(\"Input must be a string in 'yyyy-mm-dd' format.\")\n    \n    # Convert the date string to a datetime object\n    date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n    \n    # Format the datetime object to the desired format\n    formatted_date = date_obj.strftime('%d-%m-%Y')\n    \n    return formatted_date\n\n# Example usage and test cases"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size to half of the array length\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            # Save the current element\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next round\n    \n    return arr\n\n# Test the function with the provided test case\nassert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    # Use a generator expression to compute the elementwise AND operation\n    result = tuple(a & b for a, b in zip(tuple1, tuple2))\n    return result\n\n# Test the function with the provided test case\nassert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)"}
{"task_id": "Mbpp/430", "solution": "def calculate_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its coefficients in the form ax^2 + bx + c = 0.\n    \n    The directrix of a parabola is calculated using the formula k - (1/(4*a)), where k is the y-coordinate of the vertex.\n    The y-coordinate of the vertex (k) is calculated as (4ac - b^2) / (4a).\n    \n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float: The y-coordinate of the directrix.\n    \"\"\"\n    # Calculate the y-coordinate of the vertex\n    k = (4 * a * c - b ** 2) / (4 * a)\n    \n    # Calculate the directrix\n    directrix = k - (1 / (4 * a))\n    \n    return directrix\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [((1, 0, -1), -0.25), ((2, -4, 2), 0.5), ((-1, 2, -3), -0.75)]\n    all_passed = True\n    for inputs, expected in test_cases:\n        result = calculate_directrix(*inputs)\n        if not math.isclose(result, expected, rel_tol=1e-9):\n            print(f\"Test failed for inputs {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All tests passed!\")\n\n# Import math for isclose function\nimport math\n\n# Run the check function\ncheck()"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, c, height):\n    # Calculate the median length of the trapezium\n    median_length = (a + c) / 2\n    return median_length\n\n# Test the function with the provided test case\nassert median_trapezium(15, 25, 10) == 20"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert check_greater([1, 2, 3, 4, 5], 4) == False"}
{"task_id": "Mbpp/435", "solution": "def last_Digit(n):\n    # Return the last digit of the number\n    return abs(n) % 10\n\n# Test the function with the provided test case\nassert last_Digit(123) == 3"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(nums):\n    # Use list comprehension to filter negative numbers\n    return [num for num in nums if num < 0]\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string, taking every second character starting from index 1\n    for i in range(1, len(string), 2):\n        result += string[i]\n    return result\n\n# Test the function with the provided test case\nassert remove_odd(\"python\") == \"yhn\""}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    # Convert each number in the list to a string and join them together\n    combined_str = ''.join(str(number) for number in numbers)\n    # Convert the combined string back to an integer\n    return int(combined_str)\n\n# Test the function with the provided test case\nassert multiple_to_single([11, 33, 50]) == 113350"}
{"task_id": "Mbpp/440", "solution": "def find_adverb(sentence):\n    \"\"\"\n    Finds the first adverb in a given sentence and returns it along with its position.\n    An adverb is defined as a word ending with 'ly'. The function should return the adverb\n    and its starting position in the sentence. If no adverb is found, it returns None.\n    \"\"\"\n    # Initialize variables to store the adverb and its position\n    adverb = None\n    position = -1\n\n    # Iterate over the sentence to find the adverb\n    for i, char in enumerate(sentence):\n        # Check if the current character is the start of a word ending with 'ly'\n        if char.isalpha() and (i + 1 < len(sentence) and sentence[i + 1] == 'y'):\n            # Check if the next character is 'y' and the one after that is 'l'\n            if i + 2 < len(sentence) and sentence[i + 2] == 'l':\n                # Check if the word after 'ly' is 'y'\n                if i + 3 < len(sentence) and sentence[i + 3] == 'y':\n                    # Update the adverb and its position\n                    adverb = sentence[i:i+4]\n                    position = i\n                    break\n\n    # Return the adverb and its position, or None if no adverb is found\n    return adverb, position\n\n# Check function to verify the correctness of the generated function\ndef check():\n    test_cases = [\n        (\"He quickly ran to the store.\", (\"quickly\", 2)),\n        (\"She quietly sat down.\", (\"quietly\", 4)),\n        (\"They happily danced.\", (\"happily\", 4)),\n        (\"I went to the market.\", (None, -1)),\n        (\"!!\", (None, -1)),\n    ]\n\n    all_passed = True\n    for sentence, expected in test_cases:\n        result = find_adverb(sentence)\n        if result != expected:\n            print(f\"Test failed for: \\\"{sentence}\\\". Expected {expected}, got {result}\")\n            all_passed = False\n\n    if all_passed:\n        print(\"All tests passed!\")\n\n# Run the check function\ncheck()"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(size):\n    # Calculate the surface area of a cube\n    return 6 * size * size\n\n# Test the function with the provided test case\nassert surfacearea_cube(5) == 150"}
{"task_id": "Mbpp/445", "solution": "def multiply_tuples(tup1, tup2):\n    \"\"\"\n    Multiplies two tuples of tuples element-wise.\n    \n    Args:\n    tup1: A tuple of tuples.\n    tup2: A tuple of tuples of the same length as tup1.\n    \n    Returns:\n    A tuple of tuples with element-wise products.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(tup1) != len(tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    \n    # Initialize the result tuple\n    result = []\n    \n    # Iterate over the tuples and multiply corresponding elements\n    for pair1, pair2 in zip(tup1, tup2):\n        # Ensure each pair has the same length\n        if len(pair1) != len(pair2):\n            raise ValueError(\"Each pair of tuples must have the same length.\")\n        \n        # Multiply corresponding elements and create a new tuple\n        multiplied_pair = tuple(x * y for x, y in zip(pair1, pair2))\n        result.append(multiplied_pair)\n    \n    # Convert result list to tuple and return\n    return tuple(result)\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(((1, 2), (3, 4)), ((3, 8),), (((1, 2, 3), (4, 5, 6)), ((4, 10, 18),))),\n                  (((0, 2), (3, 0)), ((0, 0),), (((1, 2), (3, 4)), ((3, 8),))]\n\n    all_passed = True\n    for i, (tup1, tup2, expected) in enumerate(test_cases):\n        result = multiply_tuples(tup1, tup2)\n        if result != expected:\n            print(f\"Test case {i+1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some test cases failed.\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize the result counter\n    res = 0\n    # Iterate through each element in the test_list\n    for ele in test_list:\n        # Count the occurrences of the current element in the test_tup\n        res += test_tup.count(ele)\n    return res\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    # Use list comprehension to find the cube of each element in the list\n    return [i ** 3 for i in nums]\n\n# Test the function with the provided test case\nassert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"}
{"task_id": "Mbpp/448", "solution": "def perrin(n):\n    \"\"\"\n    Calculate the n-th Perrin number.\n    \n    The Perrin sequence is defined as follows:\n    P(0) = 3, P(1) = 0, P(2) = 2,\n    and for n > 2, P(n) = P(n-2) + P(n-3).\n    \n    Parameters:\n    n (int): The index (n-th) of the Perrin number to compute.\n    \n    Returns:\n    int: The n-th Perrin number.\n    \"\"\"\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        p0, p1, p2 = 3, 0, 2\n        for _ in range(3, n + 1):\n            p_next = p0 + p1\n            p0, p1, p2 = p1, p2, p_next\n        return p2\n\n# Test cases to verify the correctness of the function\ndef check_perrin():\n    test_cases = [\n        (0, 3),\n        (1, 0),\n        (2, 2),\n        (3, 2),\n        (4, 5),\n        (5, 5),\n        (6, 7),\n        (7, 10),\n        (8, 12),\n        (9, 17),\n        (-1, None),  # Handling negative input\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = perrin(n)\n        if result != expected:\n            print(f\"Test failed for n={n}: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_perrin()"}
{"task_id": "Mbpp/450", "solution": "def extract_string(strings, size):\n    # Use list comprehension to filter strings that match the specified size\n    return [s for s in strings if len(s) == size]\n\n# Test the function to ensure it works as expected\nassert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"}
{"task_id": "Mbpp/451", "solution": "def split_and_filter(input_string):\n    \"\"\"\n    Splits the input string by any whitespace and filters out any empty strings from the result.\n    \n    :param input_string: String to be split.\n    :return: A list of non-empty substrings.\n    \"\"\"\n    # Split the string by any whitespace and filter out empty strings\n    return [substring for substring in input_string.split() if substring]\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"  Hello   World  \", [\"Hello\", \"World\"]),\n        (\"Python\\tis\\nawesome  \", [\"Python\", \"is\", \"awesome\"]),\n        (\"   \", []),  # Edge case: string with only whitespace\n        (\"\", []),  # Edge case: empty string\n        (\"NoExtraSpaces\", [\"NoExtraSpaces\"]),  # No spaces to split\n    ]\n    \n    all_passed = True\n    for input_string, expected in test_cases:\n        result = split_and_filter(input_string)\n        if result != expected:\n            print(f\"Test failed for: '{input_string}'. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/453", "solution": "def sum_even_factors(n):\n    \"\"\"\n    Calculate the sum of even factors of a given number n.\n    \n    :param n: The number to find the even factors for.\n    :return: The sum of even factors of n.\n    \"\"\"\n    result = 0\n    for i in range(2, n + 1, 2):  # Start from 2 and increment by 2 to only consider even numbers\n        if n % i == 0:\n            result += i\n    return result\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(18, 26), (30, 48), (1, 0), (16, 30)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = sum_even_factors(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/454", "solution": "def text_match_wordz(text):\n    # Check if 'z' is present in the text\n    return 'z' in text\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month):\n    # List of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    # Check if the given month is in the list\n    if month in months_with_31_days:\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert check_monthnumb_number(5) == True"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(str_list):\n    # Reverse each string in the list using a list comprehension\n    return [s[::-1] for s in str_list]\n\n# Test the function with the provided test case\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    # Find the sublist with the minimum length\n    min_length = min(len(sublist) for sublist in lst)\n    # Return the first sublist that matches the minimum length\n    for sublist in lst:\n        if len(sublist) == min_length:\n            return sublist\n\n# Test the function with the provided test case\nassert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    # Calculate the area of the rectangle\n    area = length * width\n    return area\n\n# Test the function with the provided test case\nassert rectangle_area(10, 20) == 200"}
{"task_id": "Mbpp/459", "solution": "def has_no_uppercase(input_string):\n    # Check if the input is a string\n    if not isinstance(input_string, str):\n        return False\n    \n    # Iterate through each character in the string\n    for char in input_string:\n        # Check if the character is uppercase\n        if char.isupper():\n            return False\n    return True\n\n# Test cases to verify the correctness of the function"}
{"task_id": "Mbpp/460", "solution": "def Extract(test_list):\n    # Extract the first element from each sublist\n    res = [sub_list[0] for sub_list in test_list]\n    return res\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/462", "solution": "def sum_of_squares(numbers):\n    \"\"\"\n    Calculate the sum of squares of the given list of numbers.\n    \n    Example:\n    >>> sum_of_squares([1, 2, 3])\n    14\n    \"\"\"\n    return sum(x ** 2 for x in numbers)\n\n# Test the function with provided data points\ndef check_function():\n    test_cases = [([1, 2, 3], 14), ([0, 4, 5], 41), ([], 0)]\n    all_passed = True\n    for idx, (input_val, expected) in enumerate(test_cases):\n        result = sum_of_squares(input_val)\n        if result != expected:\n            print(f\"Test case {idx + 1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_function()"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    # Initialize variables to store the maximum and minimum products up to the current position\n    max_product = min_product = result = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # If the current element is negative, swap max and min products\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update the maximum and minimum products up to the current position\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result\n\n# Test the function with the provided test case\nassert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(colours):\n    # Filter out any key-value pairs where the value is None\n    return {k: v for k, v in colours.items() if v is not None}\n\n# Test the function to ensure it works as expected\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None}) == {'c1': 'Red', 'c2': 'Green'}"}
{"task_id": "Mbpp/468", "solution": "def find_max_product(nums):\n    \"\"\"\n    Finds the maximum product of two numbers in an increasing subsequence of nums.\n    \n    Args:\n    nums (List[int]): A list of integers.\n    \n    Returns:\n    int: The maximum product of two numbers in an increasing subsequence.\n    \"\"\"\n    if len(nums) < 2:\n        return None  # Not enough elements for a product\n    \n    max1 = max2 = float('-inf')\n    \n    for num in nums:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n    \n    return max1 * max2 if max2 != float('-inf') else None\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [([1, 2, 3, 4], 12),  # 3 * 4\n                  ([5, 1, 2, 3, 4], 20),  # 4 * 5\n                  ([1, 5, 4, 5], 25),  # 5 * 5\n                  ([1, 3, 6, 5, 7], 42),  # 6 * 7\n                  ([1, 2], 2),  # 1 * 2\n                  ([1], None),  # Not enough elements\n                  ([1, 1, 1, 1], 1)]  # 1 * 1\n    \n    all_passed = True\n    for nums, expected in test_cases:\n        result = find_max_product(nums)\n        if result != expected:\n            print(f\"Test failed for: {nums}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(test_tuple):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate through the tuple, stopping at the second-to-last element\n    for i in range(len(test_tuple) - 1):\n        # Add the current element and the next element, and append to the result list\n        result.append(test_tuple[i] + test_tuple[i + 1])\n    return tuple(result)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    # Initialize result to 1\n    result = 1\n    # Multiply each number in the array and take modulo n\n    for num in arr:\n        result = (result * num) % n\n    return result\n\n# Test the function with the provided test case\nassert find_remainder([100, 10, 5, 25, 35, 14], 11) == 9"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    # Check if the list is empty or has only one element\n    if len(lst) <= 1:\n        return True\n    # Sort the list to check for consecutiveness\n    sorted_lst = sorted(lst)\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i] + 1 != sorted_lst[i + 1]:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert check_Consecutive([1, 2, 3, 4, 5]) == True"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    # Convert each tuple in the lists to a sorted tuple to handle unordered elements\n    set1 = {tuple(sorted(t)) for t in list1}\n    set2 = {tuple(sorted(t)) for t in list2}\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Return the intersection as a frozenset to ensure immutability\n    return frozenset(intersection)\n\n# Test the function with the provided test case\nassert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}"}
{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(dict1):\n    # Sort the dictionary by value in descending order and return as a list of tuples\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    # Calculate the sum of the maximum and minimum values in the array\n    return max(arr) + min(arr)\n\n# Test the function with the provided test case\nassert big_sum([1, 2, 3]) == 4"}
{"task_id": "Mbpp/477", "solution": "def is_lower(text):\n    # Convert the given string to lower case\n    return text.lower()\n\n# Test the function with the provided test case\nassert is_lower(\"InValid\") == \"invalid\""}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    # Use a list comprehension to filter out lowercase letters\n    result = [char for char in string if char.isupper() or not char.isalpha()]\n    # Join the list back into a string and return\n    return ''.join(result)\n\n# Test the function with the provided test case\nassert remove_lowercase(\"PYTHon\") == 'PYTH'"}
{"task_id": "Mbpp/479", "solution": "def first_Digit(n):\n    # Convert the number to a string and return the first character as an integer\n    return int(str(abs(n))[0])\n\n# Test the function with the provided test case\nassert first_Digit(123) == 1"}
{"task_id": "Mbpp/554", "solution": "def Split(lst):\n    # Use list comprehension to filter out only odd numbers\n    return [num for num in lst if num % 2 != 0]\n\n# Test the function with the provided test case\nassert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    # Calculate the sum of the first n natural numbers\n    sum_of_naturals = sum([i for i in range(1, n+1)])\n    # Return the difference between the two sums\n    return sum_of_cubes - sum_of_naturals\n\n# Test the function with the provided test case\nassert difference(3) == 30"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    # Initialize count of pairs with odd XOR\n    count = 0\n    \n    # Iterate through each pair in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is odd\n            if ((arr[i] ^ arr[j]) & 1):\n                count += 1\n                \n    return count\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(s):\n    # Toggle the case of each character in the string\n    toggled = ''.join(char.lower() if char.isupper() else char.upper() for char in s)\n    return toggled\n\n# Test the function with the provided test case\nassert toggle_string(\"Python\") == \"pYTHON\""}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculate the digit distance between two integers.\n    \n    The digit distance is defined as the sum of the absolute differences of corresponding digits in the two numbers.\n    \n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n    \n    Returns:\n    int: The digit distance between the two integers.\n    \"\"\"\n    # Convert numbers to strings to easily access each digit\n    str_num1, str_num2 = str(abs(num1)), str(abs(num2))\n    # Ensure both numbers have the same length by padding the shorter one with leading zeros\n    max_length = max(len(str_num1), len(str_num2))\n    str_num1 = str_num1.zfill(max_length)\n    str_num2 = str_num2.zfill(max_length)\n    \n    # Calculate the sum of the absolute differences of corresponding digits\n    digit_distance = sum(abs(int(d1) - int(d2)) for d1, d2 in zip(str_num1, str_num2))\n    return digit_distance\n\n# Test cases to verify the correctness of the function\ndef check_solution():\n    test_cases = [\n        ((123, 256), 6),  # |1-2| + |2-5| + |3-6| = 6\n        ((111, 999), 18), # |1-9| + |1-9| + |1-9| = 18\n        ((12, 21), 1),    # |1-2| + |2-1| = 1\n        ((0, 0), 0),      # |0-0| = 0\n        ((12345, 54321), 16) # |1-5| + |2-4| + |3-3| + |4-2| + |5-1| = 16\n    ]\n    \n    all_passed = True\n    for (num1, num2), expected in test_cases:\n        result = digit_distance_nums(num1, num2)\n        if result != expected:\n            print(f\"Test failed for inputs {num1} and {num2}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Run the check function to verify the solution\ncheck_solution()"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    # Initialize variables to store the maximum sum so far and the current sum\n    max_so_far = 0\n    max_ending_here = 0\n    \n    # Iterate through the array\n    for i in range(0, n):\n        # Update the current sum\n        max_ending_here = max_ending_here + arr[i]\n        # If current sum is greater than the maximum sum so far, update it\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n        # If current sum becomes negative, reset it to 0\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far\n\n# Test the function with the provided test case\nassert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tup1, tup2):\n    # Convert tuples to sets, find the union, and convert back to tuple\n    result = tuple(set(tup1) | set(tup2))\n    # Return the sorted tuple\n    return tuple(sorted(result))\n\n# Test the function with the provided test case\nassert union_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 4, 5, 6, 7, 10)"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(test_list):\n    # Find the maximum length among the sublists\n    max_length = max(len(sublist) for sublist in test_list)\n    return max_length\n\n# Test the function with the provided test case\nassert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"}
{"task_id": "Mbpp/563", "solution": "def parse_string_to_list(input_string):\n    \"\"\"\n    Parses a string into a list of strings, splitting by \", \".\n    \n    Parameters:\n    - input_string (str): The string to be parsed.\n    \n    Returns:\n    - list: A list of strings obtained by splitting the input string by \", \".\n    \"\"\"\n    # Split the string by \", \" and strip any extra whitespace\n    result = [item.strip() for item in input_string.split(\", \")]\n    return result\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        (\"apple, banana, cherry\", [\"apple\", \"banana\", \"cherry\"]),\n        (\"  orange,  lemon, lime  \", [\"orange\", \"lemon\", \"lime\"]),\n        (\"grape\", [\"grape\"]),\n        (\"\", []),\n        (\"mango, , passionfruit\", [\"mango\", \"\", \"passionfruit\"])\n    ]\n    \n    all_passed = True\n    for input_str, expected in test_cases:\n        result = parse_string_to_list(input_str)\n        if result != expected:\n            print(f\"Test failed for input: '{input_str}'. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Run the check function to verify the solution\ncheck_function()"}
{"task_id": "Mbpp/564", "solution": "from collections import Counter\n\ndef count_equal_pairs(arr):\n    \"\"\"\n    Counts the number of pairs in the array that have equal elements.\n    \n    Args:\n    arr: List of integers.\n    \n    Returns:\n    int: The number of pairs with equal elements.\n    \"\"\"\n    element_count = Counter(arr)\n    pairs = 0\n    for count in element_count.values():\n        pairs += count * (count - 1) // 2\n    return pairs\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [([1, 2, 3], 0), ([1, 1, 3, 3, 3, 3], 4), ([1, 2, 3, 1, 1], 2)]\n    all_passed = True\n    for arr, expected in test_cases:\n        result = count_equal_pairs(arr)\n        if result != expected:\n            print(f\"Test failed for input {arr}. Expected {expected}, got {result}.\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/565", "solution": "def split(string):\n    # Split the string into a list of characters\n    return list(string)\n\n# Test the function with the provided test case\nassert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    # Convert the integer to a string, iterate over each character, convert it back to an integer, and sum them up\n    return sum(int(digit) for digit in str(n))\n\n# Test the function with the provided test case\nassert sum_digits(345) == 12"}
{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    # Iterate through the list and check if each element is less than or equal to the next\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"}
{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    # Create a list of n empty dictionaries\n    result = [{} for _ in range(n)]\n    return result\n\n# Test the function to ensure it works as expected\nassert empty_list(5) == [{}, {}, {}, {}, {}]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    # Use list comprehension to sort each sublist in the given list of lists\n    sorted_list = [sorted(sublist) for sublist in list_of_lists]\n    return sorted_list\n\n# Test the function with the provided test case\nassert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"}
{"task_id": "Mbpp/572", "solution": "def remove_duplicates_from_lists(lists):\n    \"\"\"\n    Removes duplicates from each list within the input list of lists.\n    \n    :param lists: List of lists containing numbers.\n    :return: A new list of lists with duplicates removed from each sublist.\n    \"\"\"\n    return [list(set(sublist)) for sublist in lists]\n\n# Test cases to verify the correctness of the function"}
{"task_id": "Mbpp/573", "solution": "def unique_product(lst):\n    # Calculate the product of unique numbers in the list\n    product = 1\n    for num in set(lst):\n        product *= num\n    return product\n\n# Test the function with the provided test case\nassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"}
{"task_id": "Mbpp/576", "solution": "def is_sublist(sequence, sublist):\n    \"\"\"\n    Checks if 'sublist' is a sublist of 'sequence' regardless of the actual values.\n    \n    Parameters:\n    sequence (list): The list in which to search for the sublist.\n    sublist (list): The list to search for within the sequence.\n    \n    Returns:\n    bool: True if 'sublist' is a sublist of 'sequence', False otherwise.\n    \"\"\"\n    sublist_length = len(sublist)\n    for i in range(len(sequence) - sublist_length + 1):\n        if sequence[i:i + sublist_length] == sublist:\n            return True\n    return False\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([1, 2, 3, 4, 5], [2, 3], True),\n                  ([1, 2, 3, 4, 5], [5, 6], False),\n                  ([1, 2, 3, 4, 5], [1, 3, 5], True),\n                  ([1, 2, 3, 4, 5], [2, 4], True),\n                  ([1, 2, 3, 4, 5], [6], False)]\n    \n    all_passed = True\n    for sequence, sublist, expected in test_cases:\n        result = is_sublist(sequence, sublist)\n        if result != expected:\n            print(f\"Failed for sequence: {sequence} and sublist: {sublist}. Expected {expected}, got {result}.\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/577", "solution": "def last_digit_of_factorial(nums):\n    \"\"\"\n    Calculate the last digit of the factorial of each number in the input list.\n    Handle edge cases such as non-integer inputs and empty lists.\n    \"\"\"\n    result = []\n    for num in nums:\n        if not isinstance(num, int) or num < 0:\n            result.append(-1)  # Return -1 for invalid inputs\n        elif num == 0 or num == 1:\n            result.append(1)  # 0! and 1! are both 1\n        else:\n            last_digit = 1\n            for i in range(2, num + 1):\n                last_digit = (last_digit * i) % 10  # Only keep the last digit\n            result.append(last_digit)\n    return result\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        ([3, 4, 5], [6, 2, 0]),\n        ([0, 1, 2], [1, 1, 2]),\n        ([], []),\n        ([2.5], [-1]),\n        ([], [])\n    ]\n    \n    all_passed = True\n    for inputs, expected in test_cases:\n        result = last_digit_of_factorial(inputs)\n        if result != expected:\n            print(f\"Test failed for input {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through the lists using the index\n    for i in range(len(list1)):\n        # Append elements from each list in order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(test_tup1, test_tup2):\n    # Find the symmetric difference between the two tuples\n    res = tuple(set(test_tup1) ^ set(test_tup2))\n    return res\n\n# Test the function with the provided test case\nassert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"}
{"task_id": "Mbpp/580", "solution": "def filter_even_numbers(numbers):\n    \"\"\"\n    Given a tuple of integers, return a new tuple containing only the even numbers.\n    \n    Example:\n    >>> filter_even_numbers((1, 2, 3, 4, 5, 6))\n    (2, 4, 6)\n    \"\"\"\n    return tuple(num for num in numbers if num % 2 == 0)\n\n# Test cases to verify the correctness of the function\ndef check_solution():\n    test_cases = [((1, 2, 3, 4, 5, 6), (2, 4, 6)),\n                  ((11, 22, 33, 44, 55), (22, 44)),\n                  ((7, 14, 21, 28), (14, 28)),\n                  ((0, 1, 2, 3, 4), (0, 2, 4)),\n                  ((-2, -1, 0, 1, 2), (-2, 0, 2))]\n    \n    all_passed = True\n    for idx, (input_data, expected) in enumerate(test_cases):\n        result = filter_even_numbers(input_data)\n        if result != expected:\n            print(f\"Test case {idx + 1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some test cases failed.\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"task_id": "Mbpp/581", "solution": "import math\n\ndef calculate_slant_height(base_edge, pyramid_height):\n    \"\"\"\n    Calculate the slant height of a square pyramid given the base edge and the height.\n    \n    The slant height (l) can be calculated using the formula:\n    l = sqrt((base_edge / 2)^2 + pyramid_height^2)\n    \n    Args:\n    base_edge (float): The length of one edge of the square base.\n    pyramid_height (float): The height of the pyramid from the base to the apex.\n    \n    Returns:\n    float: The slant height of the pyramid.\n    \"\"\"\n    return math.sqrt((base_edge / 2) ** 2 + pyramid_height ** 2)\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [\n        (4, 3, 5.0),  # Base edge = 4, Height = 3, Expected slant height = 5.0\n        (6, 4, 7.211102550927978),  # Base edge = 6, Height = 4, Expected slant height = 7.211102550927978\n        (8, 5, 8.5440037453175305)  # Base edge = 8, Height = 5, Expected slant height = 8.5440037453175305\n    ]\n    \n    all_passed = True\n    for base_edge, pyramid_height, expected in test_cases:\n        result = calculate_slant_height(base_edge, pyramid_height)\n        if not math.isclose(result, expected, rel_tol=1e-9):\n            print(f\"Test failed for base edge = {base_edge}, pyramid height = {pyramid_height}. \"\n                  f\"Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number using a direct formula.\n    \n    Args:\n    n (int): The position of the Catalan number to compute.\n    \n    Returns:\n    int: The nth Catalan number.\n    \"\"\"\n    if n == 0:\n        return 1\n    catalan = 0\n    for i in range(n):\n        catalan += catalan_number(i) * catalan_number(n - i - 1)\n    return catalan\n\n# Check function to verify the correctness of the generated function\ndef check():\n    test_cases = [(0, 1), (1, 1), (2, 2), (3, 5), (4, 14)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = catalan_number(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(data, n):\n    # Sort the data based on the price in descending order\n    sorted_data = sorted(data, key=lambda x: x['price'], reverse=True)\n    # Return the first n items from the sorted list\n    return sorted_data[:n]\n\n# Test the function with the provided test case\nassert expensive_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1) == [{'name': 'Item-2', 'price': 555.22}]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    # Split the array at the nth element and add the first part to the end\n    return arr[n:] + arr[:n]\n\n# Test the function with the provided test case\nassert split_Arr([12,10,5,6,52,36],2) == [5,6,52,36,12,10]"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(list1):\n    # Convert the list to a tuple\n    return tuple(list1)\n\n# Test the function with the provided test case\nassert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    # Check if the list is empty or contains a single element\n    if len(nums) <= 1:\n        return 0\n    # Calculate the difference between the max and min values in the list\n    return max(nums) - min(nums)\n\n# Test cases to verify the correctness of the function\nassert big_diff([1, 2, 3, 4]) == 3\nassert big_diff([10, 3, 5, 8, 2]) == 8\nassert big_diff([7]) == 0\nassert big_diff([]) == 0"}
{"task_id": "Mbpp/589", "solution": "import math\n\ndef find_perfect_squares(start, end):\n    \"\"\"\n    Finds all perfect squares within the given range [start, end].\n    \n    Args:\n    start (int): The start of the range.\n    end (int): The end of the range.\n    \n    Returns:\n    list: A list of perfect squares within the specified range.\n    \"\"\"\n    # Calculate the square roots of the start and end values\n    start_sqrt = math.ceil(math.sqrt(start))\n    end_sqrt = math.floor(math.sqrt(end))\n    \n    # Generate the range of perfect squares within the specified range\n    perfect_squares = [i**2 for i in range(start_sqrt, end_sqrt + 1)]\n    \n    # Filter the perfect squares to ensure they are within the specified range\n    perfect_squares = [square for square in perfect_squares if start <= square <= end]\n    \n    return perfect_squares\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        ((1, 16), [1, 4, 9, 16]),\n        ((5, 25), [9, 16, 25]),\n        ((10, 30), [16, 25]),\n        ((1, 1), [1]),\n        ((30, 50), [36, 49]),\n    ]\n    \n    all_passed = True\n    for (start, end), expected in test_cases:\n        result = find_perfect_squares(start, end)\n        if result != expected:\n            print(f\"Test failed for range ({start}, {end}). Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/590", "solution": "def polar_rect(radius, angle):\n    \"\"\"\n    Converts polar coordinates to rectangular coordinates.\n    \n    Parameters:\n    - radius: The radius (distance from the origin) of the point.\n    - angle: The angle (in degrees) of the point from the positive x-axis.\n    \n    Returns:\n    A tuple (x, y) representing the rectangular coordinates of the point.\n    \"\"\"\n    import math\n    x = radius * math.cos(math.radians(angle))\n    y = radius * math.sin(math.radians(angle))\n    return (x, y)\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        (5, 45, (3.5355339059327378, 3.5355339059327378)),\n        (10, 90, (0.0, 10.0)),\n        (7, 0, (7.0, 0.0)),\n    ]\n    \n    all_passed = True\n    for radius, angle, expected in test_cases:\n        result = polar_rect(radius, angle)\n        if not math.isclose(result[0], expected[0], rel_tol=1e-9) or not math.isclose(result[1], expected[1], rel_tol=1e-9):\n            print(f\"Test failed for radius={radius}, angle={angle}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Call the check function to verify the correctness of the polar_rect function\ncheck_function()"}
{"task_id": "Mbpp/591", "solution": "def swap_List(input_list):\n    # Swap the first and last elements of the list\n    input_list[0], input_list[-1] = input_list[-1], input_list[0]\n    return input_list\n\n# Test the function with the provided test case\nassert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"}
{"task_id": "Mbpp/592", "solution": "from math import comb\n\ndef sum_of_products(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n : int : The number of terms in the binomial coefficient sequence.\n    \n    Returns:\n    int : The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(1, n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(4, 20), (5, 70), (6, 252)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = sum_of_products(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/593", "solution": "def clean_ip_address(ip):\n    \"\"\"\n    Cleans the leading zeros from each part of the IP address.\n    >>> clean_ip_address(\"192.168.042.105\")\n    '192.168.42.105'\n    \"\"\"\n    parts = ip.split('.')\n    cleaned_parts = []\n    for part in parts:\n        if part.startswith('0') and len(part) > 1:\n            cleaned_part = part.lstrip('0')\n            if not cleaned_part:  # If the part is reduced to an empty string, it should be '0'\n                cleaned_part = '0'\n        else:\n            cleaned_part = part\n        cleaned_parts.append(cleaned_part)\n    return '.'.join(cleaned_parts)\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"192.168.042.105\", \"192.168.42.105\"),\n        (\"0.0.0.0\", \"0.0.0.0\"),\n        (\"0001.0.0.0\", \"1.0.0.0\"),\n        (\"1.1.1.1\", \"1.1.1.1\"),\n        (\"01.01.01.01\", \"1.1.1.1\"),\n    ]\n    \n    all_passed = True\n    for ip, expected in test_cases:\n        result = clean_ip_address(ip)\n        if result != expected:\n            print(f\"Test failed for {ip}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\ncheck()"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    # Initialize variables to store the first even and first odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and first odd numbers\n    for num in lst:\n        if num % 2 == 0:  # Check if the number is even\n            if first_even is None:\n                first_even = num\n        else:  # The number is odd\n            if first_odd is None:\n                first_odd = num\n    \n    # Calculate the difference between the first even and first odd numbers\n    return first_even - first_odd if first_even is not None and first_odd is not None else None\n\n# Test the function with the provided test case\nassert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"}
{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(test_tuple):\n    # Calculate the size of the tuple in bytes\n    return sys.getsizeof(test_tuple)\n\n# Test the function with the provided test case\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))"}
{"task_id": "Mbpp/597", "solution": "def find_kth_element(nums1, nums2, k):\n    \"\"\"\n    Finds the k-th smallest element in the union of two sorted arrays.\n    \n    Args:\n    nums1: List[int], the first sorted array.\n    nums2: List[int], the second sorted array.\n    k: int, the k-th position to find in the merged array.\n    \n    Returns:\n    int, the k-th smallest element in the merged array.\n    \"\"\"\n    if not nums1:\n        return nums2[k-1]\n    if not nums2:\n        return nums1[k-1]\n    if k == 1:\n        return min(nums1[0], nums2[0])\n    \n    mid1 = nums1[k // 2 - 1] if k // 2 <= len(nums1) else float('inf')\n    mid2 = nums2[k // 2 - 1] if k // 2 <= len(nums2) else float('inf')\n    \n    if mid1 < mid2:\n        return find_kth_element(nums1[k // 2:], nums2, k - k // 2)\n    else:\n        return find_kth_element(nums1, nums2[k // 2:], k - k // 2)\n\n# Test cases to verify the solution\ndef check_solution():\n    test_cases = [([1, 3], [2], 2, 2), ([1, 2], [3, 4], 4, 4), ([1, 3], [2], 1, 1), ([1, 3], [2], 3, 3)]\n    all_passed = True\n    for nums1, nums2, k, expected in test_cases:\n        result = find_kth_element(nums1, nums2, k)\n        if result != expected:\n            print(f\"Failed for nums1={nums1}, nums2={nums2}, k={k}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    # Calculate the number of digits in the number\n    num_digits = len(str(n))\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum([int(digit) ** num_digits for digit in str(n)])\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == n\n\n# Test the function with the provided test case\nassert armstrong_number(153) == True"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    # Calculate the sum of the first n natural numbers\n    total_sum = n * (n + 1) // 2\n    # Calculate the average of the first n natural numbers\n    average = total_sum / n\n    return total_sum, average\n\n# Test the function with the provided test case\ndef check():\n    test_n = 10\n    expected_output = (55, 5.5)\n    result = sum_average(test_n)\n    assert result == expected_output, f\"Expected {expected_output}, but got {result}\"\n\n# Call the check function to verify the correctness of the sum_average function\ncheck()"}
{"task_id": "Mbpp/600", "solution": "def is_Even(n):\n    # Check if the number is divisible by 2\n    return n % 2 == 0\n\n# Test the function with the provided test case\nassert is_Even(1) == False"}
{"task_id": "Mbpp/602", "solution": "def find_first_repeated_character(s):\n    \"\"\"\n    Finds the first repeated character in the given string.\n    \n    Args:\n    s (str): The string to check for repeated characters.\n    \n    Returns:\n    str: The first repeated character, or None if no repetition is found.\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [\n        (\"programming\", \"r\"),\n        (\"python\", None),\n        (\"aabbcc\", \"a\"),\n        (\"\", None),\n        (\"hello world\", \"l\")\n    ]\n    \n    all_passed = True\n    for text, expected in test_cases:\n        result = find_first_repeated_character(text)\n        if result != expected:\n            print(f\"Test failed for input: {text}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"task_id": "Mbpp/603", "solution": "def ludic_sort(numbers):\n    \"\"\"\n    Remove ludic numbers at every nth index within the list.\n    \n    Parameters:\n    numbers (list): A list of integers representing ludic numbers.\n    \n    Returns:\n    list: A list of integers after removing ludic numbers at every nth index.\n    \"\"\"\n    index = 0\n    while index < len(numbers):\n        step = numbers[index]\n        # Remove every nth number starting from the current index\n        numbers = [numbers[i] for i in range(len(numbers)) if (i + 1) % step != 0]\n        index += 1\n    return numbers\n\n# Check function to verify the correctness of the generated function\ndef check():\n    test_cases = [([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 20]),\n                  ([1, 1, 1, 1], [1, 1, 1, 1]),\n                  ([2, 3, 5], [2, 3, 5])]\n    all_passed = True\n    for input_list, expected_output in test_cases:\n        actual_output = ludic_sort(input_list)\n        if actual_output != expected_output:\n            print(f\"Test failed for input {input_list}. Expected {expected_output}, got {actual_output}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(str1):\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(str1.split()[::-1])\n\n# Test the function with the provided test case\nassert reverse_words(\"python program\") == \"program python\""}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    # Check if n is less than 2, which are not prime numbers\n    if n < 2:\n        return False\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert prime_num(13) == True"}
{"task_id": "Mbpp/606", "solution": "def radian_degree(degrees):\n    # Convert degrees to radians\n    radians = degrees * (3.141592653589793 / 180)\n    return radians\n\n# Test the function with the provided test case\nassert radian_degree(90) == 1.5707963267948966"}
{"task_id": "Mbpp/607", "solution": "import re\n\ndef find_literals(text, pattern):\n    # Use re.search to find the pattern in the text\n    match = re.search(pattern, text)\n    # If a match is found, return the matched substring and its start and end indices\n    if match:\n        return (match.group(), match.start(), match.end())\n    # If no match is found, return None\n    else:\n        return None\n\n# Test the function with the provided test case\nassert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for i in range(n+1)] for i in range(n+1)]\n    \n    # Base case\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        # Explicitly fill for small n\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the nth Bell number\n    return bell[n][0]\n\n# Test the function with the provided test case\nassert bell_Number(2) == 2"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and adjusts the indices of the remaining elements.\n    \n    Parameters:\n    lst (list): The list from which to remove the k'th element.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed and indices adjusted.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # k is out of bounds, return the original list\n    \n    # Create a new list excluding the k'th element\n    result = [lst[i] for i in range(len(lst)) if i < k-1 or i >= k]\n    return result\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([1, 2, 3, 4], 2, [1, 3, 4]),\n                  ([10, 20, 30, 40, 50], 3, [10, 20, 40, 50]),\n                  ([5, 15, 25], 1, [15, 25]),\n                  ([1, 2, 3], 4, [1, 2, 3]),\n                  ([], 1, []),\n                  ([7], 1, [])]\n    \n    all_passed = True\n    for i, (lst, k, expected) in enumerate(test_cases):\n        result = remove_kth_element(lst, k)\n        if result != expected:\n            print(f\"Test case {i+1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    # Initialize the max value to a very low number\n    max_value = float('-inf')\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Check if the current row has enough elements\n        if n < len(row):\n            # Update max_value if the current element in the nth column is greater\n            max_value = max(max_value, row[n])\n    return max_value\n\n# Test the function with the provided test case\nassert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19"}
{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    # Initialize two empty lists to hold the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate through each sublist in the input list\n    for sub_list in lst:\n        # Append the first element of the sublist to the first_elements list\n        first_elements.append(sub_list[0])\n        # Append the second element of the sublist to the second_elements list\n        second_elements.append(sub_list[1])\n    \n    # Return a list containing the two lists: first_elements and second_elements\n    return [first_elements, second_elements]\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(lst):\n    # Calculate the sum of all elements in the tuple list\n    total_sum = sum(sum(t) for t in lst)\n    return total_sum\n\n# Test the function to ensure it works as expected\nassert cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30"}
{"task_id": "Mbpp/615", "solution": "def calculate_averages(tuples):\n    \"\"\"\n    Calculate the average of each tuple in the input.\n    \n    Args:\n    tuples (tuple): A tuple containing multiple tuples of numbers.\n    \n    Returns:\n    tuple: A tuple containing the average of each input tuple.\n    \"\"\"\n    averages = []\n    for t in tuples:\n        if all(isinstance(x, (int, float)) for x in t):\n            averages.append(sum(t) / len(t))\n        else:\n            averages.append(None)\n    return tuple(averages)\n\n# Test cases to verify the correctness of the function\ndef check():\n    test_cases = [(((),), ()), \n                  (([1, 2, 3],), (2.0,)), \n                  (([1.5, 2.5, 3.5],), (2.5,)), \n                  (([1, 2, 3, 4],), (2.5,)), \n                  (([10, 20, 30],), (20.0,))]\n    \n    all_passed = True\n    for inputs, expected in test_cases:\n        result = calculate_averages(inputs)\n        if result != expected:\n            print(f\"Failed for {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple_a, tuple_b):\n    # Use a generator expression to perform element-wise modulo operation\n    result = tuple(a % b for a, b in zip(tuple_a, tuple_b))\n    return result\n\n# Test the function with the provided test case\ndef check():\n    test_tuple_a = (10, 4, 5, 6)\n    test_tuple_b = (5, 6, 7, 5)\n    expected_output = (0, 4, 5, 1)\n    \n    if tuple_modulo(test_tuple_a, test_tuple_b) == expected_output:\n        print(\"Test passed.\")\n    else:\n        print(\"Test failed.\")\n\ncheck()"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    # Check if lists are of the same length\n    if len(list1) != len(list2):\n        return \"Lists are of different lengths.\"\n    # Use a list comprehension to divide elements of list1 by elements of list2\n    result = [i / j for i, j in zip(list1, list2)]\n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/619", "solution": "def move_num(str1):\n    # Extract all non-digit characters and all digit characters separately\n    non_digit = [char for char in str1 if not char.isdigit()]\n    digits = [char for char in str1 if char.isdigit()]\n    # Concatenate non-digit characters with digit characters\n    return ''.join(non_digit + digits)\n\n# Test the function with the provided test case\nassert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"}
{"task_id": "Mbpp/620", "solution": "def check_divisibility(numbers):\n    \"\"\"\n    Check if all numbers in the list are divisible by 3 or 5.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    bool: True if all numbers are divisible by 3 or 5, False otherwise.\n    \"\"\"\n    return all(num % 3 == 0 or num % 5 == 0 for num in numbers)\n\n# Test cases to verify the correctness of the function\ndef test_check_divisibility():\n    test_cases = [\n        ([3, 5, 9], True),\n        ([3, 4, 5], True),\n        ([1, 2, 3], False),\n        ([15, 30, 45], True),\n        ([10, 20, 33], True),\n        ([1, 2, 3, 4, 5], True),\n        ([1, 2, 4, 7], False),\n        ([15, 30, 45, 60], True),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9], True),\n        ([1, 2, 4, 7, 11], False)\n    ]\n    \n    all_passed = True\n    for numbers, expected in test_cases:\n        result = check_divisibility(numbers)\n        if result != expected:\n            print(f\"Test failed for input {numbers}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Run the test function\ntest_check_divisibility()"}
{"task_id": "Mbpp/622", "solution": "def findMedianSortedArrays(nums1, nums2):\n    \"\"\"\n    Finds the median of two sorted arrays.\n    \n    :param nums1: List[int] - First sorted array.\n    :param nums2: List[int] - Second sorted array.\n    :return: float - The median of the two sorted arrays.\n    \"\"\"\n    # Merge the two sorted arrays\n    merged = []\n    i, j = 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    # Append remaining elements\n    while i < len(nums1):\n        merged.append(nums1[i])\n        i += 1\n    while j < len(nums2):\n        merged.append(nums2[j])\n        j += 1\n    \n    # Calculate the median\n    n = len(merged)\n    if n % 2 == 1:\n        return merged[n // 2]\n    else:\n        return (merged[n // 2 - 1] + merged[n // 2]) / 2\n\n# Example usage:\n# nums1 = [1, 3]\n# nums2 = [2]\n# print(findMedianSortedArrays(nums1, nums2))  # Output: 2.0"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(lst, n):\n    # Use list comprehension to raise each element to the power of n\n    return [i**n for i in lst]\n\n# Test the function with the provided test case\nassert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "Mbpp/624", "solution": "def is_upper(string):\n    # Convert the given string to uppercase\n    return string.upper()\n\n# Test the function with the provided test case\nassert is_upper(\"person\") == \"PERSON\""}
{"task_id": "Mbpp/626", "solution": "def triangle_area(radius):\n    # Return None for negative radius as radius cannot be negative\n    if radius < 0:\n        return None\n    # Area of the largest inscribed triangle in a semicircle is (radius^2)\n    return radius ** 2\n\n# Test the function with the provided test case\nassert triangle_area(-1) == None"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    # Replace all spaces in the string with '%20'\n    return string.replace(' ', '%20')\n\n# Test the function with the provided test case\nassert replace_spaces(\"My Name is Dawood\") == 'My%20Name%20is%20Dawood'"}
{"task_id": "Mbpp/629", "solution": "def Split(numbers):\n    # Use list comprehension to filter even numbers\n    return [num for num in numbers if num % 2 == 0]\n\n# Test the function with the provided test case\nassert Split([1, 2, 3, 4, 5]) == [2, 4]"}
{"task_id": "Mbpp/630", "solution": "def find_adjacent_coordinates(grid, position):\n    \"\"\"\n    Given a 2D grid represented as a list of tuples and a position as a tuple,\n    returns a list of tuples representing the valid adjacent coordinates to the given position.\n    Valid adjacent coordinates are those that are within the bounds of the grid and are not the same as the given position.\n    \n    :param grid: List of tuples representing the 2D grid.\n    :param position: Tuple representing the current position (row, column).\n    :return: List of tuples representing the valid adjacent coordinates.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    (row, col) = position\n    adjacent_coords = []\n\n    # Define possible adjacent positions (up, down, left, right, diagonals)\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue  # Skip the current position\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                adjacent_coords.append((new_row, new_col))\n\n    return adjacent_coords\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    grid = [(0, 0), (1, 1), (2, 2), (3, 3)]\n    position = (1, 1)\n    expected = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2)]\n    result = find_adjacent_coordinates(grid, position)\n    print(\"Test passed\" if sorted(result) == sorted(expected) else \"Test failed\")\n\ncheck_solution()"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(str1):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in str1:\n        if char == ' ':\n            result += '_'\n        else:\n            result += ' ' if char == '_' else char\n    return result\n\n# Test the function with the provided test case\nassert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"}
{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    # Create a new list to store non-zero elements\n    non_zero = [element for element in lst if element != 0]\n    # Append zeros to the end of the non-zero list\n    non_zero.extend([0] * lst.count(0))\n    return non_zero\n\n# Test the function with the provided test case\nassert move_zero([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(arr, n): \n    # Calculate the sum of XOR for all pairs\n    xor_sum = 0\n    for i in range(n): \n        for j in range(i + 1, n): \n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum\n\n# Test the function with the provided test case\nassert pair_xor_Sum([5,9,7,6], 4) == 47"}
{"task_id": "Mbpp/635", "solution": "def heap_sort(nums):\n    # Function to heapify a subtree rooted with node i which is an index in nums[]\n    def heapify(nums, n, i):\n        largest = i  # Initialize largest as root\n        left = 2 * i + 1  # left = 2*i + 1\n        right = 2 * i + 2  # right = 2*i + 2\n\n        # See if left child of root exists and is greater than root\n        if left < n and nums[i] < nums[left]:\n            largest = left\n\n        # See if right child of root exists and is greater than root\n        if right < n and nums[largest] < nums[right]:\n            largest = right\n\n        # Change root, if needed\n        if largest != i:\n            nums[i], nums[largest] = nums[largest], nums[i]  # swap\n\n            # Heapify the root.\n            heapify(nums, n, largest)\n\n    # Build a maxheap.\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        nums[i], nums[0] = nums[0], nums[i]  # swap\n        heapify(nums, i, 0)\n\n    return nums\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    # Check if cost price is equal to selling price\n    if cost_price == selling_price:\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert noprofit_noloss(1500, 1200) == False"}
{"task_id": "Mbpp/638", "solution": "def wind_chill(speed, temperature):\n    # Wind chill formula for Fahrenheit\n    if speed <= 3 and temperature <= 50:\n        wind_chill_index = 35.74 + 0.6215 * temperature - 35.75 * (speed ** 0.16) + 0.4275 * temperature * (speed ** 0.16)\n    else:\n        wind_chill_index = temperature\n    return round(wind_chill_index, 2)\n\n# Test cases to verify the solution\ndef check_wind_chill():\n    test_cases = [\n        (120, 35, -17.78),  # Example test case provided in the problem statement\n        (5, 10, 9.0),       # Additional test case\n        (10, 0, 10.83),     # Additional test case\n        (20, -10, 14.4),    # Additional test case\n        (30, -20, 40.6)     # Additional test case\n    ]\n    \n    all_passed = True\n    for speed, temperature, expected in test_cases:\n        result = wind_chill(speed, temperature)\n        if result != expected:\n            print(f\"Test failed for speed={speed}, temperature={temperature}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Call the check function to verify the solution\ncheck_wind_chill()"}
{"task_id": "Mbpp/639", "solution": "def filter_lowercase_names(names):\n    \"\"\"\n    Filters and returns names that start with a lowercase letter.\n    \n    :param names: List of names (strings)\n    :return: List of names starting with a lowercase letter\n    \"\"\"\n    return [name for name in names if name[0].islower()]\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        ([\"apple\", \"Banana\", \"cherry\", \"date\"], [\"apple\", \"cherry\", \"date\"]),\n        ([\"grape\", \"Orange\", \"plum\", \"fig\"], [\"grape\", \"plum\", \"fig\"]),\n        ([\"kiwi\", \"Lemon\", \"mango\", \"lime\"], [\"kiwi\", \"mango\", \"lime\"]),\n        ([\"pear\", \"Peach\", \"peach\", \"plum\"], [\"pear\", \"peach\", \"plum\"]),\n        ([\"fig\", \"fig\", \"fig\"], [\"fig\", \"fig\", \"fig\"])\n    ]\n    \n    all_passed = True\n    for names, expected in test_cases:\n        result = filter_lowercase_names(names)\n        if result != expected:\n            print(f\"Test failed for: {names}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check_function()"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    # Calculate the nth nonagonal number using the formula\n    nonagonal_number = (7 * n * n - 5 * n) // 2\n    return nonagonal_number\n\n# Test the function with the provided test case\nassert is_nonagonal(10) == 325"}
{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(text):\n    # Check if 'z' is present in the string excluding the first and last character\n    return 'z' in text[1:-1]\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements from the start of the array up to the position k\n    arr[:k] = reversed(arr[:k])\n    return arr\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(test_tuple, test_dict):\n    # Add the dictionary to the tuple\n    result = test_tuple + (test_dict,)\n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/721", "solution": "def find_max_average_path(matrix):\n    \"\"\"\n    Finds the maximum average path in a given 2D matrix. The path can start from any cell and move\n    horizontally or vertically to adjacent cells. The function returns the maximum average of the path.\n    \n    :param matrix: List[List[int]] - 2D matrix of integers.\n    :return: float - Maximum average of the path.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0.0\n\n    rows, cols = len(matrix), len(matrix[0])\n    max_avg = float('-inf')\n\n    def dfs(x, y, current_sum, path_length):\n        nonlocal max_avg\n        if path_length > max_avg:\n            max_avg = path_length\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_sum = current_sum + matrix[nx][ny]\n                dfs(nx, ny, new_sum, path_length + 1)\n\n    for i in range(rows):\n        for j in range(cols):\n            dfs(i, j, matrix[i][j], 1)\n\n    return max_avg / max_avg if max_avg != float('-inf') else 0.0\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [([[-1, 3, -3], [2, -2, 4], [5, 6, -6]], 0.05555555555555556),\n                  ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5.0)]\n    \n    all_passed = True\n    for matrix, expected in test_cases:\n        result = find_max_average_path(matrix)\n        if not math.isclose(result, expected, rel_tol=1e-9):\n            print(f\"Test failed for: {matrix}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your solution.\")\n\ncheck_solution()"}
{"task_id": "Mbpp/722", "solution": "def calculate_average_height_weight(students):\n    \"\"\"\n    Calculate the average height and weight of students given in a dictionary.\n    The dictionary has student names as keys and their heights and weights as values,\n    where heights and weights are represented as tuples (height, weight).\n\n    Args:\n    students (dict): A dictionary with student names as keys and (height, weight) as values.\n\n    Returns:\n    tuple: A tuple containing the average height and weight as floats.\n    \"\"\"\n    total_height = 0\n    total_weight = 0\n    student_count = 0\n\n    for name, (height, weight) in students.items():\n        total_height += height\n        total_weight += weight\n        student_count += 1\n\n    if student_count == 0:\n        return (0.0, 0.0)\n\n    average_height = total_height / student_count\n    average_weight = total_weight / student_count\n\n    return (average_height, average_weight)\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [\n        ({\"Alice\": (160, 55), \"Bob\": (175, 70), \"Charlie\": (165, 60)}, (165.0, 60.0)),\n        ({\"Dave\": (180, 80), \"Eve\": (170, 65)}, (175.0, 72.5)),\n        ({\"Frank\": (155, 50)}, (155.0, 50.0)),\n        ({}, (0.0, 0.0))\n    ]\n\n    all_passed = True\n    for students, expected in test_cases:\n        result = calculate_average_height_weight(students)\n        if result != expected:\n            print(f\"Test failed for: {students}. Expected {expected}, got {result}\")\n            all_passed = False\n\n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    # Initialize a counter to keep track of the indices with matching values\n    count = 0\n    # Iterate through the lists and compare elements at each index\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    # Calculate the power of the base\n    num = base ** power\n    # Convert the number to a string to iterate over each digit\n    num_str = str(num)\n    # Calculate the sum of the digits\n    sum_of_digits = sum(int(digit) for digit in num_str)\n    return sum_of_digits\n\n# Test the function with the provided test case\nassert power_base_sum(2, 100) == 115"}
{"task_id": "Mbpp/725", "solution": "def extract_quoted_text(text):\n    \"\"\"\n    Extracts text within single or double quotation marks from the given string.\n    \n    Args:\n    text (str): The string to extract text from.\n    \n    Returns:\n    list: A list of strings containing the text within quotation marks.\n    \"\"\"\n    result = []\n    i = 0\n    n = len(text)\n    while i < n:\n        # Check for single or double quotes\n        if text[i] in ('\"', \"'\"):\n            quote = text[i]\n            i += 1\n            # Find the matching closing quote\n            j = i\n            count = 0\n            while j < n:\n                if text[j] == quote:\n                    count += 1\n                elif text[j] == \"'\":\n                    if count % 2 == 0:\n                        break\n                elif text[j] == '\"':\n                    if count % 2 == 0:\n                        break\n                j += 1\n            if j < n:\n                result.append(text[i:j+1])\n                i = j + 1\n        else:\n            i += 1\n    return result\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"Hello 'world' and \\\"python\\\"!\", [\"'world'\", '\"python\"']),\n        (\"Test 'single' and \\\"double\\\" quotes.\", [\"'single'\", '\"double\"']),\n        ('No quotes here.', []),\n        ('\"Quotes\" and \"more quotes\".', ['\"Quotes\"', '\"more quotes\"']),\n        (\"'Nested \\\"quotes\\\"'.\", [\"'Nested \\\"quotes\\\"'\"])\n    ]\n    \n    all_passed = True\n    for text, expected in test_cases:\n        result = extract_quoted_text(text)\n        if result != expected:\n            print(f\"Test failed for: {text}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\ncheck()"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through the tuple, stopping at the second last element\n    for i in range(len(t) - 1):\n        # Multiply the current element with the next one and append to the result list\n        result.append(t[i] * t[i + 1])\n    # Convert the result list to a tuple and return it\n    return tuple(result)\n\n# Test the function with the provided test case\nassert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    # Check if both lists have the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    # Sum the corresponding elements of the lists\n    return [a + b for a, b in zip(list1, list2)]\n\n# Test the function with the provided test case\ndef check():\n    test_output = sum_list([10, 20, 30], [15, 25, 35])\n    expected_output = [25, 45, 65]\n    assert test_output == expected_output, f\"Expected {expected_output}, but got {test_output}\"\n\n# Call the check function to verify the correctness\ncheck()"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    # Initialize an empty list to store the result\n    result = []\n    # Append the first element of the list to the result\n    if lst:\n        result.append(lst[0])\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(lst)):\n        # If the current element is not the same as the last element in the result, append it\n        if lst[i] != lst[i-1]:\n            result.append(lst[i])\n    \n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/731", "solution": "import math\n\ndef lateralsurface_cone(r, h):\n    # Calculate the lateral surface area of a cone\n    lateral_surface_area = math.pi * r * math.sqrt(r * r + h * h)\n    return lateral_surface_area\n\n# Test the function with the provided test case\nassert lateralsurface_cone(5, 12) == 204.20352248333654"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(input_str):\n    # Replace spaces, commas, and dots with a colon\n    result = input_str.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result\n\n# Test the function with the provided test case\nassert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    # Initialize the start and end pointers\n    start, end = 0, len(arr) - 1\n    \n    # Loop until the start pointer exceeds the end pointer\n    while start <= end:\n        mid = start + (end - start) // 2  # Calculate the middle index\n        \n        # Check if the middle element is the target\n        if arr[mid] == target:\n            # If it's the first element or the previous element is not the target, return mid\n            if mid == 0 or arr[mid - 1] != target:\n                return mid\n            else:\n                # Otherwise, continue searching in the left half\n                end = mid - 1\n        elif arr[mid] < target:\n            # If the middle element is less than the target, search in the right half\n            start = mid + 1\n        else:\n            # If the middle element is greater than the target, search in the left half\n            end = mid - 1\n    \n    # If the target is not found, return -1\n    return -1\n\n# Test the function with the provided test case\nassert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(arr):\n    # Initialize the sum to 0\n    sum_prod = 0\n    # Iterate over all possible subarray lengths\n    for i in range(len(arr)):\n        product = 1\n        for j in range(i, len(arr)):\n            product *= arr[j]\n            sum_prod += product\n    return sum_prod\n\n# Test the function with the provided test case\nassert sum_Of_Subarray_Prod([1, 2, 3]) == 20"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    # Input validation to ensure n is an integer\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    # Handle negative numbers by converting them to positive\n    n = abs(n)\n    \n    # Calculate the number of bits in n\n    num_bits = n.bit_length()\n    \n    # Define the mask to toggle the middle bits\n    if num_bits % 2 == 0:\n        mask = (1 << (num_bits // 2)) - 1\n    else:\n        mask = (1 << (num_bits // 2 + 1)) - 1\n    \n    # Toggle the middle bits using XOR\n    result = n ^ mask\n    \n    return result\n\n# Example usage:\n# print(toggle_middle_bits(10))  # Output: 5\n# print(toggle_middle_bits(-10)) # Output: 5"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(lst, num):\n    # Iterate through the list to find the correct insertion point\n    for i in range(len(lst)):\n        if lst[i] >= num:\n            return i\n    # If the number is greater than all elements, return the length of the list\n    return len(lst)\n\n# Test the function with the provided test case\nassert left_insertion([1,2,4,5], 6) == 4"}
{"task_id": "Mbpp/737", "solution": "import re\n\ndef check_str(string):\n    # Check if the string starts with a vowel using regex\n    return bool(re.match(r'^[aeiouAEIOU]', string))\n\n# Test the function with the provided test case\nassert check_str(\"annie\") == True"}
{"task_id": "Mbpp/739", "solution": "def find_Index(arr, target):\n    \"\"\"\n    Finds the index of the target value in the given array.\n    If the target is not found, returns -1.\n    Handles invalid inputs by returning -1.\n    \"\"\"\n    if not isinstance(arr, list) or not all(isinstance(x, (int, float)) for x in arr):\n        return -1\n    if not isinstance(target, (int, float)):\n        return -1\n    \n    try:\n        return arr.index(target)\n    except ValueError:\n        return -1\n\n# Test cases to verify the correctness of the function\ndef check():\n    test_cases = [\n        ([1, 2, 3, 4, 5], 3, 2),\n        ([10, 20, 30, 40, 50], 20, 1),\n        ([1, 2, 3], 4, -1),\n        ([], 1, -1),\n        ([1, 2, 3], 0, -1),\n        ([-1, 0, 1], -1, 0),\n        (['a', 'b', 'c'], 'b', 1),\n        (['a', 'b', 'c'], 'd', -1),\n        (['a', 'b', 'c'], 'a', 0),\n        (['a', 'b', 'c'], 'c', 2),\n    ]\n    \n    all_passed = True\n    for arr, target, expected in test_cases:\n        result = find_Index(arr, target)\n        if result != expected:\n            print(f\"Test failed for: {arr}, {target}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary\n    res = {}\n    # Iterate through the tuple, stepping by 2 to get key-value pairs\n    for idx in range(0, len(test_tup) - 1, 2):\n        res[test_tup[idx]] = test_tup[idx + 1]\n    return res\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(str1):\n    # Check if the string is empty or has only one character\n    if len(str1) <= 1:\n        return True\n    # Compare the first character with the rest of the string\n    for i in range(1, len(str1)):\n        if str1[0] != str1[i]:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert all_Characters_Same(\"python\") == False"}
{"task_id": "Mbpp/742", "solution": "import math\n\ndef area_tetrahedron(side_length):\n    # Calculate the area of a tetrahedron given the side length\n    area = math.sqrt(3) * (side_length ** 2)\n    return area\n\n# Test the function with the provided test case\nassert math.isclose(area_tetrahedron(3), 15.588457268119894), \"The calculated area is incorrect.\""}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    # Handle the case where the list is empty or n is 0\n    if not lst or n == 0:\n        return lst\n    # Normalize the rotation count in case it's greater than the list length\n    n = n % len(lst)\n    # Rotate the list by slicing and concatenating\n    return lst[-n:] + lst[:-n]\n\n# Test the function with the provided test case\nassert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"}
{"task_id": "Mbpp/744", "solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(item is None for item in test_tup)\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/745", "solution": "def find_max_product_pair(numbers):\n    \"\"\"\n    Finds the pair of numbers in the list that yields the maximum product.\n    \n    Args:\n    numbers: A list of integers.\n    \n    Returns:\n    A tuple containing the pair of numbers that yield the maximum product.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # Not enough numbers to form a pair\n    \n    max_product = float('-inf')\n    max_pair = (None, None)\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            product = numbers[i] * numbers[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (numbers[i], numbers[j])\n                \n    return max_pair\n\n# Test cases to verify the solution\ndef check_solution():\n    test_cases = [\n        ([1, 10, -5, 1, -100], (10, -100)),\n        ([5, 1, 9, 2, 6], (9, 6)),\n        ([1, 2, 3, 4], (3, 4)),\n        ([0, 2, 3, 6, -1, 2, 2], (3, 6)),\n        ([1, 11, 3, 4, 5, 6], (11, 6)),\n        ([1, 22], (22, 1)),  # Corrected failed input\n        ([100, 200], (100, 200))  # Corrected failed input\n    ]\n    \n    all_passed = True\n    for nums, expected in test_cases:\n        result = find_max_product_pair(nums)\n        if result != expected:\n            print(f\"Failed for {nums}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your solution.\")\n\n# Run the check function to verify the solution\ncheck_solution()"}
{"task_id": "Mbpp/748", "solution": "def split_words(text):\n    \"\"\"\n    Splits a given string into words based on capital letters.\n    \n    Args:\n    text (str): The string to be split.\n    \n    Returns:\n    list: A list of words split based on capital letters.\n    \"\"\"\n    words = []\n    current_word = \"\"\n    \n    for i, char in enumerate(text):\n        if char.isupper():\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n            current_word += char\n        else:\n            current_word += char\n            \n    if current_word:\n        words.append(current_word)\n        \n    return words\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        (\"HelloWorld\", [\"Hello\", \"World\"]),\n        (\"SplitCamelCase\", [\"Split\", \"Camel\", \"Case\"]),\n        (\"AnotherExample\", [\"Another\", \"Example\"]),\n        (\"NoSplit\", [\"NoSplit\"]),\n        (\"\", []),\n        (\"ALLCAPS\", [\"ALLCAPS\"]),\n        (\"lowercase\", [\"lowercase\"])\n    ]\n    \n    all_passed = True\n    for text, expected in test_cases:\n        result = split_words(text)\n        if result != expected:\n            print(f\"Test failed for: {text}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Running the check function to verify the solution\ncheck_function()"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(strings):\n    \"\"\"\n    Sorts a list of strings that represent numbers, ignoring the decimal points.\n    \n    Example:\n    >>> sort_numeric_strings(['1', '4.5', '3.2', '2'])\n    ['1', '2', '3.2', '4.5']\n    \"\"\"\n    return sorted(strings, key=lambda s: float(s.replace('.', '')))\n\n# Test cases to verify the solution\ndef check():\n    test_cases = [\n        (['1', '4.5', '3.2', '2'], ['1', '2', '3.2', '4.5']),\n        (['10.1', '2.5', '3.3', '1.1'], ['1.1', '2.5', '3.3', '10.1']),\n        (['0.9', '0.1', '0.01', '0.10'], ['0.01', '0.1', '0.10', '0.9']),\n    ]\n    \n    all_passed = True\n    for input_data, expected in test_cases:\n        result = sort_numeric_strings(input_data)\n        if result != expected:\n            print(f\"Test failed for input {input_data}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Run the check function to verify the solution\ncheck()"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements of the tuple\n    lst.extend(tpl)\n    return lst\n\n# Test the function to ensure it works as expected\nassert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    # Iterate through the array to check the heap property\n    for i in range(len(arr)):\n        # Check if the left child index is within bounds\n        if (2 * i + 1) < len(arr) and arr[i] > arr[2 * i + 1]:\n            return False\n        # Check if the right child index is within bounds\n        if (2 * i + 2) < len(arr) and arr[i] > arr[2 * i + 2]:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert check_min_heap([1, 2, 3, 4, 5, 6]) == True"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number using an iterative approach.\n    \n    :param n: The position in the Jacobsthal sequence.\n    :return: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + 2 * b\n    return b\n\n# Test cases to verify the correctness of the function\ndef check_jacobsthal():\n    test_cases = [(0, 0), (1, 1), (2, 1), (3, 3), (4, 5), (5, 11)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = jacobsthal_num(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the line below to run the test function\n# check_jacobsthal()"}
{"task_id": "Mbpp/753", "solution": "def min_k(test_list, K): \n    # Sort the list of tuples based on the second element of each tuple\n    # and then select the first K elements from the sorted list.\n    res = sorted(test_list, key=lambda x: x[1])[:K] \n    return res\n\n# Test the function with the provided test case\nassert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    # Determine the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(nums):\n    # Initialize the smallest and second smallest to infinity\n    smallest = second_smallest = float('inf')\n    \n    for num in nums:\n        if num < smallest:\n            # Update second smallest before updating smallest\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            # Update second smallest if num is between smallest and second smallest\n            second_smallest = num\n    \n    # If second smallest is still infinity, it means there wasn't a second unique smallest number\n    return second_smallest if second_smallest != float('inf') else None\n\n# Test the function with the provided test case\nassert second_smallest([1, 2, -8, -2, 0, -2]) == -2"}
{"task_id": "Mbpp/757", "solution": "def flatten_and_sum(input_list):\n    \"\"\"\n    This function takes a single list as input and returns the sum of all the numbers in the list.\n    It handles nested lists by flattening them before summing the numbers.\n    \n    Example:\n    >>> flatten_and_sum([1, 2, [3, 4], [5, 6]])\n    21\n    \"\"\"\n    total = 0\n    for item in input_list:\n        if isinstance(item, list):\n            total += flatten_and_sum(item)\n        else:\n            total += item\n    return total\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [([1, 2, [3, 4], [5, 6]], 21),\n                  ([], 0),\n                  ([10, 20, 30], 60),\n                  ([1, [2, [3, [4, [5]]]]], 15)]\n    \n    all_passed = True\n    for input_list, expected in test_cases:\n        result = flatten_and_sum(input_list)\n        if result != expected:\n            print(f\"Test failed for input {input_list}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the following line to run the check function\n# check_function()"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    # Initialize a dictionary to store the count of each tuple\n    count_dict = {}\n    # Iterate through each sublist in the provided list\n    for sublist in lst:\n        # Convert the sublist to a tuple and count its occurrences\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict\n\n# Test the function with the provided test case\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}"}
{"task_id": "Mbpp/759", "solution": "def validate_and_process_input(input_data):\n    \"\"\"\n    Validates and processes the input data to ensure it is of the correct type and format.\n    \n    Parameters:\n    - input_data: The data to be validated and processed.\n    \n    Returns:\n    - The processed data if valid, otherwise raises a ValueError.\n    \"\"\"\n    if not isinstance(input_data, (int, float)):\n        raise ValueError(\"Input must be a number.\")\n    \n    # Assuming the task is to return the square of the input number\n    return input_data ** 2\n\n# Example usage and test cases"}
{"task_id": "Mbpp/760", "solution": "def unique_Element(test_list):\n    # Check if all elements in the list are the same by comparing the set length\n    return len(set(test_list)) == 1\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    # Check if the month has 30 days\n    if month in {4, 6, 9, 11}:\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert check_monthnumber_number(6) == True"}
{"task_id": "Mbpp/763", "solution": "def find_max(arr, n):\n    \"\"\"\n    Finds the maximum element in an array.\n    \n    Parameters:\n    arr (list): The array of integers.\n    n (int): The length of the array.\n    \n    Returns:\n    int: The maximum element in the array.\n    \"\"\"\n    max_element = arr[0]\n    for i in range(1, n):\n        if arr[i] > max_element:\n            max_element = arr[i]\n    return max_element\n\n# Test cases to verify the solution\ndef check_solution():\n    test_cases = [([1, 2, 3, 4, 5], 5, 5),\n                  ([10, 20, 30, 40, 50], 5, 50),\n                  ([5, 4, 3, 2, 1], 5, 5),\n                  ([1, 1, 1, 1, 1], 5, 1),\n                  ([100], 1, 100)]\n    \n    all_passed = True\n    for arr, n, expected in test_cases:\n        result = find_max(arr, n)\n        if result != expected:\n            print(f\"Test failed for: {arr}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    # Initialize a counter to count digits\n    count = 0\n    # Iterate through each character in the string\n    for char in string:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    return count\n\n# Test the function with the provided test case\nassert number_ctr('program2bedone') == 1"}
{"task_id": "Mbpp/765", "solution": "def find_nth_polite_number(n):\n    \"\"\"\n    Finds the nth polite number.\n    \n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    The task is to find the nth polite number.\n    \n    Args:\n    n (int): The position of the polite number to find.\n    \n    Returns:\n    int: The nth polite number.\n    \"\"\"\n    count = 0\n    num = 1\n    while True:\n        # Check if the number is polite\n        is_polite = False\n        for i in range(2, num // 2 + 1):\n            if (num % i == 0):\n                is_polite = True\n                break\n        if not (num & (num - 1)) and not is_polite:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(1, 3), (2, 5), (3, 6), (4, 7), (5, 9)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = find_nth_polite_number(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(input_list):\n    # Initialize an empty list to store the pairs\n    pairs = []\n    # Iterate through the list, stopping at the second-to-last element\n    for i in range(len(input_list) - 1):\n        # Append the current element and the next element as a tuple to the pairs list\n        pairs.append((input_list[i], input_list[i + 1]))\n    return pairs\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(arr, target_sum):\n    \"\"\"\n    Counts the number of pairs in the list whose sum is equal to target_sum.\n\n    :param arr: List of integers.\n    :param target_sum: The target sum for pairs.\n    :return: The count of pairs whose sum is equal to target_sum.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] + arr[j] == target_sum:\n                count += 1\n    return count\n\n# Test the function with the provided test case\nassert get_pairs_count([1, 1, 1, 1], 2) == 6"}
{"task_id": "Mbpp/769", "solution": "from typing import List\n\ndef find_intersection(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Finds the intersection of two lists, including duplicates, and returns the result in sorted order.\n    \n    Args:\n    nums1: List[int] - First list of integers.\n    nums2: List[int] - Second list of integers.\n    \n    Returns:\n    List[int] - A list containing the sorted intersection of nums1 and nums2, including duplicates.\n    \"\"\"\n    # Convert the first list to a set to remove duplicates and for O(1) lookups\n    unique_nums1 = set(nums1)\n    # Use a list comprehension to find common elements, including duplicates\n    intersection = [num for num in nums2 if num in unique_nums1]\n    # Sort the result to meet the requirement of the problem statement\n    intersection.sort()\n    return intersection\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [([1, 2, 2, 1], [2, 2], [2, 2]),\n                  ([4, 9, 5], [9, 4, 9, 8, 4], [4, 9]),\n                  ([1, 2, 2, 1, 3], [2, 2], [2, 2]),\n                  ([], [1, 2, 3], []),\n                  ([1, 2, 3], [], [])]\n    \n    all_passed = True\n    for nums1, nums2, expected in test_cases:\n        result = find_intersection(nums1, nums2)\n        if result != expected:\n            print(f\"Test failed for nums1={nums1} and nums2={nums2}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    # Calculate the sum of the fourth power of the first n odd natural numbers\n    return sum(i**4 for i in range(1, 2*n, 2))\n\n# Test the function with the provided test case\nassert odd_num_sum(2) == 82"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    \"\"\"\n    Checks if the brackets in the given expression are balanced.\n    Supports parentheses '()', square brackets '[]', and curly braces '{}'.\n    \n    Args:\n    expression (str): The string containing the brackets to check.\n    \n    Returns:\n    bool: True if the brackets are balanced, False otherwise.\n    \"\"\"\n    # Dictionary to hold matching pairs of brackets\n    matching_bracket = {')': '(', ']': '[', '}': '{'}\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    for char in expression:\n        if char in matching_bracket.values():\n            # If it's an opening bracket, push to stack\n            stack.append(char)\n        elif char in matching_bracket:\n            # If it's a closing bracket and stack is empty or doesn't match the last opening bracket, return False\n            if not stack or stack[-1] != matching_bracket[char]:\n                return False\n            stack.pop()\n    \n    # If stack is empty, all brackets were matched; otherwise, they're not balanced\n    return not stack\n\n# Check function to verify the correctness of the generated function\ndef check():\n    test_cases = [\n        (\"{[()]}\", True),\n        (\"{[}\", False),\n        (\"{()}[{}]\", True),\n        (\"\", True),\n        (\"([]{})\", True),\n        (\"([)]\", False),\n        (\"{[(])}\", False),\n    ]\n    \n    all_passed = True\n    for expression, expected in test_cases:\n        result = check_expression(expression)\n        if result != expected:\n            print(f\"Failed for {expression}: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    # Split the string into words\n    words = string.split()\n    # Filter out words with length k\n    filtered_words = [word for word in words if len(word) != k]\n    # Join the filtered words back into a string\n    result = ' '.join(filtered_words)\n    return result\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/773", "solution": "def find_substring(s1: str, s2: str) -> tuple:\n    \"\"\"\n    Finds the first occurrence of s2 in s1 and returns a tuple containing the substring,\n    its start index, and its end index (exclusive).\n    \n    :param s1: The string to search within.\n    :param s2: The substring to find.\n    :return: A tuple (substring, start_index, end_index) if found, otherwise an empty tuple.\n    \"\"\"\n    if not s2:  # Handle the case where s2 is an empty string\n        return (s2, 0, 0)\n    \n    start_index = s1.find(s2)\n    if start_index == -1:\n        return ()\n    \n    return (s2, start_index, start_index + len(s2))\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"hello world\", \"world\", (\"world\", 6, 11)),\n        (\"hello world\", \"hello\", (\"hello\", 0, 5)),\n        (\"hello world\", \"worlds\", ()),\n        (\"hello world\", \"\", (\"\", 0, 0)),\n        (\"\", \"world\", ()),\n        (\"\", \"\", (\"\", 0, 0)),\n    ]\n    \n    all_passed = True\n    for s1, s2, expected in test_cases:\n        result = find_substring(s1, s2)\n        if result != expected:\n            print(f\"Failed for {s1}, {s2}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Uncomment the following line to run the check function\n# check()"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    \"\"\"\n    This function takes a list of integers and returns the sum of all the integers in the list.\n    \"\"\"\n    return sum(lst)\n\n# Example usage and test cases"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    \"\"\"\n    This function takes a list and returns a new list where consecutive duplicates are packed into sublists.\n    If the input list is empty, it should return an empty list.\n    \"\"\"\n    if not lst:  # Check if the input list is empty\n        return []\n    \n    packed_list = [[lst[0]]]  # Initialize the packed list with the first element\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            packed_list[-1].append(lst[i])  # Append to the last sublist if the current element is the same as the previous\n        else:\n            packed_list.append([lst[i]])  # Start a new sublist if the current element is different\n    \n    return packed_list\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        ([], []),\n        ([1, 1, 2, 2, 2, 3], [[1, 1], [2, 2, 2], [3]]),\n        ([1, 2, 3, 4], [[1], [2], [3], [4]]),\n        ([1, 1, 1, 1, 1], [[1, 1, 1, 1, 1]]),\n        ([1, 2, 2, 3, 3, 3, 4], [[1], [2, 2], [3, 3, 3], [4]])\n    ]\n    \n    all_passed = True\n    for input_list, expected_output in test_cases:\n        actual_output = pack_consecutive_duplicates(input_list)\n        if actual_output != expected_output:\n            print(f\"Test failed for input {input_list}. Expected {expected_output}, got {actual_output}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Run the check function to verify the solution\ncheck()"}
{"task_id": "Mbpp/780", "solution": "from itertools import product\n\ndef sum_tuples(tuples_list):\n    \"\"\"\n    Given a list of tuples, each containing two integers, the function returns a list of new tuples.\n    Each new tuple is the element-wise sum of the corresponding elements from the original tuples.\n    The function ensures that all generated tuples are unique.\n    \n    Example:\n    sum_tuples([(1, 2), (3, 4), (5, 6)]) == [(4, 6), (6, 8), (8, 10), (4, 8), (6, 10), (8, 12)]\n    \"\"\"\n    # Generate all possible pairwise sums\n    summed_tuples = [tuple(x + y for x, y in zip(a, b)) for a, b in product(tuples_list, repeat=2)]\n    \n    # Filter out non-unique tuples\n    unique_summed_tuples = list(set(summed_tuples))\n    \n    return unique_summed_tuples\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([(1, 2), (3, 4), (5, 6)], [(4, 6), (6, 8), (8, 10), (4, 8), (6, 10), (8, 12)]),\n                  ([(0, 1), (1, 0), (1, 1)], [(0, 1), (1, 1), (2, 0), (2, 2)])]\n    \n    all_passed = True\n    for input_data, expected in test_cases:\n        result = sum_tuples(input_data)\n        if sorted(result) != sorted(expected):\n            print(f\"Test failed for input {input_data}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some tests failed. Please review your function.\")\n\n# Uncomment the line below to run the check function\n# check()"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    # Initialize count of divisors\n    count = 0\n    # Iterate from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor\n            count += 1  # Increment count\n            if i != n // i:  # Check if n/i is a different divisor\n                count += 1  # Increment count if so\n    return count % 2 == 0  # Return True if count is even\n\n# Test the function with the provided test case\nassert count_divisors(10) == True"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    # Initialize the sum to 0\n    total_sum = 0\n    # Calculate the number of elements in the array\n    n = len(arr)\n    # Iterate over all possible starting points of subarrays\n    for i in range(n):\n        # Calculate the sum of the current subarray\n        current_sum = 0\n        # Iterate over all possible ending points of subarrays starting from i\n        for j in range(i, n):\n            # Include the current element in the subarray\n            current_sum += arr[j]\n            # Check if the length of the subarray is odd\n            if (j - i + 1) % 2 == 1:\n                # Add the sum of the current subarray to the total sum\n                total_sum += current_sum\n    return total_sum\n\n# Test the function with the provided test case\nassert odd_length_sum([1, 2, 4]) == 14"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and odd numbers\n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        # Stop iteration if both first even and odd numbers are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Calculate the product of the first even and odd numbers\n    return first_even * first_odd if first_even is not None and first_odd is not None else None\n\n# Test the function with the provided test case\nassert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    # Remove the parentheses and split the string by commas\n    tuple_str = tuple_str.strip('()').split(',')\n    # Convert each element to an integer and return as a tuple\n    return tuple(int(num.strip()) for num in tuple_str)\n\n# Test the function with the provided test case\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, val):\n    \"\"\"\n    Find the index where 'val' should be inserted to maintain the sorted order of 'arr'.\n    \n    Parameters:\n    arr (list): A sorted list of elements.\n    val (int): The value to be inserted into the list.\n    \n    Returns:\n    int: The index at which 'val' should be inserted.\n    \"\"\"\n    low, high = 0, len(arr)\n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] <= val:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([1, 3, 5, 6], 5, 2),\n                  ([1, 3, 5, 6], 2, 1),\n                  ([1, 3, 5, 6], 7, 4),\n                  ([1, 3, 5, 6], 0, 0)]\n    \n    all_passed = True\n    for arr, val, expected in test_cases:\n        result = right_insertion(arr, val)\n        if result != expected:\n            print(f\"Failed for {arr} with value {val}. Expected {expected}, got {result}.\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/787", "solution": "def has_three_b_following_a(text):\n    \"\"\"\n    Checks if the string contains at least one 'a' followed by exactly three 'b's.\n    \n    Args:\n    text (str): The string to check.\n    \n    Returns:\n    bool: True if 'a' is followed by exactly three 'b's, False otherwise.\n    \"\"\"\n    # Find all occurrences of 'a' followed by three 'b's\n    matches = [match for match in text.split('a') if match.startswith('bbb')]\n    \n    # Check if there is at least one match\n    return len(matches) > 0\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (\"abbbc\", True),  # 'a' followed by 'bbb'\n    (\"abbbbc\", True), # 'a' followed by 'bbb' and more characters\n    (\"aabbb\", True),  # 'a' followed by 'bbb'\n    (\"abbb\", True),   # 'a' followed by 'bbb'\n    (\"bbbba\", False), # 'a' not directly following 'bbb'\n    (\"bbaaabbb\", True), # 'a' followed by 'bbb' with other characters in between\n    (\"a\", False),     # 'a' without 'bbb'\n    (\"bbb\", False),   # 'bbb' without 'a'\n    (\"\", False),      # Empty string\n]\n\n# Function to check all test cases\ndef check_function():\n    all_passed = True\n    for text, expected in test_cases:\n        result = has_three_b_following_a(text)\n        if result != expected:\n            print(f\"Test failed for: '{text}'. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the line below to run the check function\n# check_function()"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(list1, str1):\n    # Create a new tuple by combining the elements of the list and the string\n    result = tuple(list1) + (str1,)\n    return result\n\n# Test the function to ensure it works as expected\nassert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best')"}
{"task_id": "Mbpp/790", "solution": "def find_even_numbers(lst):\n    \"\"\"\n    This function takes a list of integers and returns a new list containing only the even numbers from the original list.\n    \"\"\"\n    # Initialize an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate through the list using the index\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 == 0:  # Check if the number is even\n            even_numbers.append(lst[i])  # Add even number to the list\n    \n    return even_numbers\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [\n        ([1, 2, 3, 4, 5, 6], [2, 4, 6]),\n        ([10, 15, 20, 25, 30], [10, 20, 30]),\n        ([1, 3, 5, 7], []),\n        ([2, 4, 6, 8, 10], [2, 4, 6, 8, 10]),\n        ([], []),\n    ]\n    \n    all_passed = True\n    for idx, (input_list, expected) in enumerate(test_cases):\n        result = find_even_numbers(input_list)\n        if result != expected:\n            print(f\"Test case {idx + 1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"task_id": "Mbpp/791", "solution": "def find_max_in_tuples(tuples_list):\n    \"\"\"\n    Finds the maximum value in a list of tuples.\n    \n    Args:\n    tuples_list: A list of tuples containing numerical values.\n    \n    Returns:\n    The maximum value found in the list of tuples.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        return None\n    \n    return max(max(t) for t in tuples_list)\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [((1, 2, 3), 3), ((5, 1, 9, 2), 9), ((-1, -2, -3, 0), 0), ((10,), 10), ((1, 1, 1, 1), 1), ([], None)]\n    all_passed = True\n    for i, (input_data, expected) in enumerate(test_cases):\n        result = find_max_in_tuples(input_data)\n        if result != expected:\n            print(f\"Test case {i+1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_function()"}
{"task_id": "Mbpp/792", "solution": "def count_nested_lists(nested_list):\n    \"\"\"\n    Counts the number of lists within a given list, including nested lists.\n    \n    :param nested_list: List containing elements, possibly including other lists.\n    :return: Integer count of all lists within the given list, including nested ones.\n    \"\"\"\n    count = 0\n    for element in nested_list:\n        if isinstance(element, list):\n            count += 1\n            count += count_nested_lists(element)\n    return count\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([1, 2, [3, 4], [5, [6, 7]]], 3),\n                  ([], 0),\n                  ([[[]]], 2),\n                  ([1, 2, 3], 0)]\n    \n    all_passed = True\n    for nested_list, expected in test_cases:\n        result = count_nested_lists(nested_list)\n        if result != expected:\n            print(f\"Test failed for: {nested_list}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()"}
{"task_id": "Mbpp/793", "solution": "def last(arr, x):\n    # Initialize the result variable to -1\n    result = -1\n    # Iterate through the array\n    for i in range(len(arr)):\n        # If the current element matches the target element, update result\n        if arr[i] == x:\n            result = i\n    # Return the last position of the target element\n    return result\n\n# Test the function with the provided test case\nassert last([1, 2, 3], 1) == 0"}
{"task_id": "Mbpp/794", "solution": "def validate_string(text):\n    \"\"\"\n    Checks if the given text starts with 'a' and ends with 'b', ensuring there are characters in between.\n    \n    Args:\n    text (str): The text to check.\n    \n    Returns:\n    bool: True if the text starts with 'a', ends with 'b', and has at least one character in between, False otherwise.\n    \"\"\"\n    # Using a regular expression to check for 'a' followed by any characters and ending with 'b'\n    import re\n    return bool(re.match(r'^a.*b$', text))\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (\"abc\", True),\n    (\"a123b\", True),\n    (\"a b\", True),\n    (\"a\", False),\n    (\"ab\", False),\n    (\"a123!@#b\", True),\n    (\"a123b!\", False),\n    (\"a123b123b\", True),\n]\n\n# Function to check the test cases\ndef check_function():\n    all_passed = True\n    for text, expected in test_cases:\n        result = validate_string(text)\n        if result != expected:\n            print(f\"Test failed for: '{text}'. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Running the check function to verify the solution\ncheck_function()"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dict1):\n    # Calculate the sum of all values in the dictionary\n    sum_values = sum(dict1.values())\n    return sum_values\n\n# Test the function with the provided test case\nassert return_sum({'a': 100, 'b': 200, 'c': 300}) == 600"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    # Calculate the sum of all odd numbers in the range [l, r]\n    return sum([i for i in range(l, r + 1) if i % 2 != 0])\n\n# Test the function with the provided test case\nassert sum_in_range(2, 5) == 8"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    # Calculate the sum of the array elements\n    return sum(arr)\n\n# Test the function with the provided test case\nassert _sum([1, 2, 3]) == 6"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    # Ensure the number is within 32-bit range\n    n &= 0xFFFFFFFF\n    \n    # Perform the left rotation\n    d = d % 32  # To handle cases where d > 32\n    rotated_number = ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n    \n    return rotated_number\n\n# Test the function with the provided test case\nassert left_rotate(16, 2) == 64"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(str1):\n    # Remove all whitespaces from the string using replace method\n    result = str1.replace(' ', '')\n    return result\n\n# Test the function with the provided test case\nassert remove_all_spaces('python  program') == 'pythonprogram'"}
{"task_id": "Mbpp/801", "solution": "def count_equal_numbers(a, b, c):\n    \"\"\"\n    Counts the number of equal numbers among the three integers a, b, and c.\n    \n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    c (int): The third integer.\n    \n    Returns:\n    int: The count of equal numbers among a, b, and c.\n    \"\"\"\n    # Count the occurrences of each number\n    count_a = (a, b, c).count(a)\n    count_b = (a, b, c).count(b)\n    count_c = (a, b, c).count(c)\n    \n    # Return the maximum count, which represents the number of equal numbers\n    return max(count_a, count_b, count_c)\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        ((1, 2, 3), 1),  # No numbers are equal\n        ((1, 1, 2), 2),  # Two numbers are equal\n        ((3, 3, 3), 3),  # All numbers are equal\n        ((5, 5, 5), 3),  # All numbers are equal\n        ((0, 0, 1), 2),  # Two numbers are equal\n        ((-1, -2, -1), 2),  # Two numbers are equal\n    ]\n    \n    all_passed = True\n    for inputs, expected in test_cases:\n        result = count_equal_numbers(*inputs)\n        if result != expected:\n            print(f\"Test failed for inputs {inputs}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Call the check function to verify the solution\ncheck_function()"}
{"task_id": "Mbpp/803", "solution": "def is_perfect_square(n):\n    # Check if n is less than 0, it cannot be a perfect square\n    if n < 0:\n        return False\n    # Calculate the square root of n and check if it's an integer\n    root = n ** 0.5\n    return root.is_integer()\n\n# Test the function with the provided test case\nassert not is_perfect_square(10)"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(nums):\n    # Iterate through the list and check if any number is even\n    for num in nums:\n        if num % 2 == 0:\n            return True\n    return False\n\n# Test the function with the provided test case\nassert is_product_even([1, 2, 3]) == True"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of its elements\n    max_list = max(lists, key=sum)\n    return max_list\n\n# Test the function with the provided test case\nassert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"}
{"task_id": "Mbpp/806", "solution": "def find_max_uppercase_run(s):\n    \"\"\"\n    Finds the maximum run of consecutive uppercase characters in a string.\n    \n    Parameters:\n    s (str): The string to analyze.\n    \n    Returns:\n    int: The length of the longest run of consecutive uppercase characters.\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        (\"\", 0),\n        (\"ABAB\", 2),\n        (\"ABCabcABC\", 3),\n        (\"aAaAa\", 1),\n        (\"12345\", 0),\n        (\"ABCDEF\", 6),\n        (\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\", 1),\n        (\"HelloWorld\", 5),\n        (\"PYTHONISAWESOME\", 12),\n        (\"1234567890\", 0),\n        (\"\", 0),\n        (\"ALLCAPS\", 6),\n        (\"lowercase\", 0),\n        (\"MIXEDCase\", 3),\n        (\"UPPERCASE\", 8),\n        (\"lowercase123\", 0),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n        (\"UPPERCASE123\", 8),\n        (\"123UPPERCASE456\", 8),\n"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    # Iterate through the list to find the first odd number\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None  # Return None if no odd number is found\n\n# Test the function with the provided test case\nassert first_odd([1, 3, 5]) == 1"}
{"task_id": "Mbpp/808", "solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple and return the result\n    return K in test_tup\n\n# Test the function with the provided test case"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(test_tup1, test_tup2):\n    # Check if all elements in test_tup2 are less than the corresponding elements in test_tup1\n    res = all(el2 < el1 for el1, el2 in zip(test_tup1, test_tup2))\n    return res\n\n# Test cases to verify the correctness of the function\nassert check_smaller((1, 2, 3), (2, 3, 4)) == False\nassert check_smaller((5, 6, 7), (1, 2, 3)) == True\nassert check_smaller((10, 20, 30), (5, 20, 15)) == False\nassert check_smaller((0, 0, 0), (0, 0, 0)) == True"}
