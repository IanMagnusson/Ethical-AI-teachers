{"date": "2025-03-13 14:01", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a, b):\n    # Check if the signs of a and b are opposite\n    return (a ^ b) < 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements(tup1, tup2):\n    # Convert the tuples to sets and find the intersection\n    result = set(tup1) & set(tup2)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall_number(x):\n    # If the number is even, it cannot be a Woodall number\n    if x % 2 == 0:\n        return False\n    # If the number is 1, it is a Woodall number\n    if x == 1:\n        return True\n    # Add 1 to make the number even\n    x += 1\n    p = 0\n    # Check if the number is divisible by 2\n    while x % 2 == 0:\n        x //= 2\n        p += 1\n        # If at any point the power (p) equals the number (x), it is a Woodall number\n        if p == x:\n            return True\n    return False\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    (1, True),\n    (7, True),\n    (23, True),\n    (63, True),\n    (159, True),\n    (383, True),\n    (200, False),\n    (1424, False)\n]\n\n# Check the function against the test cases\nall_passed = True\nfor x, expected in test_cases:\n    result = is_woodall_number(x)\n    if result != expected:\n        print(f\"Test failed for x = {x}. Expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All tests passed!\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(side):\n    # Calculate the perimeter of the square\n    perimeter = 4 * side\n    return perimeter", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    # Calculate the nth centered hexagonal number\n    return 3 * n * (n - 1) + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def count_rotations_divisible_by_4(num_str):\n    \"\"\"\n    Counts the number of rotations of the given number (as a string) that are divisible by 4.\n    \n    :param num_str: A string representation of a positive integer.\n    :return: The count of rotations that are divisible by 4.\n    \"\"\"\n    # Convert the string to an integer for easy manipulation\n    num = int(num_str)\n    count = 0\n    \n    # Generate all rotations of the number\n    for i in range(len(num_str)):\n        # Rotate the number by moving the first digit to the end\n        num_str = num_str[1:] + num_str[0]\n        # Convert the rotated string back to an integer\n        rotated_num = int(num_str)\n        # Check if the rotated number is divisible by 4\n        if rotated_num % 4 == 0:\n            count += 1\n    \n    return count\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume(a, b, c):\n    # Calculate the area of the triangular base\n    base_area = (a * b) / 2\n    # Calculate the volume of the prism\n    volume = base_area * c\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i + gaps]:\n                nums[i], nums[i + gaps] = nums[i + gaps], nums[i]\n                swapped = True\n            i += 1\n\n    return nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks(test_list):\n    # Sort the list of tuples based on the second element of each tuple\n    test_list.sort(key=lambda x: x[1])\n    return test_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(num):\n    # Calculate twice the reverse of the number and subtract 1\n    if num == 2 * int(str(num)[::-1]) - 1:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(s1, s2):\n    # Create a set of characters to be removed for faster lookup\n    chars_to_remove = set(s2)\n    # Use a list comprehension to filter out unwanted characters\n    result = [char for char in s1 if char not in chars_to_remove]\n    # Join the list back into a string and return\n    return ''.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    # Find the first occurrence of the character\n    first_occurrence = string.find(char)\n    # Find the last occurrence of the character\n    last_occurrence = string.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return string\n    \n    # Remove the first and last occurrence of the character\n    new_string = string[:first_occurrence] + string[first_occurrence+1:last_occurrence] + string[last_occurrence+1:]\n    \n    return new_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    # Use a list comprehension to square each element in the input list\n    return [i ** 2 for i in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row in ascending order\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    # Calculate the nth octagonal number using the formula\n    return n * (3 * n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def find_max_difference(tuples_list):\n    \"\"\"\n    Finds the maximum difference between the elements of the tuples in the list.\n    \n    :param tuples_list: List of tuples where each tuple contains two integers.\n    :return: Maximum difference between the elements of the tuples.\n    \"\"\"\n    if not tuples_list or len(tuples_list[0]) != 2:\n        return 0\n\n    # Calculate the absolute difference for each tuple and find the maximum\n    max_diff = max(abs(a - b) for a, b in tuples_list)\n    return max_diff\n\n# Test cases to verify the solution\ndef check_solution():\n    test_cases = [([(11, 14), (0, 78), (33, 67), (89, 0)], 78),\n                  ([(5, 3), (1, 4), (9, 5), (3, 5)], 8),\n                  ([(9, 5), (3, 5)], 4),\n                  ([(2, 2), (3, 3)], 0)]\n    \n    all_passed = True\n    for i, (tuples, expected) in enumerate(test_cases):\n        result = find_max_difference(tuples)\n        if result != expected:\n            print(f\"Test case {i+1} failed: Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Running the check function to verify the solution\ncheck_solution()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    # Check if the array contains any duplicate elements\n    return len(arr) != len(set(arr))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples where all elements are divisible by K\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring(test_list, test_str):\n    # Check if the test_str is a substring of any string in test_list\n    res = any(test_str in sub for sub in test_list)\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import cmath", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(x, y):\n    # Calculate the XOR of x and y\n    xor = x ^ y\n    # Check if the result is a power of 2 (only one bit set)\n    return xor and not (xor & (xor - 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings(S):\n    # Initialize the count of substrings\n    count = 0\n    # Iterate over all possible starting points of substrings\n    for start in range(len(S)):\n        sum_digits = 0\n        # Iterate over all possible ending points of substrings\n        for end in range(start, len(S)):\n            # Add the current digit to the sum\n            sum_digits += int(S[end])\n            # Check if the sum of digits is equal to the length of the substring\n            if sum_digits == end - start + 1:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_Diff(n):\n    # Check if the number is divisible by 11\n    if n % 11 == 0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    # Calculate the nth tetrahedral number using the formula\n    return n * (n + 1) * (n + 2) // 6", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(lst):\n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num(nums):\n    # Convert each number in the list to a string\n    str_nums = list(map(str, nums))\n    # Sort the list of strings in reverse order (descending)\n    str_nums.sort(reverse=True)\n    # Join the sorted strings to form the largest number\n    largest_num = ''.join(str_nums)\n    # Convert the result back to an integer\n    return int(largest_num)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def has_ordered_intersection(lst1, lst2):\n    \"\"\"\n    Checks if lst1 is a sublist of lst2, considering the order of elements.\n    \"\"\"\n    if not lst1:  # An empty list is a sublist of any list\n        return True\n    if not lst2:  # An non-empty list cannot be a sublist of an empty list\n        return False\n\n    k = 0  # Index for lst2\n    for i in lst1:\n        while k < len(lst2) and lst2[k] != i:\n            k += 1\n        if k == len(lst2):  # lst2 has been exhausted without finding all elements of lst1\n            return False\n        k += 1  # Move to the next element in lst2\n\n    return True\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(lst):\n    # Initialize a counter to count positive numbers\n    count = 0\n    # Iterate through the list\n    for num in lst:\n        # Check if the current number is positive\n        if num > 0:\n            # Increment the counter if the number is positive\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the common elements with the first list's elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the nested lists starting from the second list\n    for lst in nested_lists[1:]:\n        # Update the common elements to only include elements present in the current list\n        common_elements.intersection_update(lst)\n    \n    # Return the set of common elements\n    return common_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    # Merge the three dictionaries using the update method\n    result = dict1.copy()\n    result.update(dict2)\n    result.update(dict3)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def max_diff_substring(binary_str):\n    \"\"\"\n    Finds the maximum difference between the number of 0s and 1s in any sub-string of the given binary string.\n    If all characters are 1s, returns -1.\n    \"\"\"\n    max_diff = 0\n    current_diff = 0\n    for char in binary_str:\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        max_diff = max(max_diff, current_diff)\n        if current_diff < 0:\n            current_diff = 0\n\n    if max_diff == 0:\n        return -1\n    return max_diff\n\n# Test cases to verify the solution\ntest_cases = [\n    (\"11000010001\", 6),\n    (\"1111111\", -1),\n    (\"0000\", 4),\n    (\"1110000\", 0),\n    (\"0101010\", 2)\n]\n\ndef check_solution():\n    all_passed = True\n    for binary_str, expected in test_cases:\n        result = max_diff_substring(binary_str)\n        if result != expected:\n            print(f\"Test failed for input: {binary_str}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def longest_palindromic_subsequence(s: str) -> int:\n    \"\"\"\n    Finds the length of the longest palindromic subsequence in the given string.\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. The outer loop is for substrings of increasing length.\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    return dp[0][n - 1]\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    # Increment the number until a palindrome is found\n    while True:\n        n += 1\n        # Convert the number to a string and check if it reads the same forwards and backwards\n        if str(n) == str(n)[::-1]:\n            return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def count_odd_rotations(binary_str):\n    \"\"\"\n    Counts the number of rotations of a binary string that result in an odd decimal value.\n    \n    :param binary_str: A binary string consisting of '0's and '1's.\n    :return: The count of rotations that result in an odd decimal value.\n    \"\"\"\n    odd_count = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        # Rotate the string by i positions\n        rotated_str = binary_str[i:] + binary_str[:i]\n        # Convert the rotated string to an integer\n        decimal_value = int(rotated_str, 2)\n        # Check if the decimal value is odd\n        if decimal_value % 2 != 0:\n            odd_count += 1\n            \n    return odd_count\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(data):\n    # Initialize sum to 0\n    total_sum = 0\n    # Iterate through each element in the list\n    for element in data:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # If it's a list, recursively call the function to sum its elements\n            total_sum += recursive_list_sum(element)\n        else:\n            # If it's not a list, add the element to the total sum\n            total_sum += element\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def is_int(x):\n    # Check if the input is an integer using the built-in isinstance function\n    return isinstance(x, int)\n\n# Test cases to verify the correctness of the function\ndef check_is_int():\n    test_cases = [\n        (3, True),\n        (-17, True),\n        ('3', False),\n        ('3.14', False),\n        ('asfasfas', False),\n        (0.0, False),\n        (1.0, False),\n        (0, True),\n        (1, True),\n        (True, True),  # Note: True is equivalent to 1 in Python\n        (False, True), # Note: False is equivalent to 0 in Python\n    ]\n    \n    all_passed = True\n    for value, expected in test_cases:\n        result = is_int(value)\n        if result != expected:\n            print(f\"Test failed for input: {value}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Run the test function\ncheck_is_int()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    # Subtract 1 from n to find the closest smaller number\n    return n - 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    # Check if the length of the word is odd\n    return len(word) % 2 != 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Iterate from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        # If i is a divisor of n\n        if n % i == 0:\n            # Increment the count\n            count += 1\n            # If i is not the square root of n, count the complementary divisor\n            if i != n // i:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    res = min(test_list, key=lambda ele: ele[1])[0]\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    # Split the string by underscore and capitalize each word\n    # Then join them without any spaces\n    return ''.join(word.capitalize() or '_' for word in snake_str.split('_'))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count(test_list):\n    # Count the number of True booleans in the list\n    count = sum(test_list)\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def special_sum(x, y):\n    \"\"\"\n    This function takes two integers as input and returns their sum.\n    If the sum is between 15 and 20 (inclusive of 15 and exclusive of 20),\n    it returns 20 instead.\n    \"\"\"\n    total = x + y\n    if 15 <= total < 20:\n        return 20\n    else:\n        return total\n\n# Testing the function with provided data points", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element(lst, index, element):\n    \"\"\"\n    Inserts an element into a list at the specified index.\n    \n    Parameters:\n    lst (list): The list where the element is to be inserted.\n    index (int): The index at which the element is to be inserted.\n    element: The element to be inserted into the list.\n    \n    Returns:\n    list: The list with the new element inserted.\n    \"\"\"\n    lst.insert(index, element)\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Black"], "c"]], "plus_fail_tests": [[[], "hello"]]}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int(nums):\n    # Convert each element in the tuple to a string and join them together\n    str_nums = ''.join(str(num) for num in nums)\n    # Convert the resulting string to an integer\n    return int(str_nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    # Initialize the result variable\n    result = 0\n    \n    # Iterate through the array\n    for num in arr:\n        # XOR each element with the result\n        result ^= num\n    \n    # Return the result which is the element that appears only once\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def create_tuples_with_cubes(numbers):\n    \"\"\"\n    Create a list of tuples where each tuple contains a number and its cube.\n    \n    :param numbers: List of integers.\n    :return: List of tuples, where each tuple contains a number and its cube.\n    \"\"\"\n    return [(num, num ** 3) for num in numbers]\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        ([1, 2, 3], [(1, 1), (2, 8), (3, 27)]),\n        ([0, 1, 2, 3, 4], [(0, 0), (1, 1), (2, 8), (3, 27), (4, 64)]),\n        ([5, 6], [(5, 125), (6, 216)])\n    ]\n    \n    all_passed = True\n    for numbers, expected in test_cases:\n        result = create_tuples_with_cubes(numbers)\n        if result != expected:\n            print(f\"Test failed for input {numbers}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Running the check function to verify the solution\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    # Calculate the nth hexagonal number using the formula\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    # Initialize the count to 0\n    count = 0\n    # Iterate over the string with index\n    for index, char in enumerate(s):\n        # Convert character to lowercase and check if it matches the position\n        if char.lower() == chr(ord('a') + index):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    # Join the elements of the tuple into a single string\n    result = ''.join(tup)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def find_x_y(a, b, n):\n    from math import gcd\n\n    # Calculate the greatest common divisor of a and b\n    d = gcd(a, b)\n\n    # Check if n is divisible by the gcd\n    if n % d != 0:\n        return \"No Solution Exists\"\n\n    # Reduce the equation by dividing a, b, and n by their gcd\n    a //= d\n    b //= d\n    n //= d\n\n    # Find the particular solution using the extended Euclidean algorithm\n    x0, y0 = extended_euclidean_algorithm(a, b)\n\n    # Scale the particular solution to satisfy the original equation\n    x0 *= n\n    y0 *= n\n\n    # General solution\n    x = x0 + b * (n // d)\n    y = y0 - a * (n // d)\n\n    return x, y\n\ndef extended_euclidean_algorithm(a, b):\n    if a == 0:\n        return (0, 1)\n    else:\n        x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (x, y)\n\n# Test cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists(list_of_lists):\n    # Use list comprehension to sort each sublist in the given list of lists\n    sorted_list = [sorted(sublist) for sublist in list_of_lists]\n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list(str1):\n    # Split the string on spaces and return the list of words\n    return str1.split(' ')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    # A number can be represented as the difference of two squares if and only if it is not of the form 4k+2\n    return n % 4 != 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of the specified slice of the list\n    return sum(nums[start:end+1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    # Calculate the volume of a sphere using the formula (4/3) * \u03c0 * r^3\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance(str1):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through the string to find occurrences of 'std'\n    for i in range(len(str1) - 2):\n        # Check if the substring from current position to current position + 3 is 'std'\n        if str1[i:i+3] == 'std':\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements(original_list, elements_to_remove):\n    # Use a list comprehension to filter out elements that are in the elements_to_remove list\n    result = [element for element in original_list if element not in elements_to_remove]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    # Iterate over the array from the end to the beginning\n    for cur_size in range(len(arr), 1, -1):\n        # Find the index of the maximum element in the current subarray\n        max_pos = 0\n        for i in range(cur_size):\n            if arr[i] > arr[max_pos]:\n                max_pos = i\n        # If the maximum element is not at the current position, flip it to the front\n        if max_pos != cur_size - 1:\n            # Flip the element to the front\n            arr[:max_pos + 1] = reversed(arr[:max_pos + 1])\n            # Flip the element to its correct position\n            arr[:cur_size] = reversed(arr[:cur_size])\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "def multiply_num(nums):\n    # Calculate the product of all numbers in the list\n    product = 1\n    for num in nums:\n        product *= num\n    # Divide the product by the length of the list\n    return product / len(nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(n):\n    # Considering the definition with restriction that there should be at least 3 digits\n    if len(n) <= 2:\n        return False\n\n    # Check if all alternate digits are same or not\n    for i in range(2, len(n)):\n        if n[i - 2] != n[i]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1212121]], "plus_fail_tests": [[2121212121212121]]}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def find_eulerian_number(n, m):\n    \"\"\"\n    Calculate the Eulerian number A(n, m), which represents the number of permutations of the numbers 1 to n\n    in which exactly m elements are greater than the previous element.\n    \n    :param n: The length of the permutation.\n    :param m: The number of elements that are greater than the previous element.\n    :return: The Eulerian number A(n, m).\n    \"\"\"\n    if m == 0:\n        return 1 if n == 1 else 0\n    if m == n - 1:\n        return 1\n    return (n - m) * find_eulerian_number(n - 1, m - 1) + (m + 1) * find_eulerian_number(n - 1, m)\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum(nums):\n    # Initialize sum to 0\n    sum = 0\n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            # Add the negative number to the sum\n            sum += num\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_hexadecimal(n):\n    \"\"\"\n    Converts a decimal number to its hexadecimal representation as a string.\n    \n    Args:\n        n (int): The decimal number to convert.\n        \n    Returns:\n        str: The hexadecimal representation of the decimal number.\n    \"\"\"\n    if n < 0:\n        # Handle negative numbers in 2's complement form\n        n = (1 << 32) + n\n    return hex(n)[2:]\n\n# Test cases to verify the correctness of the function\ndef check():\n    test_cases = [\n        (134, \"86\"),\n        (-134, \"ffffff86\"),  # 2's complement representation for -134\n        (0, \"0\"),\n        (255, \"ff\"),\n        (-255, \"ffffff01\")\n    ]\n    \n    all_passed = True\n    for n, expected in test_cases:\n        result = decimal_to_hexadecimal(n)\n        if result != expected:\n            print(f\"Test failed for input {n}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    # Calculate the circumference of a circle given its radius\n    return 2 * math.pi * radius", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple(test_list):\n    # Calculate the absolute product for each tuple and return the maximum value\n    res = max(abs(a * b) for a, b in test_list)\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    # Calculate a to the power of b\n    return a ** b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    # Find the minimum length among all the lists in the list of lists\n    min_length = min(len(sublist) for sublist in list_of_lists)\n    return min_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    # Find the maximum length of the words in the list\n    max_length = max(len(word) for word in words)\n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def can_be_sum_of_powers_of_3(n):\n    \"\"\"\n    Check if a number can be represented as the sum of distinct powers of 3.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    str: \"Yes\" if n can be represented as the sum of distinct powers of 3, \"No\" otherwise.\n    \"\"\"\n    # Generate powers of 3 up to the largest one less than or equal to n\n    powers_of_3 = [3**i for i in range(1, 10) if 3**i <= n]\n    \n    # Try to find a subset of these powers that sums to n\n    def find_subset(powers, target):\n        if target == 0:\n            return True\n        if not powers:\n            return False\n        \n        # Include the largest power and check if the remaining can be found\n        if powers[-1] <= target:\n            if find_subset(powers[:-1], target - powers[-1]):\n                return True\n        # Exclude the largest power and check the remaining\n        return find_subset(powers[:-1], target)\n    \n    return \"Yes\" if find_subset(powers_of_3, n) else \"No\"\n\n# Test cases to verify the solution\ntest_cases = [(28, \"Yes\"), (6, \"No\"), (5, \"Yes\"), (15, \"No\")]\nall_passed = True\nfor n, expected in test_cases:\n    result = can_be_sum_of_powers_of_3(n)\n    if result != expected:\n        print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All test cases passed!\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(text):\n    # Define vowels\n    vowels = \"aeiouAEIOU\"\n    # Convert text to a list for easy manipulation\n    text_list = list(text)\n    # Initialize two pointers\n    left, right = 0, len(text_list) - 1\n    \n    # Traverse the string with two pointers\n    while left < right:\n        # Move the left pointer until a vowel is found\n        if text_list[left] not in vowels:\n            left += 1\n        # Move the right pointer until a vowel is found\n        elif text_list[right] not in vowels:\n            right -= 1\n        # Swap the vowels\n        else:\n            text_list[left], text_list[right] = text_list[right], text_list[left]\n            left += 1\n            right -= 1\n    \n    # Convert the list back to a string\n    return ''.join(text_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    # Calculate the perimeter of a regular pentagon\n    perimeter = 5 * side_length\n    return perimeter", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type(test_tuple):\n    # Extract the type of the first element in the tuple\n    first_type = type(test_tuple[0])\n    # Check if all elements in the tuple have the same type as the first element\n    return all(isinstance(element, first_type) for element in test_tuple)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    # Initialize a counter to count the integer elements\n    count = 0\n    # Iterate through each element in the list\n    for element in lst:\n        # Check if the element is an integer\n        if type(element) is int:\n            # Increment the counter if the element is an integer\n            count += 1\n    # Return the total count of integer elements\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(lst1, lst2):\n    # Replace the last element of the first list with the elements of the second list\n    lst1[-1:] = lst2\n    return lst1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # Increment the count of the item in the dictionary\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n    \n    return max_item", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    # Calculate the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Return the absolute difference between the max and min values\n    return abs(max_val - min_val)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(x, y):\n    # Multiply two integers and return the result\n    return x * y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples and convert it to a set to remove duplicates\n    return set([item for sublist in list_of_tuples for item in sublist])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def convert_tuples_to_dict(tuples_list):\n    \"\"\"\n    Converts a list of tuples into a dictionary where each tuple contains exactly two elements.\n    The first element of each tuple is used as the key, and the second as the value in the dictionary.\n    \n    :param tuples_list: List of tuples to convert into a dictionary.\n    :return: Dictionary created from the list of tuples.\n    \"\"\"\n    return dict(tuples_list)\n\n# Example usage:\nexample_tuples = [('a', 1), ('b', 2), ('c', 3)]\nresult = convert_tuples_to_dict(example_tuples)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samePatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    sdict = {}\n    pset = set()\n    sset = set()\n\n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False\n\n    for values in sdict.values():\n        for i in range(len(values) - 1):\n            if values[i] != values[i + 1]:\n                return False\n\n    return True\n\n# Test cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def count_special_sequences(n, m):\n    \"\"\"\n    Counts the number of special sequences of length n where each element is greater than zero,\n    less than or equal to m, and follows the condition seq[i+1] >= 2 * seq[i].\n    \"\"\"\n    # Initialize a 2D DP table where dp[i][j] represents the number of ways to form a sequence of length i ending with j.\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: there's one way to form a sequence of length 0 (the empty sequence).\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(str1, ch):\n    # Replace spaces in the string with the specified character\n    result = str1.replace(' ', ch)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    # Initialize the count of even pairs to 0\n    count = 0\n    # Iterate through each pair of integers in the list\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if the XOR of the pair results in an even number\n            if ((nums[i] ^ nums[j]) % 2 == 0):\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "import math\ndef bell_numbers(n):\n    \"\"\"\n    Calculate the Bell number for a set of size n using Dobinski's formula.\n    \"\"\"\n    return (1 / math.e) * sum([(k**n) / math.factorial(k) for k in range(n + 1)])\ndef stirling_numbers(n, k):\n    \"\"\"\n    Calculate the Stirling number of the second kind.\n    \"\"\"\n    if n == 0 or k == 0 or k > n:\n        return 0\n    if k == 1 or n == k:\n        return 1\n    return k * stirling_numbers(n - 1, k) + stirling_numbers(n - 1, k - 1)\ndef peirce_triangle(n):\n    \"\"\"\n    Calculate the Bell number using Peirce's triangle.\n    \"\"\"\n    matrix = [[0] * (i + 1) for i in range(n + 1)]\n    matrix[0][0] = 1\n    for i in range(1, n + 1):\n        matrix[i][0] = matrix[i - 1][i - 1]\n        for j in range(1, i + 1):\n            matrix[i][j] = matrix[i - 1][j - 1] + matrix[i][j - 1]\n    return matrix[n][0]\ndef bell_number(n, method='dobinski'):\n    \"\"\"\n    Calculate the Bell number for a set of size n using the specified method.\n    \"\"\"\n    if method == 'dobinski':\n        return bell_numbers(n)\n    elif method == 'stirling':\n        return sum(stirling_numbers(n, k) for k in range(n + 1))\n    elif method == 'peirce':\n        return peirce_triangle(n)\n    else:\n        raise ValueError(\"Invalid method specified\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[0]]}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    # Return the (k-1)th element of the array using 1-based indexing\n    return arr[k-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through each sublist in the given list of lists\n    for sublist in lists:\n        # Update the frequency dictionary with the elements from the current sublist\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n                \n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Calculate the maximum increasing subsequence sum ending at each index\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Calculate the maximum decreasing subsequence sum starting at each index\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of a bitonic sequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    # Calculate the surface area of a sphere using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * radius ** 2\n    return surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, x):\n    \"\"\"\n    Check if the element x appears more than n/2 times in the array.\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def check_even_or_odd(n):\n    \"\"\"\n    Checks if the given number is even or odd using bitwise operations.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        str: 'Even' if the number is even, 'Odd' if the number is odd.\n    \"\"\"\n    return 'Even' if (n & 1) == 0 else 'Odd'\n\ndef check_all_bits_set(n):\n    \"\"\"\n    Checks if all bits of the given number are set.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        str: 'Yes' if all bits are set, 'No' if not.\n    \"\"\"\n    return 'Yes' if ((n + 1) & n) == 0 else 'No'\n\n# Test cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    # Initialize count of set bits to 0\n    count = 0\n    # Loop until n becomes 0\n    while n:\n        # Increment count if the least significant bit is 1\n        count += n & 1\n        # Right shift n by 1 to check the next bit\n        n >>= 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal(test_list):\n    # Check if all tuples in the list have the same length\n    res = all(len(i) == len(test_list[0]) for i in test_list)\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency(arr, num):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through the list to count occurrences of num\n    for n in arr:\n        if n == num:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency_dict = {}\n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    # Return the dictionary containing the frequency of each element\n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate through the string, considering only characters at even indices\n    for i in range(0, len(s), 2):\n        result += s[i]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, string):\n    # Split the string into words\n    words = string.split(\" \")\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(str1):\n    # Calculate the length of the string\n    length = len(str1)\n    return length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "def find_zeroes(arr):\n    \"\"\"\n    Counts the number of zeroes in the given array.\n    \"\"\"\n    return arr.count(0)\n\ndef find_positive_negative_ratios(arr):\n    \"\"\"\n    Finds the ratio of positive, negative, and zero numbers in the array.\n    \"\"\"\n    total = len(arr)\n    positive_count = sum(1 for num in arr if num > 0)\n    negative_count = sum(1 for num in arr if num < 0)\n    zero_count = total - positive_count - negative_count\n\n    positive_ratio = round(positive_count / total, 4) if total > 0 else 0\n    negative_ratio = round(negative_count / total, 4) if total > 0 else 0\n    zero_ratio = round(zero_count / total, 4) if total > 0 else 0\n\n    return positive_ratio, negative_ratio, zero_ratio\n\n# Test cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(num):\n    # Convert the complex number to polar coordinates\n    polar_coordinates = cmath.polar(num)\n    return polar_coordinates", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(test_tup, K):\n    # Count the occurrences of K in the tuple using the count method\n    res = test_tup.count(K)\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def newman_conway(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 1]\n    \n    p = [0] * (n + 1)\n    p[1] = 1\n    p[2] = 1\n    \n    for i in range(3, n + 1):\n        p[i] = p[p[i - 1]] + p[i - p[i - 1]]\n    \n    return p\n\n# Test the function with the given sequence\ndef test_newman_conway():\n    # Test for the first 20 terms of the Newman-Conway sequence\n    result = newman_conway(20)\n    expected = [1, 1, 2, 2, 3, 4, 4, 4, 5, 6, 7, 7, 8, 8, 8, 8, 9, 10, 11, 12, 12]\n    assert result == expected, f\"Expected {expected}, but got {result}\"\n\n    # Test for the 105th term\n    result_105 = newman_conway(105)[105]\n    expected_105 = 56\n    assert result_105 == expected_105, f\"Expected {expected_105}, but got {result_105}\"\n\n    print(\"All tests passed!\")\n\n# Call the test function\ntest_newman_conway()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    # Initialize a counter for the matching elements\n    count = 0\n    # Iterate through the lists using zip to compare elements at the same position\n    for a, b, c in zip(list1, list2, list3):\n        # Increment the counter if elements in all three lists are the same\n        if a == b == c:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    # Sort the list in descending order and slice the first n elements\n    return sorted(lst, reverse=True)[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    # Calculate the volume of the cube\n    volume = side_length ** 3\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    # Return the minimum of the three numbers\n    return min(a, b, c)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    # Initialize the count of substrings\n    count = 0\n    # Calculate the number of substrings\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    # If n is 0, the next power of 2 is 1\n    if n == 0:\n        return 1\n    # If n is already a power of 2, return n itself\n    if (n & (n - 1)) == 0:\n        return n\n    # Otherwise, find the next power of 2\n    power = 1\n    while power < n:\n        power <<= 1\n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    # Calculate the sum of the series (n - 2*i) from i=0 to n // 2\n    return sum(n - 2 * i for i in range(n // 2 + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to the specified limit.\n    \n    Args:\n    limit (int): The upper limit for finding amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers within the specified range.\n    \"\"\"\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    \n    def sum_prop_div(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        d_sum = 0\n        for x in range(1, n // 2 + 1):\n            if n % x == 0:\n                d_sum += x\n        return d_sum\n    \n    amicables = set()\n    for num in range(2, limit + 1):\n        if num in amicables:\n            continue\n        sum_fact = sum_prop_div(num)\n        sum_fact2 = sum_prop_div(sum_fact)\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9999]], "plus_fail_tests": [[10000]]}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_slice(sequence, step):\n    \"\"\"\n    Splits the given sequence into slices with a specified step.\n    \n    Parameters:\n    sequence (list): The list to be split.\n    step (int): The step value to split the list.\n    \n    Returns:\n    list: A list of slices from the sequence with a step of 'step'.\n    \"\"\"\n    return [sequence[i::step] for i in range(step)]\n\n# Example usage:\nC = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nresult = list_slice(C, 3)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def calculate_dog_years(human_years):\n    \"\"\"\n    Calculates the dog's age in dog years based on the given human years.\n    \n    Parameters:\n    human_years (int): The age of the dog in human years.\n    \n    Returns:\n    int: The age of the dog in dog years.\n    \"\"\"\n    if human_years < 0:\n        return \"Age must be a positive number.\"\n    elif human_years <= 2:\n        return human_years * 10.5\n    else:\n        return 21 + (human_years - 2) * 4\n\n# Example usage:\n# print(calculate_dog_years(12))  # Output: 61", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract(test_list):\n    # Extract the last element of each tuple in the list\n    rear_elements = [sub[-1] for sub in test_list]\n    return rear_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter(dict1, n):\n    # Filter the dictionary to only include entries with values >= n\n    result = {key: value for key, value in dict1.items() if value >= n}\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length(lists):\n    # Find the maximum length of the sublists\n    max_len = max(len(sublist) for sublist in lists)\n    # Return the maximum length and the sublist with that length\n    return (max_len, [sublist for sublist in lists if len(sublist) == max_len][0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    # Split the list into two parts based on the length L\n    first_part = lst[:L]\n    second_part = lst[L:]\n    # Return the two parts as a tuple\n    return (first_part, second_part)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side):\n    # Calculate the lateral surface area of a cube\n    return 4 * side * side", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value(c):\n    # Convert the character to its ASCII value and return it\n    return ord(c)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    # If n is less than 2, there are no prime numbers less than n\n    if n < 2:\n        return 0\n    \n    # Initialize a list to mark prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Use the Sieve of Eratosthenes algorithm to find all prime numbers less than n\n    for start in range(2, int(n**0.5) + 1):\n        if is_prime[start]:\n            for multiple in range(start*start, n, start):\n                is_prime[multiple] = False\n    \n    # Count and return the number of prime numbers\n    return sum(is_prime)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_list_to_tuple(str1):\n    \"\"\"\n    Converts a given string with spaces to a tuple, excluding whitespaces.\n    \n    :param str1: String to be converted to a tuple.\n    :return: Tuple containing characters of the string, excluding whitespaces.\n    \"\"\"\n    result = tuple(x for x in str1 if not x.isspace())\n    return result\n\n# Test the function with provided data points", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(l, s):\n    # Apply the format string to each element in the list\n    res = [s.format(i) for i in l]\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "def contains_any(s, char_set):\n    \"\"\"\n    Check if the string 's' contains any of the characters in 'char_set'.\n    \n    :param s: String to check\n    :param char_set: Set of characters to look for\n    :return: True if any character in 'char_set' is found in 's', otherwise False\n    \"\"\"\n    return any(c in char_set for c in s)\n\n# Test cases to verify the solution\ndef test_contains_any():\n    test_cases = [\n        (\"hello\", {'h', 'e', 'l', 'o'}, True),\n        (\"world\", {'h', 'e', 'l', 'o'}, False),\n        (\"python\", {'p', 'y', 't', 'h', 'o', 'n'}, True),\n        (\"code\", {'c', 'o', 'd', 'e'}, True),\n        (\"test\", {'a', 'b', 'c'}, False),\n    ]\n    \n    all_passed = True\n    for s, char_set, expected in test_cases:\n        result = contains_any(s, char_set)\n        if result != expected:\n            print(f\"Test failed for: {s}, {char_set}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n\n# Run the tests\ntest_contains_any()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subsequence(arr, i, k):\n    \"\"\"\n    Finds the maximum sum of an increasing subsequence from the prefix up to index i,\n    including the element at index k (where k > i).\n    \"\"\"\n    if i >= k or k >= len(arr):\n        return 0\n\n    # Initialize the dp table\n    dp = [[0] * len(arr) for _ in range(len(arr))]\n\n    # Fill the dp table\n    for idx in range(len(arr)):\n        for kdx in range(idx, len(arr)):\n            if idx == kdx:\n                dp[idx][kdx] = arr[idx]\n            else:\n                if arr[idx] < arr[kdx]:\n                    dp[idx][kdx] = max(dp[idx][idx], dp[idx][idx-1] if idx > 0 else 0) + arr[kdx]\n                else:\n                    dp[idx][kdx] = dp[idx][idx-1] if idx > 0 else 0\n\n    return dp[i][k]\n\n# Test cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def add_element_to_tuple(original_tuple, element):\n    \"\"\"\n    Adds an element to the given tuple and returns a new tuple.\n    \n    :param original_tuple: Tuple to which the element will be added.\n    :param element: Element to add to the tuple.\n    :return: New tuple with the added element.\n    \"\"\"\n    return original_tuple + (element,)\n\n# Example usage:\n# new_tuple = add_element_to_tuple((1, 2, 3), 4)\n# print(new_tuple)  # Output: (1, 2, 3, 4)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers(num1, num2):\n    # Return a tuple with the second number first and then the first number\n    return (num2, num1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(nums):\n    \"\"\"\n    Calculate the sum of digits of each number in a given list.\n    \n    Args:\n        nums (list): A list of integers.\n        \n    Returns:\n        list: A list containing the sum of digits for each number in the input list.\n    \"\"\"\n    result = []\n    for num in nums:\n        sum_digits = 0\n        while num != 0:\n            sum_digits += num % 10\n            num //= 10\n        result.append(sum_digits)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 2, 56]]], "plus_fail_tests": [[[]]]}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_elements_until_first_tuple(input_list):\n    \"\"\"\n    Counts the elements in the input list until the first tuple is encountered.\n    \n    Parameters:\n    input_list (list): The list to be processed.\n    \n    Returns:\n    int: The count of elements before the first tuple.\n    \"\"\"\n    count = 0\n    for element in input_list:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [([4, 5, 6, 10, (1, 2, 3), 11, 2, 4], 4),\n                  ([4, (5, 6), 10, (1, 2, 3), 11, 2, 4], 1),\n                  ([1, 2, 3, 4, 5], 5),\n                  ([], 0),\n                  ([1, 2, (3, 4), 5], 2)]\n    \n    all_passed = True\n    for input_list, expected in test_cases:\n        result = count_elements_until_first_tuple(input_list)\n        if result != expected:\n            print(f\"Test failed for: {input_list}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Running the check function\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    # Check if all items in the list are equal to the given element\n    return all(item == element for item in lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    # Check if the length of the list is the same as the length of the set of the list\n    # If they are the same, all elements are unique\n    return len(lst) == len(set(lst))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    # Calculate the nth decagonal number using the formula\n    return 4 * n * n - 3 * n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    # Create a dictionary to store the results of subproblems\n    memo = {0: 0, 1: 1}\n    \n    def helper(x):\n        # If the result is already computed, return it\n        if x in memo:\n            return memo[x]\n        # Compute the maximum sum recursively\n        max_sum = max(x, helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5))\n        # Store the result in the dictionary\n        memo[x] = max_sum\n        return max_sum\n    \n    return helper(n)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(strings, size):\n    # Use list comprehension to filter strings that match the specified size\n    return [s for s in strings if len(s) == size]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, target):\n    # Iterate through the array with index\n    for index, element in enumerate(arr):\n        # Check if the current element matches the target\n        if element == target:\n            return (True, index)\n    # Return (False, -1) if the target is not found\n    return (False, -1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    # Initialize sum to 0\n    sum = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is even\n        if index % 2 == 0 and value % 2 == 0:\n            sum += value\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    # Calculate the n'th star number using the formula\n    return 6 * n * (n - 1) + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    # Calculate the volume of the cylinder\n    volume = math.pi * (radius ** 2) * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def find_nth_prime(n):\n    \"\"\"\n    Finds the n-th prime number.\n    \n    Parameters:\n    n (int): The position of the prime number to find.\n    \n    Returns:\n    int: The n-th prime number.\n    \"\"\"\n    if n == 1:\n        return 2\n    count = 1  # Starting with the first prime number, 2.\n    num = 3\n    while count < n:\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n        num += 2\n    return num - 2\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [(6, 13), (1, 2), (5, 11), (10, 29)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = find_nth_prime(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(input_string):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    # Use a generator expression to perform element-wise division and handle division by zero\n    result = tuple(i / j if j != 0 else 0 for i, j in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(str_list):\n    # Reverse each string in the list using a list comprehension\n    return [s[::-1] for s in str_list]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    # Use a tuple comprehension to subtract elements of tuple2 from tuple1\n    result = tuple(x - y for x, y in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def sum_even_odd_digits(numbers):\n    even_sum = 0\n    odd_sum = 0\n    for num in numbers:\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                even_sum += int(digit)\n            else:\n                odd_sum += int(digit)\n    return even_sum, odd_sum\n\n# Test cases to verify the solution\ntest_cases = [\n    ([345, 893], (12, 20)),\n    ([1, 2, 3, 4, 5, 6], (12, 9)),\n    ([1, 3, 5, 8, 10, 9, 11, 12, 1, 14], (22, 18)),\n]\n\ndef check_solution():\n    all_passed = True\n    for idx, (input_data, expected) in enumerate(test_cases):\n        result = sum_even_odd_digits(input_data)\n        if result != expected:\n            print(f\"Test case {idx + 1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(list1, list2, list3):\n    # Create a list of dictionaries using the zipped lists\n    result = [dict(zip([item1], [dict(zip([item2], [item3]))])) for item1, item2, item3 in zip(list1, list2, list3)]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    # Calculate the sum of the first n natural numbers\n    sum_of_naturals = sum([i for i in range(1, n+1)])\n    # Return the difference between the two sums\n    return sum_of_cubes - sum_of_naturals", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    # Check if the number is even\n    if n % 2 == 0:\n        return False\n    else:\n        return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(side1, side2):\n    # Calculate the third side using Pythagorean theorem\n    third_side = math.sqrt(side1**2 + side2**2)\n    return third_side", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    # Initialize variables to store the maximum and minimum products up to the current position\n    max_product = min_product = result = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # If the current element is negative, swap max and min products\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update the maximum and minimum products up to the current position\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inv_count = 0\n    # Traverse each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If there is an inversion, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    # Calculate the cube sum of the first n even natural numbers\n    return sum([(2 * i) ** 3 for i in range(1, n + 1)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    # Calculate the sum of the maximum and minimum values in the array\n    return max(arr) + min(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_product_pair(arr):\n    \"\"\"\n    Finds the pair of integers in the given array that has the highest product.\n    \n    :param arr: List of integers\n    :return: Tuple containing the pair of integers with the highest product\n    \"\"\"\n    if len(arr) < 2:\n        print(\"No pairs exists\")\n        return None\n    \n    # Initialize the maximum product and the pair\n    max_product = float('-inf')\n    max_pair = (None, None)\n    \n    # Iterate through the array to find the maximum product pair\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (arr[i], arr[j])\n                \n    return max_pair\n\n# Test cases\ndef test_max_product_pair():\n    test_cases = [\n        ([1, 2, 3, 4, 7, 0, 8, 4], (7, 8)),\n        ([0, -1, -2, -4, 5, 0, -6], (-4, -6)),\n        ([1, 2, 3], (3, 2)),\n        ([0, 0], (0, 0)),\n        ([1], None),\n        ([-1, -2, -3, -4], (-3, -4))\n    ]\n    \n    all_passed = True\n    for arr, expected in test_cases:\n        result = max_product_pair(arr)\n        if result != expected:\n            print(f\"Test failed for array {arr}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_product_pair()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def max_min_val(list_val):\n    \"\"\"\n    Finds the maximum and minimum integer values in a given heterogeneous list.\n    \n    Parameters:\n    list_val (list): A list containing a mix of integers and non-integer values.\n    \n    Returns:\n    tuple: A tuple containing the maximum and minimum integer values.\n    \"\"\"\n    # Use generator expressions to find the maximum and minimum integer values in 'list_val'\n    max_val = max(i for i in list_val if isinstance(i, int))\n    min_val = min(i for i in list_val if isinstance(i, int))\n    return (max_val, min_val)\n\n# Create a list 'list_val' containing a mix of integers and non-integer values\nlist_val = ['Python', 3, 2, 4, 5, 'version']\n\n# Print a message indicating the original list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(dict1):\n    # Sort the dictionary by value in descending order and return as a list of tuples\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def find_rightmost_unset_bit(n):\n    \"\"\"\n    Finds the position of the rightmost unset bit in the binary representation of n.\n    If no unset bits are found, returns -1.\n    \"\"\"\n    if n == 0:\n        return 0\n    position = 1\n    while n & 1:\n        n >>= 1\n        position <<= 1\n    while n:\n        n >>= 1\n        position <<= 1\n        position -= 1\n    return position - 1\n\n# Test cases to verify the solution\ntest_cases = [\n    (10, 2),  # 10 in binary is 1010, rightmost unset bit is at position 2\n    (21, 2),  # 21 in binary is 10101, rightmost unset bit is at position 2\n    (9, 2),   # 9 in binary is 1001, rightmost unset bit is at position 2\n    (0, 0),   # 0 in binary has no unset bits, so it returns 0\n]\n\n# Check function to verify the correctness of the solution\ndef check():\n    all_passed = True\n    for n, expected in test_cases:\n        result = find_rightmost_unset_bit(n)\n        if result != expected:\n            print(f\"Test failed for input {n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos(nums):\n    # Use list comprehension to filter negative numbers\n    return [num for num in nums if num < 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find(x, y):\n    # Calculate the quotient using integer division\n    quotient = x // y\n    return quotient", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    # Calculate the maximum subarray sum for a single array\n    max_current = max_global = arr[0]\n    for i in range(1, n):\n        max_current = max(arr[i], max_current + arr[i])\n        if max_current > max_global:\n            max_global = max_current\n\n    # Calculate the total sum of the array\n    total_sum = sum(arr)\n\n    # If k is 1, return the result of the single array case\n    if k == 1:\n        return max_global\n\n    # If the total sum is negative, do not add extra sums\n    if total_sum < 0:\n        return max_global\n\n    # Otherwise, the result is total_sum * (k-1) + max_global\n    return max_global + (k - 1) * total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def max_product_of_triplet(arr):\n    \"\"\"\n    Finds the maximum product of a triplet in the given array.\n    \"\"\"\n    if len(arr) < 3:\n        return None  # Not enough elements to form a triplet\n\n    # Initialize the maximum product to a very low value\n    max_product = -float('inf')\n\n    # Iterate through the array to find the maximum product of a triplet\n    for i in range(len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                max_product = max(max_product, arr[i] * arr[j] * arr[k])\n\n    return max_product\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct(test_tup):\n    # Check if the length of the tuple is the same as the length of the set created from the tuple\n    # If they are the same, it means there are no duplicates\n    return len(test_tup) == len(set(test_tup))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "def text_match_wordz(text):\n    # Check if 'z' is present in the text\n    return 'z' in text", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(test_list):\n    # Find the maximum length among the sublists\n    max_length = max(len(sublist) for sublist in test_list)\n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    # Check if the list is empty or has only one element\n    if len(lst) <= 1:\n        return True\n    # Sort the list to check for consecutiveness\n    sorted_lst = sorted(lst)\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i] + 1 != sorted_lst[i + 1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "from typing import List, Tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    # Convert each number in the list to a string and join them together\n    combined_str = ''.join(str(number) for number in numbers)\n    # Convert the combined string back to an integer\n    return int(combined_str)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string, taking every second character starting from index 1\n    for i in range(1, len(string), 2):\n        result += string[i]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(lst):\n    # Initialize a dictionary to keep track of the maximum aggregate for each person\n    max_aggregate_dict = {}\n    \n    # Iterate through each tuple in the list\n    for name, score in lst:\n        # If the name is already in the dictionary, add the score to the existing total\n        if name in max_aggregate_dict:\n            max_aggregate_dict[name] += score\n        else:\n            # Otherwise, initialize the name in the dictionary with the score\n            max_aggregate_dict[name] = score\n    \n    # Find the name with the maximum aggregate score\n    max_name = max(max_aggregate_dict, key=max_aggregate_dict.get)\n    \n    # Return the name with the maximum aggregate score and the score itself as a tuple\n    return (max_name, max_aggregate_dict[max_name])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    # Calculate the area of the rectangle\n    area = length * width\n    return area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower(text):\n    # Convert the given string to lower case\n    return text.lower()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    # Initialize result to 1\n    result = 1\n    # Multiply each number in the array and take modulo n\n    for num in arr:\n        result = (result * num) % n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(test_tup, K):\n    # Check if K is in test_tup using the 'in' keyword\n    if K in test_tup:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize the result counter\n    res = 0\n    # Iterate through each element in the test_list\n    for ele in test_list:\n        # Count the occurrences of the current element in the test_tup\n        res += test_tup.count(ele)\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "from itertools import chain, combinations", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements(tup1, tup2):\n    # Convert tuples to sets, find the union, and convert back to tuple\n    result = tuple(set(tup1) | set(tup2))\n    # Return the sorted tuple\n    return tuple(sorted(result))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    # Find the sublist with the minimum length\n    min_length = min(len(sublist) for sublist in lst)\n    # Return the first sublist that matches the minimum length\n    for sublist in lst:\n        if len(sublist) == min_length:\n            return sublist", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    # Use list comprehension to sort each sublist in the given list of lists\n    sorted_list = [sorted(sublist) for sublist in list_of_lists]\n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val(list_val):\n    \"\"\"\n    Finds the maximum value in a heterogeneous list using lambda.\n    \n    The function sorts the list first by whether the element is an integer (True for integers, False for non-integers)\n    and then lexicographically by the elements themselves.\n    \n    Parameters:\n    list_val (list): A list containing a mix of strings and integers.\n    \n    Returns:\n    The maximum value in the list based on the specified criteria.\n    \"\"\"\n    # Find the maximum value in 'list_val' based on two criteria:\n    # 1. First, sort by whether the element is an integer or not (True for integers, False for non-integers)\n    # 2. Second, sort lexicographically by the elements themselves\n    max_val = max(list_val, key=lambda i: (isinstance(i, int), i))\n    return max_val\nlist_val = ['Python', 3, 2, 4, 5, 'version']", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Python", 3.14, 5, "version", 10, 7.5, 2, "3.14"]]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    # Use list comprehension to find the cube of each element in the list\n    return [i ** 3 for i in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    # Return the larger of the two numbers\n    if a > b:\n        return a\n    else:\n        return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "from datetime import datetime", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "from typing import List, Tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    # Initialize count of pairs with odd XOR\n    count = 0\n    \n    # Iterate through each pair in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is odd\n            if ((arr[i] ^ arr[j]) & 1):\n                count += 1\n                \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def get_distance(a, b):\n    \"\"\"\n    Calculate the appropriately signed distance between two numbers.\n    \n    Args:\n        a (int or float): The first number.\n        b (int or float): The second number.\n        \n    Returns:\n        int or float: The distance between the two numbers with appropriate sign.\n    \"\"\"\n    if a == b:\n        return 0\n    elif (a < 0 and b < 0) or (a > 0 and b > 0):\n        if a < b:\n            return abs(a) - abs(b)\n        else:\n            return -(abs(a) - abs(b))\n    else:\n        return (max(a, b) - min(a, b)) * (-1 if a > b else 1)\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit(n):\n    # Convert the number to a string and return the first character as an integer\n    return int(str(abs(n))[0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split(string):\n    # Split the string into a list of characters\n    return list(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string(s):\n    # Toggle the case of each character in the string\n    toggled = ''.join(char.lower() if char.isupper() else char.upper() for char in s)\n    return toggled", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(size):\n    # Calculate the surface area of a cube\n    return 6 * size * size", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    # Subtract each element of the second list from the first list element-wise\n    return [a - b for a, b in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    # Use a generator expression to compute the elementwise AND operation\n    result = tuple(a & b for a, b in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    # Calculate the volume of a cone using the formula V = (1/3)\u03c0r\u00b2h\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    \"\"\"\n    Calculate the depth of a dictionary.\n    \n    :param d: Dictionary to calculate depth for.\n    :return: Depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict) or not d:\n        return 0\n    return 1 + max((dict_depth(value) for value in d.values()), default=0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"a": 1, "b": {"c": {"d": {}}}}]], "plus_fail_tests": [[{}]]}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    # Iterate through each element in the nested list\n    for element in nested_list:\n        # If the element is a list, extend the flat_list with its elements\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        else:\n            # If the element is not a list, append it to the flat_list\n            flat_list.append(element)\n    return flat_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract(test_list):\n    # Extract the first element from each sublist\n    res = [sub_list[0] for sub_list in test_list]\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate(num):\n    # Convert the number to a string to iterate over each digit\n    num_str = str(num)\n    # Iterate through each unique digit in the number\n    for digit in set(num_str):\n        # Count the frequency of the current digit in the number\n        if num_str.count(digit) > int(digit):\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    # Initialize variables to store the maximum sum so far and the current sum\n    max_so_far = 0\n    max_ending_here = 0\n    \n    # Iterate through the array\n    for i in range(0, n):\n        # Update the current sum\n        max_ending_here = max_ending_here + arr[i]\n        # If current sum is greater than the maximum sum so far, update it\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n        # If current sum becomes negative, reset it to 0\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_Digit(n):\n    # Return the last digit of the number\n    return abs(n) % 10", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    # Use the built-in min function to find the minimum of two numbers\n    return min(a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    # Use a list comprehension to filter out lowercase letters\n    result = [char for char in string if char.isupper() or not char.isalpha()]\n    # Join the list back into a string and return\n    return ''.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, c, height):\n    # Calculate the median length of the trapezium\n    median_length = (a + c) / 2\n    return median_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple(pairs):\n    # Calculate the product of each tuple and find the minimum product\n    min_product = min([x * y for x, y in pairs])\n    return min_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping(list1, list2):\n    # Check if any value in list1 exists in list2\n    return any(item in list2 for item in list1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to keep track of the occurrences\n    count = 0\n    # Iterate through each sublist in the given list\n    for sublist in lst:\n        # If the current sublist contains the specified element, increment the counter\n        if element in sublist:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_substring(s, start, length=None):\n    \"\"\"\n    Extracts a substring from the given string `s` starting at index `start`.\n    If `length` is provided, it extracts a substring of that length.\n    If `length` is not provided, it extracts the substring to the end of the string.\n    \n    Parameters:\n    s (str): The string to extract from.\n    start (int): The starting index of the substring.\n    length (int, optional): The length of the substring to extract.\n    \n    Returns:\n    str: The extracted substring.\n    \"\"\"\n    if length is None:\n        return s[start:]\n    else:\n        return s[start:start + length]\n\n# Test cases to verify the correctness of the function\ndef check():\n    test_cases = [\n        (\"hello\", 1, 2, \"ll\"),\n        (\"hello\", 1, None, \"ello\"),\n        (\"hello\", 0, 5, \"hello\"),\n        (\"hello\", 0, 0, \"\"),\n        (\"hello\", 5, 1, \"\"),\n        (\"hello\", -1, 1, \"o\"),\n        (\"hello\", -6, 3, \"hello\"),\n        (\"hello\", -6, None, \"hello\"),\n    ]\n    \n    all_passed = True\n    for s, start, length, expected in test_cases:\n        result = extract_substring(s, start, length)\n        if result != expected:\n            print(f\"Test failed for: extract_substring('{s}', {start}, {length}). Expected '{expected}', got '{result}'\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(nums):\n    # Use list comprehension to filter odd numbers\n    return [num for num in nums if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "def count_sequences(n):\n    # Base case: if n is 0, there's only one sequence: an empty sequence\n    if n == 0:\n        return 1\n    # If n is 1, there are two sequences: \"00\" and \"11\"\n    if n == 1:\n        return 2\n    # Recursive case: calculate the number of sequences for n-1\n    # and use it to calculate the number of sequences for n\n    return 2 * count_sequences(n - 1) + 2 * (n - 1)\n\n# Test cases to verify the solution\ndef test():\n    test_cases = [(1, 2), (2, 6), (3, 20)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = count_sequences(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Run the tests\ntest()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(input_list):\n    # Find the element with maximum length using max function with key=len\n    max_element = max(input_list, key=len)\n    return max_element", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def sum_within_range(x, y):\n    \"\"\"\n    Sums two integers x and y. If the sum is between 15 and 20 (inclusive of 15, exclusive of 20),\n    it returns 20 instead of the actual sum.\n    \n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    \n    Returns:\n    int: The sum of x and y, or 20 if the sum is between 15 and 20.\n    \"\"\"\n    total = x + y\n    if 15 <= total < 20:\n        return 20\n    else:\n        return total\n\n# Test cases to verify the correctness of the function\ndef check_function():\n    test_cases = [\n        (10, 5, 15),  # Sum is 15, should return 15\n        (10, 6, 16),  # Sum is 16, should return 16\n        (10, 15, 20), # Sum is 25, should return 25\n        (10, 10, 20), # Sum is 20, should return 20\n        (10, 11, 20)  # Sum is 21, should return 21\n    ]\n    \n    all_passed = True\n    for x, y, expected in test_cases:\n        result = sum_within_range(x, y)\n        if result != expected:\n            print(f\"Test failed for inputs ({x}, {y}). Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Running the check function to verify the solution\ncheck_function()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    # Iterate through the list and check if each element is less than or equal to the next\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split(lst):\n    # Use list comprehension to filter out only odd numbers\n    return [num for num in lst if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def drop_empty(colours):\n    # Filter out any key-value pairs where the value is None\n    return {k: v for k, v in colours.items() if v is not None}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    # Calculate the average of the sum of cubes\n    average = sum_of_cubes / n\n    return average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element(test_list, n):\n    # Extracts the nth element from each tuple in the list\n    res = [sub[n] for sub in test_list]\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    # Create a list of n empty dictionaries\n    result = [{} for _ in range(n)]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    # Calculate the median of three numbers\n    if (a <= b <= c) or (c <= b <= a):\n        return b\n    elif (b <= a <= c) or (c <= a <= b):\n        return a\n    else:\n        return c", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    # Sort the products in descending order and select the top n products\n    largest_products = sorted(products, reverse=True)[:n]\n    return largest_products", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size to half of the array length\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            # Save the current element\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next round\n    \n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def equation_parabola(x1, y1, a, b, c):\n    \"\"\"\n    Calculates the equation of a parabola given its focus (x1, y1) and directrix (ax + by + c = 0).\n    \n    Args:\n        x1 (float): x-coordinate of the focus.\n        y1 (float): y-coordinate of the focus.\n        a (float): Coefficient of x in the directrix equation.\n        b (float): Coefficient of y in the directrix equation.\n        c (float): Constant term in the directrix equation.\n        \n    Returns:\n        str: The equation of the parabola in the form 'ax^2 + by^2 + cx + dy + exy + f = 0'.\n    \"\"\"\n    t = a * a + b * b\n    a1 = t - (a * a)\n    b1 = t - (b * b)\n    c1 = (-2 * t * x1) - (2 * c * a)\n    d1 = (-2 * t * y1) - (2 * c * b)\n    e1 = -2 * a * b\n    f1 = (-c * c) + (t * x1 * x1) + (t * y1 * y1)\n    return f\"equation of parabola is {a1:.1f} x^2 + {b1:.1f} y^2 + {c1:.1f} x + {d1:.1f} y + {e1:.1f} xy + {f1:.1f} = 0.\"\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    # Convert the integer to a string, iterate over each character, convert it back to an integer, and sum them up\n    return sum(int(digit) for digit in str(n))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month):\n    # List of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    # Check if the given month is in the list\n    if month in months_with_31_days:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    # Convert each tuple in the lists to a sorted tuple to handle unordered elements\n    set1 = {tuple(sorted(t)) for t in list1}\n    set2 = {tuple(sorted(t)) for t in list2}\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Return the intersection as a frozenset to ensure immutability\n    return frozenset(intersection)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sum_even_factors(n):\n    \"\"\"\n    Calculate the sum of all even factors of a given number n.\n    \n    Args:\n        n (int): The number to find the sum of even factors for.\n        \n    Returns:\n        int: The sum of all even factors of n.\n    \"\"\"\n    sum_even = 0\n    for i in range(2, n + 1, 2):  # Start from 2 and increment by 2 to only check even numbers\n        if n % i == 0:\n            sum_even += i\n    return sum_even\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(lst):\n    # Use list comprehension to filter out odd numbers\n    return [num for num in lst if num % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    # Initialize the power of 2\n    power = 1\n    # Keep multiplying by 2 until it exceeds n\n    while power * 2 <= n:\n        power *= 2\n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise(test_tuple):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate through the tuple, stopping at the second-to-last element\n    for i in range(len(test_tuple) - 1):\n        # Add the current element and the next element, and append to the result list\n        result.append(test_tuple[i] + test_tuple[i + 1])\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "from collections import Counter", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(nums):\n    # Round each number in the list and calculate the sum\n    rounded_sum = sum(round(num) for num in nums)\n    # Multiply the sum by the length of the list\n    result = rounded_sum * len(nums)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def sublist(lst1, lst2):\n    \"\"\"\n    Check if lst1 is a sublist of lst2 considering the order of elements.\n    \n    :param lst1: List to check if it is a sublist.\n    :param lst2: List to check against.\n    :return: True if lst1 is a sublist of lst2, False otherwise.\n    \"\"\"\n    it = iter(lst2)\n    return all(item in it for item in lst1)\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(lst):\n    # Calculate the product of unique numbers in the list\n    product = 1\n    for num in set(lst):\n        product *= num\n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a given list of numbers while preserving the original order.\n    \n    Args:\n        nums (list): A list of integers.\n        \n    Returns:\n        list: A list of integers with duplicates removed.\n    \"\"\"\n    # Use a dictionary to track occurrences of each number\n    occurrences = {}\n    for num in nums:\n        occurrences[num] = occurrences.get(num, 0) + 1\n    \n    # Create a new list with numbers that occur exactly once\n    unique_list = [num for num in nums if occurrences[num] == 1]\n    \n    return unique_list\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through the lists using the index\n    for i in range(len(list1)):\n        # Append elements from each list in order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def flatten_tuples(nested_tuples):\n    \"\"\"\n    Flattens a list of nested tuples into a single list of values.\n    \n    Args:\n    nested_tuples (list): A list containing nested tuples.\n    \n    Returns:\n    list: A flattened list of values.\n    \"\"\"\n    result = []\n    for item in nested_tuples:\n        if isinstance(item, tuple):\n            result.extend(flatten_tuples(item))\n        else:\n            result.append(item)\n    return result\n\n# Test cases to verify the correctness of the function\ndef check_flatten_tuples():\n    test_cases = [\n        ([(4, (5, 'Gfg')), (7, (8, 6))], [4, 5, 'Gfg', 7, 8, 6]),\n        ((1, 2, 3, 4, 5), [1, 2, 3, 4, 5]),\n        ((1,), [1]),\n        ((1, (2, 3), 4), [1, 2, 3, 4]),\n        ((), []),\n    ]\n    \n    all_passed = True\n    for i, (input_data, expected) in enumerate(test_cases):\n        result = flatten_tuples(input_data)\n        if result != expected:\n            print(f\"Test case {i+1} failed: expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All test cases passed!\")\n    else:\n        print(\"Some test cases failed.\")\n\n# Running the check function to verify the solution\ncheck_flatten_tuples()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def factorial(x):\n    \"\"\"\n    This is a recursive function to find the factorial of an integer.\n    \"\"\"\n    if x == 1 or x == 0:\n        return 1\n    else:\n        # Recursive call to the function\n        return (x * factorial(x - 1))\n\n# Test the function with a few test cases\ndef check_factorial():\n    test_cases = [(7, 5040), (0, 1), (1, 1), (5, 120)]\n    all_passed = True\n    for num, expected in test_cases:\n        result = factorial(num)\n        if result != expected:\n            print(f\"Test failed for {num}: expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All tests passed!\")\n\n# Uncomment the line below to run the test function\n# check_factorial()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items(data, n):\n    # Sort the data based on the price in descending order\n    sorted_data = sorted(data, key=lambda x: x['price'], reverse=True)\n    # Return the first n items from the sorted list\n    return sorted_data[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number using dynamic programming.\n    \n    Args:\n    n (int): The position of the Catalan number to compute.\n    \n    Returns:\n    int: The nth Catalan number.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    catalan = [0] * (n + 1)\n    catalan[0], catalan[1] = 1, 1\n    \n    for i in range(2, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar(test_tup1, test_tup2):\n    # Find the symmetric difference between the two tuples\n    res = tuple(set(test_tup1) ^ set(test_tup2))\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import cmath", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple(list1):\n    # Convert the list to a tuple\n    return tuple(list1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    # Calculate the number of digits in the number\n    num_digits = len(str(n))\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum([int(digit) ** num_digits for digit in str(n)])\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    # Check if the list is empty or contains a single element\n    if len(nums) <= 1:\n        return 0\n    # Calculate the difference between the max and min values in the list\n    return max(nums) - min(nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "def calculate_consecutive_sum(limit):\n    \"\"\"\n    Calculates the sum of consecutive numbers (1 + 2 + 3 + ...) until the sum is at least equal to the limit.\n    \n    Args:\n        limit (int): The target sum limit.\n    \n    Returns:\n        tuple: A tuple containing the sum and the consecutive numbers string.\n    \"\"\"\n    base = 0\n    num = 1\n    num_total = 0\n    calculation = 'The consecutive sum: '\n    \n    while base < limit:\n        calculation += f\"{num} + \"\n        base += num\n        num += 1\n    \n    # Remove the last ' + ' from the calculation string\n    calculation = calculation[:-3]\n    calculation += f\" = {base}\"\n    \n    return base, calculation\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(test_tuple):\n    # Calculate the size of the tuple in bytes\n    return sys.getsizeof(test_tuple)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    # Split the array at the nth element and add the first part to the end\n    return arr[n:] + arr[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List(input_list):\n    # Swap the first and last elements of the list\n    input_list[0], input_list[-1] = input_list[-1], input_list[0]\n    return input_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums(lst, n):\n    # Use list comprehension to raise each element to the power of n\n    return [i**n for i in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def Split(numbers):\n    # Use list comprehension to filter even numbers\n    return [num for num in numbers if num % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "def radian_degree(degrees):\n    # Convert degrees to radians\n    radians = degrees * (3.141592653589793 / 180)\n    return radians", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    # Initialize the max value to a very low number\n    max_value = float('-inf')\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Check if the current row has enough elements\n        if n < len(row):\n            # Update max_value if the current element in the nth column is greater\n            max_value = max(max_value, row[n])\n    return max_value", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def find_median_sorted_arrays(nums1, nums2):\n    \"\"\"\n    Finds the median of two sorted arrays of different sizes.\n    \n    Args:\n        nums1 (List[int]): The first sorted array.\n        nums2 (List[int]): The second sorted array.\n        \n    Returns:\n        float: The median of the two arrays.\n    \"\"\"\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        # If partition_x is 0 it means nothing is there on left side. Use -inf for max_left_x\n        # If partition_x is length of input then there is nothing on right side. Use +inf for min_right_x\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            # We have partitioned array at correct place\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            # We are too far on right side for partition_x. Go on left side.\n            high = partition_x - 1\n        else:\n            # We are too far on left side for partition_x. Go on right side.\n            low = partition_x + 1\n\n# Test cases", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def ludic_numbers(n):\n    ludics = list(range(1, n + 1))\n    index = 1\n    while index < len(ludics):\n        step = ludics[index]\n        ludics = [num for i, num in enumerate(ludics) if i % step != 0]\n        index += 1\n    return ludics\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(n_list, L):\n    \"\"\"\n    Removes the K'th element from the given list and returns the updated list.\n    \n    Parameters:\n    n_list (list): The original list from which the K'th element will be removed.\n    L (int): The position (1-based index) of the element to be removed.\n    \n    Returns:\n    list: The updated list after removing the K'th element.\n    \"\"\"\n    # Adjusting the index to be 0-based for Python's list indexing\n    kth_index = L - 1\n    # Return a new list excluding the element at the kth index\n    return n_list[:kth_index] + n_list[kth_index + 1:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char_smallest_distance(str1):\n    \"\"\"\n    Finds the first repeated character in a given string where the index of the first occurrence is smallest.\n    \n    :param str1: Input string to search for the first repeated character.\n    :return: A tuple containing the first repeated character and its first occurrence index, or 'None' if no repetition is found.\n    \"\"\"\n    temp = {}\n    for index, ch in enumerate(str1):\n        if ch in temp:\n            return ch, temp[ch]\n        else:\n            temp[ch] = index\n    return 'None'\n\n# Test the function with different input strings.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    # Initialize variables to store the first even and first odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and first odd numbers\n    for num in lst:\n        if num % 2 == 0:  # Check if the number is even\n            if first_even is None:\n                first_even = num\n        else:  # The number is odd\n            if first_odd is None:\n                first_odd = num\n    \n    # Calculate the difference between the first even and first odd numbers\n    return first_even - first_odd if first_even is not None and first_odd is not None else None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    # Calculate the sum of the first n natural numbers\n    total_sum = n * (n + 1) // 2\n    # Calculate the average of the first n natural numbers\n    average = total_sum / n\n    return total_sum, average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    # Replace all spaces in the string with '%20'\n    return string.replace(' ', '%20')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    # Check if lists are of the same length\n    if len(list1) != len(list2):\n        return \"Lists are of different lengths.\"\n    # Use a list comprehension to divide elements of list1 by elements of list2\n    result = [i / j for i, j in zip(list1, list2)]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "class Solution:\n    def solve(self, nums):\n        dp = [1] * len(nums)\n        nums.sort()\n        n = len(nums)\n        if n <= 1:\n            return n\n        ans = 0\n        for i in range(1, n):\n            for j in range(0, i):\n                if nums[i] % nums[j] == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            ans = max(ans, dp[i])\n        return ans\n\n# Example usage:\nob = Solution()\nnums = [3, 6, 12, 24, 26, 39]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(str1):\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(str1.split()[::-1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(text, pattern):\n    # Use re.search to find the pattern in the text\n    match = re.search(pattern, text)\n    # If a match is found, return the matched substring and its start and end indices\n    if match:\n        return (match.group(), match.start(), match.end())\n    # If no match is found, return None\n    else:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def kth_element(a, b, k):\n    \"\"\"\n    Finds the k-th smallest element in the merged array of two sorted arrays.\n    \n    :param a: List[int] - First sorted array.\n    :param b: List[int] - Second sorted array.\n    :param k: int - The k-th position to find in the merged array.\n    :return: int - The k-th smallest element in the merged array.\n    \"\"\"\n    # Merge the two arrays\n    merged_array = a + b\n    # Sort the merged array\n    merged_array.sort()\n    # Return the k-th element (1-based index)\n    return merged_array[k - 1]\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def calculate_average(nums):\n    \"\"\"\n    Calculate the average value of the numbers in a given tuple of tuples.\n    \n    Args:\n    nums (tuple of tuples): A tuple containing multiple tuples of numbers.\n    \n    Returns:\n    tuple: A tuple containing the average values of the numbers at each position.\n    \"\"\"\n    # Use list comprehension to calculate the sum of elements for each position across all inner tuples,\n    # and then divide by the number of inner tuples to get the average for each position.\n    result = [sum(x) / len(x) for x in zip(*nums)]\n    return tuple(result)\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    ((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)),\n    ((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3))\n]\n\n# Expected results for the test cases\nexpected_results = [\n    (30.5, 34.25, 27.0, 23.25),\n    (25.5, -18.0, 3.75)\n]\n\n# Check function to verify the results\ndef check():\n    all_passed = True\n    for i, test_case in enumerate(test_cases):\n        result = calculate_average(test_case)\n        if result != expected_results[i]:\n            print(f\"Test case {i+1} failed: expected {expected_results[i]}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\n# Run the check function\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    # Initialize two empty lists to hold the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate through each sublist in the input list\n    for sub_list in lst:\n        # Append the first element of the sublist to the first_elements list\n        first_elements.append(sub_list[0])\n        # Append the second element of the sublist to the second_elements list\n        second_elements.append(sub_list[1])\n    \n    # Return a list containing the two lists: first_elements and second_elements\n    return [first_elements, second_elements]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(n):\n    # Check if the number is divisible by 2\n    return n % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(string):\n    # Convert the given string to uppercase\n    return string.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for i in range(n+1)] for i in range(n+1)]\n    \n    # Base case\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        # Explicitly fill for small n\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # Return the nth Bell number\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cummulative_sum(lst):\n    # Calculate the sum of all elements in the tuple list\n    total_sum = sum(sum(t) for t in lst)\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    # Check if n is less than 2, which are not prime numbers\n    if n < 2:\n        return False\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple_a, tuple_b):\n    # Use a generator expression to perform element-wise modulo operation\n    result = tuple(a % b for a, b in zip(tuple_a, tuple_b))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "def triangle_area(radius):\n    # Return None for negative radius as radius cannot be negative\n    if radius < 0:\n        return None\n    # Area of the largest inscribed triangle in a semicircle is (radius^2)\n    return radius ** 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num(str1):\n    # Extract all non-digit characters and all digit characters separately\n    non_digit = [char for char in str1 if not char.isdigit()]\n    digits = [char for char in str1 if char.isdigit()]\n    # Concatenate non-digit characters with digit characters\n    return ''.join(non_digit + digits)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(text):\n    # Check if 'z' is present in the string excluding the first and last character\n    return 'z' in text[1:-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "# Define a function to create a dictionary mapping student names to their grades\ndef create_student_grade_dict(names, grades):\n    \"\"\"\n    Create a dictionary that maps student names to their grades.\n    \n    :param names: List of student names.\n    :param grades: List of student grades corresponding to the names.\n    :return: Dictionary mapping student names to their grades.\n    \"\"\"\n    return dict(zip(names, grades))\n\n# Define a function to add a new student and their grade to the existing dictionary\ndef add_student(grade_dict, name, grade):\n    \"\"\"\n    Add a new student and their grade to the existing dictionary.\n    \n    :param grade_dict: Existing dictionary mapping student names to their grades.\n    :param name: Name of the new student.\n    :param grade: Grade of the new student.\n    :return: Updated dictionary with the new student added.\n    \"\"\"\n    grade_dict[name] = grade\n    return grade_dict\n\n# Example usage:\n# Create a dictionary for the initial students\nstudents_grades = create_student_grade_dict(\n    ['Ashley', 'David', 'Edward', 'Zoe'],\n    [0.92, 0.72, 0.88, 0.77]\n)\n\n# Add a new student, Ryan, with grade 0.34\nstudents_grades = add_student(students_grades, 'Ryan', 0.34)\n\n# Print the resulting dictionary", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements from the start of the array up to the position k\n    arr[:k] = reversed(arr[:k])\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    # Create a new list to store non-zero elements\n    non_zero = [element for element in lst if element != 0]\n    # Append zeros to the end of the non-zero list\n    non_zero.extend([0] * lst.count(0))\n    return non_zero", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "def extract_quoted_strings(text):\n    \"\"\"\n    Extracts all strings enclosed in double quotes from the input text.\n    \n    Args:\n        text (str): The text to extract quoted strings from.\n        \n    Returns:\n        list: A list of strings found between double quotes.\n    \"\"\"\n    import re\n    # Using regex to find all substrings enclosed in double quotes\n    quoted_strings = re.findall(r'\"(.*?)\"', text)\n    return quoted_strings\n\n# Check function to verify the correctness of the solution\ndef check():\n    test_cases = [\n        (\"SetVariables \\\"a\\\" \\\"b\\\" \\\"c\\\"\", [\"a\", \"b\", \"c\"]),\n        (\"\\\"Hello\\\" world \\\"Python\\\" is great\", [\"Hello\", \"Python\"]),\n        (\"No quotes here\", []),\n        ('\"Multiple\" \"quotes\" in \"one\" string', [\"Multiple\", \"quotes\", \"one\"])\n    ]\n    \n    all_passed = True\n    for text, expected in test_cases:\n        result = extract_quoted_strings(text)\n        if result != expected:\n            print(f\"Test failed for: {text}. Expected {expected}, got {result}\")\n            all_passed = False\n    \n    if all_passed:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Running the check function to validate the solution\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces(str1):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in str1:\n        if char == ' ':\n            result += '_'\n        else:\n            result += ' ' if char == '_' else char\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(arr, n): \n    # Calculate the sum of XOR for all pairs\n    xor_sum = 0\n    for i in range(n): \n        for j in range(i + 1, n): \n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(test_tuple, test_dict):\n    # Add the dictionary to the tuple\n    result = test_tuple + (test_dict,)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar(input_str):\n    # Replace spaces, commas, and dots with a colon\n    result = input_str.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(side_length):\n    # Calculate the area of a tetrahedron given the side length\n    area = math.sqrt(3) * (side_length ** 2)\n    return area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort(nums):\n    # Function to heapify a subtree rooted with node i which is an index in nums[]\n    def heapify(nums, n, i):\n        largest = i  # Initialize largest as root\n        left = 2 * i + 1  # left = 2*i + 1\n        right = 2 * i + 2  # right = 2*i + 2\n\n        # See if left child of root exists and is greater than root\n        if left < n and nums[i] < nums[left]:\n            largest = left\n\n        # See if right child of root exists and is greater than root\n        if right < n and nums[largest] < nums[right]:\n            largest = right\n\n        # Change root, if needed\n        if largest != i:\n            nums[i], nums[largest] = nums[largest], nums[i]  # swap\n\n            # Heapify the root.\n            heapify(nums, n, largest)\n\n    # Build a maxheap.\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        nums[i], nums[0] = nums[0], nums[i]  # swap\n        heapify(nums, i, 0)\n\n    return nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through the tuple, stopping at the second last element\n    for i in range(len(t) - 1):\n        # Multiply the current element with the next one and append to the result list\n        result.append(t[i] * t[i + 1])\n    # Convert the result list to a tuple and return it\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    # Check if both lists have the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    # Sum the corresponding elements of the lists\n    return [a + b for a, b in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    # Initialize the start and end pointers\n    start, end = 0, len(arr) - 1\n    \n    # Loop until the start pointer exceeds the end pointer\n    while start <= end:\n        mid = start + (end - start) // 2  # Calculate the middle index\n        \n        # Check if the middle element is the target\n        if arr[mid] == target:\n            # If it's the first element or the previous element is not the target, return mid\n            if mid == 0 or arr[mid - 1] != target:\n                return mid\n            else:\n                # Otherwise, continue searching in the left half\n                end = mid - 1\n        elif arr[mid] < target:\n            # If the middle element is less than the target, search in the right half\n            start = mid + 1\n        else:\n            # If the middle element is greater than the target, search in the left half\n            end = mid - 1\n    \n    # If the target is not found, return -1\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r, h):\n    # Calculate the lateral surface area of a cone\n    lateral_surface_area = math.pi * r * math.sqrt(r * r + h * h)\n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    # Initialize an empty list to store the result\n    result = []\n    # Append the first element of the list to the result\n    if lst:\n        result.append(lst[0])\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(lst)):\n        # If the current element is not the same as the last element in the result, append it\n        if lst[i] != lst[i-1]:\n            result.append(lst[i])\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sum_name_lengths(names):\n    \"\"\"\n    Sums the length of a list of names after removing those that start with lowercase letters.\n    \n    Args:\n    names (list): A list of strings representing names.\n    \n    Returns:\n    int: The sum of the lengths of the names that start with an uppercase letter.\n    \"\"\"\n    # Filter the names using a lambda function to include only names that start with an uppercase letter\n    filtered_names = list(filter(lambda el: el[0].isupper() and el[1:].islower(), names))\n    # Calculate the total length of the filtered names\n    total_length = sum(len(name) for name in filtered_names)\n    return total_length\n\n# Test the function with provided data points\nsample_names = ['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']\nresult = sum_name_lengths(sample_names)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_mid_bits(n):\n    \"\"\"\n    Toggles all bits of a given number except the first and last bits.\n    \n    Args:\n        n (int): The number whose mid bits are to be toggled.\n        \n    Returns:\n        int: The number after toggling all the bits of a given number except the first and last bits.\n    \"\"\"\n    # Calculate the number of bits in the given number\n    num_bits = n.bit_length()\n    \n    # If the number has less than 3 bits, toggling all mid bits doesn't make sense\n    if num_bits <= 2:\n        return n\n    \n    # Create a mask that has all bits set to 1 except the first and last bits\n    mask = (1 << (num_bits - 1)) - 2  # This creates a mask like 111...000 (all mid bits set to 1)\n    \n    # Toggle the mid bits by using XOR operation with the mask\n    result = n ^ mask\n    \n    return result\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    # Calculate the nth nonagonal number using the formula\n    nonagonal_number = (7 * n * n - 5 * n) // 2\n    return nonagonal_number", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    # Check if cost price is equal to selling price\n    if cost_price == selling_price:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(arr):\n    # Initialize the sum to 0\n    sum_prod = 0\n    # Iterate over all possible subarray lengths\n    for i in range(len(arr)):\n        product = 1\n        for j in range(i, len(arr)):\n            product *= arr[j]\n            sum_prod += product\n    return sum_prod", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def max_average_path(matrix):\n    \"\"\"\n    Finds the path with the maximum average value in a given N*N matrix.\n    The path starts from the top-left corner and ends at the bottom-right corner,\n    moving only right or down.\n    \"\"\"\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize the first row and column\n    dp[0][0] = matrix[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    \n    # Fill the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the maximum average path\n    total_sum = dp[n-1][n-1]\n    num_cells = 2 * n - 1\n    max_avg = total_sum / num_cells\n    \n    return max_avg\n\n# Test the function with provided data points", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    # Calculate the power of the base\n    num = base ** power\n    # Convert the number to a string to iterate over each digit\n    num_str = str(num)\n    # Calculate the sum of the digits\n    sum_of_digits = sum(int(digit) for digit in num_str)\n    return sum_of_digits", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    # Initialize a counter to keep track of the indices with matching values\n    count = 0\n    # Iterate through the lists and compare elements at each index\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary\n    res = {}\n    # Iterate through the tuple, stepping by 2 to get key-value pairs\n    for idx in range(0, len(test_tup) - 1, 2):\n        res[test_tup[idx]] = test_tup[idx + 1]\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(str1):\n    # Check if the string is empty or has only one character\n    if len(str1) <= 1:\n        return True\n    # Compare the first character with the rest of the string\n    for i in range(1, len(str1)):\n        if str1[0] != str1[i]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(nums_str):\n    \"\"\"\n    Sorts a list of strings containing numeric values numerically.\n    \n    Args:\n        nums_str (list): A list of strings representing numbers.\n    \n    Returns:\n        list: A sorted list of integers.\n    \"\"\"\n    # Convert each string in the list to an integer and sort the list\n    result = sorted(nums_str, key=lambda el: int(el))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["4", "12", "45", "7", "0", "100", "200", "-12", "-500"]]], "plus_fail_tests": [[["10000000000", "99999999", "88888888", "7777777", "666666", "-55555", "-4444", "-333", "222", "111", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]]]}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(item is None for item in test_tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    # Handle the case where the list is empty or n is 0\n    if not lst or n == 0:\n        return lst\n    # Normalize the rotation count in case it's greater than the list length\n    n = n % len(lst)\n    # Rotate the list by slicing and concatenating\n    return lst[-n:] + lst[:-n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_strong_numbers(numbers):\n    def is_strong(num):\n        temp = num\n        sum_factorial = 0\n        while temp > 0:\n            digit = temp % 10\n            sum_factorial += factorial(digit)\n            temp //= 10\n        return sum_factorial == num\n\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return [num for num in numbers if is_strong(num)]\n\n# Example usage:\nnumbers = [145, 375, 144]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements of the tuple\n    lst.extend(tpl)\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(string):\n    # Check if the string starts with a vowel using regex\n    return bool(re.match(r'^[aeiouAEIOU]', string))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion(lst, num):\n    # Iterate through the list to find the correct insertion point\n    for i in range(len(lst)):\n        if lst[i] >= num:\n            return i\n    # If the number is greater than all elements, return the length of the list\n    return len(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n    \n    Args:\n    n (int): The index of the Jacobsthal number to compute.\n    \n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + 2 * b\n        return b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "import re\ndef is_decimal(num):\n    \"\"\"\n    Checks if the provided string represents a decimal number with a precision of 2.\n    \n    Args:\n    num (str): The string to check.\n    \n    Returns:\n    bool: True if the string represents a decimal with a precision of 2, False otherwise.\n    \"\"\"\n    dnumre = re.compile(r\"^[0-9]+(\\.[0-9]{1,2})?$\")\n    result = dnumre.search(num)\n    return bool(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_duplicates(tuples_list):\n    \"\"\"\n    Removes duplicate tuples from the given list of tuples.\n    \n    Args:\n        tuples_list (list): A list of tuples to remove duplicates from.\n    \n    Returns:\n        list: A list of tuples with duplicates removed.\n    \"\"\"\n    seen = set()\n    result = []\n    for t in tuples_list:\n        if t not in seen:\n            seen.add(t)\n            result.append(t)\n    return result\n\n# Test cases to verify the solution", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_smallest_k_digit_number_divisible_by_x(x, k):\n    \"\"\"\n    Finds the smallest K-digit number that is divisible by X.\n    \n    :param x: Integer, the divisor.\n    :param k: Integer, the number of digits.\n    :return: The smallest K-digit number divisible by X.\n    \"\"\"\n    # Calculate the smallest K-digit number\n    min_k_digit = 10**(k-1)\n    \n    # Find the smallest number >= min_k_digit that is divisible by x\n    result = (min_k_digit + x - 1) // x * x\n    return result\n\n# Example usage:", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(nums):\n    # Initialize the smallest and second smallest to infinity\n    smallest = second_smallest = float('inf')\n    \n    for num in nums:\n        if num < smallest:\n            # Update second smallest before updating smallest\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            # Update second smallest if num is between smallest and second smallest\n            second_smallest = num\n    \n    # If second smallest is still infinity, it means there wasn't a second unique smallest number\n    return second_smallest if second_smallest != float('inf') else None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def is_balanced(expression):\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to hold matching pairs\n    matching_bracket = {')': '(', '}': '{', ']': '['}\n    \n    # Traverse each character in the expression\n    for char in expression:\n        # If it's an opening bracket, push it onto the stack\n        if char in matching_bracket.values():\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in matching_bracket:\n            # Check if the stack is empty or the top of the stack doesn't match\n            if not stack or stack[-1] != matching_bracket[char]:\n                return False\n            # If it matches, pop the top of the stack\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched\n    return not stack\n\n# Test cases\ntest_cases = [\n    \"((()))()()\",  # Balanced\n    \"())((())\",     # Not Balanced\n    \"[(])\",         # Not Balanced\n    \"{}[]()\",       # Balanced\n]\n\n# Check each test case\nfor i, test in enumerate(test_cases):\n    print(f\"Test case {i+1}: {test} -> {'Balanced' if is_balanced(test) else 'Not Balanced'}\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "from collections import Counter", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "from collections import Counter", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(input_list):\n    # Initialize an empty list to store the pairs\n    pairs = []\n    # Iterate through the list, stopping at the second-to-last element\n    for i in range(len(input_list) - 1):\n        # Append the current element and the next element as a tuple to the pairs list\n        pairs.append((input_list[i], input_list[i + 1]))\n    return pairs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    # Initialize a counter to count digits\n    count = 0\n    # Iterate through each character in the string\n    for char in string:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    # Calculate the sum of the fourth power of the first n odd natural numbers\n    return sum(i**4 for i in range(1, 2*n, 2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count(arr, target_sum):\n    \"\"\"\n    Counts the number of pairs in the list whose sum is equal to target_sum.\n\n    :param arr: List of integers.\n    :param target_sum: The target sum for pairs.\n    :return: The count of pairs whose sum is equal to target_sum.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] + arr[j] == target_sum:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element(test_list):\n    # Check if all elements in the list are the same by comparing the set length\n    return len(set(test_list)) == 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def get_nth_fibonacci(n):\n    \"\"\"\n    Calculate the nth Fibonacci number using dynamic programming.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\n\n# Test cases to verify the correctness of the function\ndef check():\n    test_cases = [(0, 0), (1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13)]\n    all_passed = True\n    for n, expected in test_cases:\n        result = get_nth_fibonacci(n)\n        if result != expected:\n            print(f\"Test failed for n={n}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(str1):\n    # Remove all whitespaces from the string using replace method\n    result = str1.replace(' ', '')\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    # Check if the month has 30 days\n    if month in {4, 6, 9, 11}:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k(test_list, K): \n    # Sort the list of tuples based on the second element of each tuple\n    # and then select the first K elements from the sorted list.\n    res = sorted(test_list, key=lambda x: x[1])[:K] \n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    # Remove the parentheses and split the string by commas\n    tuple_str = tuple_str.strip('()').split(',')\n    # Convert each element to an integer and return as a tuple\n    return tuple(int(num.strip()) for num in tuple_str)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and odd numbers\n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        # Stop iteration if both first even and odd numbers are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Calculate the product of the first even and odd numbers\n    return first_even * first_odd if first_even is not None and first_odd is not None else None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "import bisect", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(input_list):\n    \"\"\"\n    Counts the number of lists within the given list of lists.\n    \n    Parameters:\n    input_list (list): A list containing other lists.\n    \n    Returns:\n    int: The number of lists within the input list.\n    \"\"\"\n    return len(input_list)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 3, [4, [5, [6, [7, [8, 9]]]]]]]]}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(str_list):\n    \"\"\"\n    Counts the number of pairs of strings in the list that are reverses of each other.\n    \n    :param str_list: List of strings to check for reverse pairs.\n    :return: Number of reverse string pairs.\n    \"\"\"\n    reverse_count = {}\n    for s in str_list:\n        reversed_s = s[::-1]\n        reverse_count[reversed_s] = reverse_count.get(reversed_s, 0) + 1\n    return sum(count // 2 for count in reverse_count.values())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["julia", "best", "tseb", "for", "ailuj"]]], "plus_fail_tests": [[["app", "123", "ad3", "apple", "elppa", "xyx", "bat", "tab", "tacocat", "racecar", "abc", "zyx", "def", "fed"]]]}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def odd_even_position(nums):\n    \"\"\"\n    Checks if every even index contains an even number and every odd index contains an odd number.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    bool: True if the condition is met, False otherwise.\n    \"\"\"\n    return all(nums[i] % 2 == i % 2 for i in range(len(nums)))\n\n# Test cases to verify the correctness of the function\ntest_cases = [\n    ([2, 1, 4, 3, 6, 7, 6, 3], True),\n    ([2, 1, 4, 3, 6, 7, 6, 4], False),\n    ([2, 1, 4, 3, 6, 7, 6, 4], True),\n    ([2, 1, 4, 3, 6, 7, 6, 4], True),\n    ([2, 1, 4, 3, 6, 7, 6, 4], True),\n]\n\n# Running the test cases\nall_passed = True\nfor nums, expected in test_cases:\n    result = odd_even_position(nums)\n    if result != expected:\n        print(f\"Test failed for: {nums}. Expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All tests passed!\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    # Iterate through the array to check the heap property\n    for i in range(len(arr)):\n        # Check if the left child index is within bounds\n        if (2 * i + 1) < len(arr) and arr[i] > arr[2 * i + 1]:\n            return False\n        # Check if the right child index is within bounds\n        if (2 * i + 2) < len(arr) and arr[i] > arr[2 * i + 2]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "from itertools import groupby\ndef pack_consecutive_duplicates(lst):\n    \"\"\"\n    This function takes a list of elements and returns a new list where consecutive duplicates are packed into sublists.\n    \n    Example:\n    >>> pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])\n    [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    \"\"\"\n    return [list(group) for key, group in groupby(lst)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    # Ensure the number is within 32-bit range\n    n &= 0xFFFFFFFF\n    \n    # Perform the left rotation\n    d = d % 32  # To handle cases where d > 32\n    rotated_number = ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF\n    \n    return rotated_number", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple(list1, str1):\n    # Create a new tuple by combining the elements of the list and the string\n    result = tuple(list1) + (str1,)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum(dict1):\n    # Calculate the sum of all values in the dictionary\n    sum_values = sum(dict1.values())\n    return sum_values", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    # Determine the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "from itertools import combinations", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last(arr, x):\n    # Initialize the result variable to -1\n    result = -1\n    # Iterate through the array\n    for i in range(len(arr)):\n        # If the current element matches the target element, update result\n        if arr[i] == x:\n            result = i\n    # Return the last position of the target element\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    # Initialize a dictionary to store the count of each tuple\n    count_dict = {}\n    # Iterate through each sublist in the provided list\n    for sublist in lst:\n        # Convert the sublist to a tuple and count its occurrences\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "import re", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    # Initialize count of divisors\n    count = 0\n    # Iterate from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor\n            count += 1  # Increment count\n            if i != n // i:  # Check if n/i is a different divisor\n                count += 1  # Increment count if so\n    return count % 2 == 0  # Return True if count is even", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    # Initialize the sum to 0\n    total_sum = 0\n    # Calculate the number of elements in the array\n    n = len(arr)\n    # Iterate over all possible starting points of subarrays\n    for i in range(n):\n        # Calculate the sum of the current subarray\n        current_sum = 0\n        # Iterate over all possible ending points of subarrays starting from i\n        for j in range(i, n):\n            # Include the current element in the subarray\n            current_sum += arr[j]\n            # Check if the length of the subarray is odd\n            if (j - i + 1) % 2 == 1:\n                # Add the sum of the current subarray to the total sum\n                total_sum += current_sum\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    # Calculate the sum of the array elements\n    return sum(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    # Split the string into words\n    words = string.split()\n    # Filter out words with length k\n    filtered_words = [word for word in words if len(word) != k]\n    # Join the filtered words back into a string\n    result = ' '.join(filtered_words)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(x, y, z):\n    # Create a set containing the unique values of x, y, and z\n    result = set([x, y, z])\n    # Check if the length of the set is equal to 3\n    if len(result) == 3:\n        # If the set contains three unique values, return 0\n        return 0\n    else:\n        # If the set does not contain three unique values, return the difference between 4 and the set length\n        return (4 - len(result))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def find_max_uppercase_run(input_string):\n    max_length = 0\n    current_length = 0\n\n    for char in input_string:\n        if char.isupper():\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n\n    return max_length\n\n# Test cases\ntest_cases = [\n    ('GeEKSForGEEksISBESt', 5),\n    ('ThisIsGeeksforGeeks!, 123', 4),\n    ('geeksgeeksisbestforgeeks', 0),\n    ('GEEKS', 5),\n    ('g', 0),\n    ('', 0),\n]\n\nall_passed = True\nfor test_str, expected in test_cases:\n    result = find_max_uppercase_run(test_str)\n    if result != expected:\n        print(f\"Test failed for: {test_str}. Expected {expected}, got {result}\")\n        all_passed = False\n\nif all_passed:\n    print(\"All tests passed!\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "def is_perfect_square(n):\n    # Check if n is less than 0, it cannot be a perfect square\n    if n < 0:\n        return False\n    # Calculate the square root of n and check if it's an integer\n    root = n ** 0.5\n    return root.is_integer()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple and return the result\n    return K in test_tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(test_tup1, test_tup2):\n    # Check if all elements in test_tup2 are less than the corresponding elements in test_tup1\n    res = all(el2 < el1 for el1, el2 in zip(test_tup1, test_tup2))\n    return res", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    # Iterate through the list to find the first odd number\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None  # Return None if no odd number is found", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of its elements\n    max_list = max(lists, key=sum)\n    return max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(nums):\n    # Iterate through the list and check if any number is even\n    for num in nums:\n        if num % 2 == 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(start_num, end_num):\n    \"\"\"\n    This function returns a list of numbers within the range of start_num to end_num (inclusive)\n    where each number is divisible by every digit it contains.\n    \"\"\"\n    return [n for n in range(start_num, end_num + 1) if not any(map(lambda x: int(x) == 0 or n % int(x) != 0, str(n)))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    # Calculate the sum of all odd numbers in the range [l, r]\n    return sum([i for i in range(l, r + 1) if i % 2 != 0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def find_adjacent_coordinates(tup):\n    \"\"\"\n    Given a tuple representing a coordinate, returns all adjacent coordinates.\n    Adjacency is defined as coordinates that share at least one index with the given coordinate,\n    differing by exactly one unit.\n    \"\"\"\n    dimensions = len(tup)\n    adjacent_coords = []\n    for i in range(dimensions):\n        for offset in [-1, 1]:\n            new_coord = list(tup)\n            new_coord[i] += offset\n            adjacent_coords.append(new_coord)\n    return adjacent_coords\n\n# Test cases to verify the solution\ntest_cases = [((1, 2, 3), [[0, 2, 3], [2, 2, 3], [1, 1, 3], [1, 3, 3], [1, 2, 2], [1, 2, 4]]),\n              ((5, 6), [[4, 6], [6, 6], [5, 5], [5, 7], [5, 6]])]\n\ndef check_solution():\n    all_passed = True\n    for tup, expected in test_cases:\n        result = find_adjacent_coordinates(tup)\n        if sorted(result) != sorted(expected):\n            print(f\"Test failed for input {tup}. Expected {expected}, got {result}\")\n            all_passed = False\n    if all_passed:\n        print(\"All test cases passed!\")\n\ncheck_solution()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    # Base cases for the first two Lucas numbers\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    # Recursive call to find the n'th Lucas number\n    return find_lucas(n - 1) + find_lucas(n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "from itertools import combinations, combinations_with_replacement", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    # Initialize sum to 0\n    sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the even number (2 * i)\n        even_number = 2 * i\n        # Add the fifth power of the even number to the sum\n        sum += even_number ** 5\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}, "pass_at_k": {"base": {"pass@1": 0.7248677248677249}, "plus": {"pass@1": 0.7195767195767195}}}